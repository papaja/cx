import { VDOM } from "cx-react";
import { NumberCulture, DateTimeCulture } from "intl-io";

function _defineProperties(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, descriptor.key, descriptor);
	}
}

function _createClass(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties(Constructor, staticProps);
	return Constructor;
}

function _defineProperty(obj, key, value) {
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value: value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}

	return obj;
}

function _extends() {
	_extends =
		Object.assign ||
		function(target) {
			for (var i = 1; i < arguments.length; i++) {
				var source = arguments[i];

				for (var key in source) {
					if (Object.prototype.hasOwnProperty.call(source, key)) {
						target[key] = source[key];
					}
				}
			}

			return target;
		};

	return _extends.apply(this, arguments);
}

function _objectSpread(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? arguments[i] : {};
		var ownKeys = Object.keys(source);

		if (typeof Object.getOwnPropertySymbols === "function") {
			ownKeys = ownKeys.concat(
				Object.getOwnPropertySymbols(source).filter(function(sym) {
					return Object.getOwnPropertyDescriptor(source, sym).enumerable;
				})
			);
		}

		ownKeys.forEach(function(key) {
			_defineProperty(target, key, source[key]);
		});
	}

	return target;
}

function _inheritsLoose(subClass, superClass) {
	subClass.prototype = Object.create(superClass.prototype);
	subClass.prototype.constructor = subClass;
	subClass.__proto__ = superClass;
}

function _setPrototypeOf(o, p) {
	_setPrototypeOf =
		Object.setPrototypeOf ||
		function _setPrototypeOf(o, p) {
			o.__proto__ = p;
			return o;
		};

	return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
	if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	if (Reflect.construct.sham) return false;
	if (typeof Proxy === "function") return true;

	try {
		Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
		return true;
	} catch (e) {
		return false;
	}
}

function _construct(Parent, args, Class) {
	if (isNativeReflectConstruct()) {
		_construct = Reflect.construct;
	} else {
		_construct = function _construct(Parent, args, Class) {
			var a = [null];
			a.push.apply(a, args);
			var Constructor = Function.bind.apply(Parent, a);
			var instance = new Constructor();
			if (Class) _setPrototypeOf(instance, Class.prototype);
			return instance;
		};
	}

	return _construct.apply(null, arguments);
}

function isString(s) {
	return typeof s === "string";
}

function isFunction(f) {
	return typeof f === "function";
}

function isArray(a) {
	return Array.isArray(a);
}

var componentAlias = {};
var Component =
	/*#__PURE__*/
	(function() {
		function Component(config) {
			if (config && config.$props) {
				Object.assign(config, config.$props);
				delete config.$props;
			}

			Object.assign(this, config);
		}

		Component.alias = function alias(_alias, type) {
			var _this = this;

			if (type) {
				type.prototype.componentAlias = _alias;
				componentAlias[this.namespace + _alias] = type;
			} else //decorator usage
				return function(t) {
					_this.alias(_alias, t);

					return t;
				};
		};

		Component.create = function create(typeAlias, config, more) {
			var _this2 = this;

			if (!typeAlias) return this.factory(typeAlias, config, more);
			if (typeAlias.isComponent) return typeAlias;
			if (isComponentFactory(typeAlias)) return this.create(typeAlias.create(config));
			if (isArray(typeAlias))
				return typeAlias.map(function(c) {
					return _this2.create(c, config, more);
				});
			if (typeAlias.$type) return this.create(typeAlias.$type, typeAlias, config);
			if (typeAlias.type) return this.create(typeAlias.type, typeAlias, config);
			var cmpType, alias;
			if (typeAlias.isComponentType) cmpType = typeAlias;
			else if (isFunction(typeAlias)) {
				if (this.factory) return this.factory(typeAlias, config, more);
				throw new Error("Unsupported component type " + typeAlias + ".");
			} else if (isString(typeAlias)) {
				alias = this.namespace + typeAlias;
				cmpType = componentAlias[alias];

				if (!cmpType) {
					if (typeAlias && this.factory) return this.factory(typeAlias, config, more);
					throw new Error("Unknown component alias " + alias + ".");
				}
			} else if (typeof typeAlias == "object") {
				cmpType = typeAlias.type || typeAlias.$type;

				if (!cmpType) {
					cmpType = this;
					more = more ? Object.assign({}, config, more) : config;
					config = typeAlias;
				}
			}
			if (isArray(config))
				return config.map(function(cfg) {
					return _this2.create(cmpType, cfg, more);
				});
			var cfg = config;
			if (more) cfg = Object.assign({}, config, more);
			var cmp = new cmpType(cfg);
			if (cmpType.autoInit && cmp.init) cmp.init();
			return cmp;
		};

		return Component;
	})();
Component.prototype.isComponent = true;
Component.isComponentType = true;
Component.namespace = "";
Component.autoInit = false;

Component.factory = function(alias, config, more) {
	throw new Error("Unknown component alias " + alias + ".");
};
function isComponentFactory(factory) {
	return factory && factory.$isComponentFactory;
}

var cssHelperCache = {};
var CSSHelper =
	/*#__PURE__*/
	(function() {
		function CSSHelper() {}

		CSSHelper.get = function get(code) {
			var helper = cssHelperCache[code];
			if (!helper) throw new Error("Unknown CSS helper '" + code + "'.");
			return helper;
		};

		CSSHelper.register = function register(code, helper) {
			cssHelperCache[code] = helper;
		};

		CSSHelper.alias = function alias(code, helper) {
			cssHelperCache[code] = helper;
		};

		return CSSHelper;
	})();

function parseStyle(str) {
	if (typeof str != "string") return str;
	var style = {},
		parts = str.split(";");

	for (var i = 0; i < parts.length; i++) {
		var part = parts[i];
		var colonIndex = part.indexOf(":");
		if (colonIndex == -1) continue;
		var name = part.substring(0, colonIndex).trim();
		var value = part.substring(colonIndex + 1).trim();
		name = name
			.split("-")
			.map(function(p, i) {
				return i == 0 ? p : p[0].toUpperCase() + p.substring(1);
			})
			.join("");
		style[name] = value;
	}

	return style;
}

function push(list, item) {
	if (!item) return list;
	if (!list) list = [];
	list.push(item);
	return list;
}

function pushMore(list, itemArray) {
	if (!itemArray || itemArray.length == 0) return list;
	if (!list) list = [];
	list.push.apply(list, itemArray);
	return list;
}

function pushMap(list, itemArray, mapF) {
	return itemArray ? pushMore(list, itemArray.map(mapF)) : list;
}

function join(list) {
	return list ? list.join(" ") : null;
}

var CSS =
	/*#__PURE__*/
	(function() {
		function CSS() {}

		CSS.resolve = function resolve() {
			var list, type, arg, i, key;

			for (i = 0; i < arguments.length; i++) {
				arg = arguments[i];

				if (arg) {
					type = typeof arg;
					if (type == "string") list = push(list, arg);
					else if (type == "object") {
						if (isArray(arg)) list = pushMore(list, this.resolve.apply(this, arg));
						else
							for (key in arg) {
								if (arg[key]) list = push(list, key);
							}
					}
				}
			}

			return list;
		};

		CSS.block = function block(baseClass, styleModifiers, stateModifiers) {
			var _this = this;

			var list;
			if (baseClass) list = push(list, this.classPrefix + "b-" + baseClass);
			list = pushMap(list, this.resolve(styleModifiers), function(m) {
				return _this.classPrefix + "m-" + m;
			});
			list = pushMap(list, this.resolve(stateModifiers), function(m) {
				return _this.classPrefix + "s-" + m;
			});
			return join(list);
		};

		CSS.element = function element(baseClass, elementClass, stateModifiers) {
			var _this2 = this;

			var list;
			if (baseClass && elementClass) list = push(list, this.classPrefix + "e-" + baseClass + "-" + elementClass);
			list = pushMap(list, this.resolve(stateModifiers), function(m) {
				return _this2.classPrefix + "s-" + m;
			});
			return join(list);
		};

		CSS.state = function state(stateModifiers) {
			var _this3 = this;

			return join(
				pushMap(null, this.resolve(stateModifiers), function(m) {
					return _this3.classPrefix + "s-" + m;
				})
			);
		};

		CSS.expand = function expand() {
			return join(this.resolve.apply(this, arguments));
		};

		CSS.parseStyle = function parseStyle$$1(str) {
			return parseStyle(str);
		};

		return CSS;
	})();
CSS.classPrefix = "cx";
CSSHelper.alias("cx", CSS);

function isObject(o) {
	return o !== null && typeof o === "object";
}

var bindingCache = {};
var Binding =
	/*#__PURE__*/
	(function() {
		function Binding(path) {
			this.path = path;
			this.parts = path.split(".");
			var fstr = "return (x";
			var cpath = "x";

			for (var i = 0; i < this.parts.length; i++) {
				if (this.parts[i][0] >= "0" && this.parts[i][0] <= "9") cpath += "[" + this.parts[i] + "]";
				else cpath += "." + this.parts[i];
				if (i + 1 < this.parts.length) fstr += " && " + cpath;
				else fstr += " ? " + cpath + " : undefined";
			}

			fstr += ")";
			this.value = new Function("x", fstr);
		}

		var _proto = Binding.prototype;

		_proto.set = function set(state, value) {
			var cv = this.value(state);
			if (cv === value) return state;
			var ns = Object.assign({}, state);
			var o = ns;

			for (var i = 0; i < this.parts.length; i++) {
				var part = this.parts[i];
				var no = i == this.parts.length - 1 ? value : Object.assign({}, o[part]);
				o[part] = no;
				o = no;
			}

			return ns;
		};

		_proto.delete = function _delete(state) {
			var ns = Object.assign({}, state);
			var o = ns;
			var part;

			for (var i = 0; i < this.parts.length - 1; i++) {
				part = this.parts[i];
				var no = Object.assign({}, o[part]);
				o[part] = no;
				o = no;
			}

			part = this.parts[this.parts.length - 1];
			if (!o.hasOwnProperty(part)) return state;
			delete o[part];
			return ns;
		};

		Binding.get = function get(path) {
			if (isString(path)) {
				var b = bindingCache[path];
				if (b) return b;
				b = new Binding(path);
				bindingCache[path] = b;
				return b;
			}

			if (isObject(path) && isString(path.bind)) return this.get(path.bind);
			if (path instanceof Binding) return path;
			throw new Error("Invalid binding definition provided.");
		};

		return Binding;
	})();

function computable() {
	var _ref;

	if (arguments.length == 0)
		throw new Error("computable requires at least a compute function to be passed in arguments.");
	var compute = ((_ref = arguments.length - 1), _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref]);
	if (typeof compute != "function") throw new Error("Last argument to the computable function should be a function.");
	var inputs = [],
		a;

	for (var i = 0; i + 1 < arguments.length; i++) {
		a = i < 0 || arguments.length <= i ? undefined : arguments[i];
		if (isString(a)) inputs.push(Binding.get(a).value);
		else if (a.memoize) inputs.push(a.memoize());
		else if (isFunction(a)) inputs.push(a);
		else throw new Error("Invalid selector type '" + typeof a + "' received.");
	}

	function memoize(amnesia, warmupData) {
		var lastValue,
			lastArgs =
				warmupData &&
				inputs.map(function(s, i) {
					return s(warmupData);
				});
		return function(data) {
			var dirty = amnesia;

			if (!lastArgs) {
				lastArgs = Array.from({
					length: inputs.length
				});
				dirty = true;
			}

			for (var _i = 0; _i < inputs.length; _i++) {
				var v = inputs[_i](data);

				if (v !== lastArgs[_i]) dirty = true;
				lastArgs[_i] = v;
			}

			if (dirty) lastValue = compute.apply(null, lastArgs);
			return lastValue;
		};
	}

	var selector = memoize(true);
	selector.memoize = memoize;
	return selector;
}

var Console = {
	log: function log() {
		var _console;

		if (typeof window != "undefined" && window.console) (_console = console).log.apply(_console, arguments);
	},
	warn: function warn() {
		var _console2;

		if (typeof window != "undefined" && window.console) (_console2 = console).warn.apply(_console2, arguments);
	}
};

var activeFlags = {
	deprecated: true
};
function debug(flag) {
	if (process.env.NODE_ENV !== "production") {
		if (!activeFlags[flag]) return;
		Console.log.apply(Console, arguments);
	}
}

var globalCacheIdentifier = 1;
var GlobalCacheIdentifier =
	/*#__PURE__*/
	(function() {
		function GlobalCacheIdentifier() {}

		GlobalCacheIdentifier.get = function get() {
			return globalCacheIdentifier;
		};

		GlobalCacheIdentifier.change = function change() {
			globalCacheIdentifier++;
		};

		return GlobalCacheIdentifier;
	})();

function isNumber(n) {
	return typeof n === "number";
}

function isUndefined(v) {
	return v === undefined;
}

var defaultFormatter = function defaultFormatter(v) {
	return v.toString();
};

var formatFactory = {
	string: function string() {
		return defaultFormatter;
	},
	wrap: function wrap(part0, prefix, suffix) {
		if (!prefix) prefix = "";
		if (!suffix) suffix = "";
		return function(value) {
			return prefix + value.toString() + suffix;
		};
	},
	fixed: function fixed(part0, digits) {
		return function(value) {
			return value.toFixed(digits);
		};
	},
	prefix: function prefix(part0, _prefix) {
		if (!_prefix) _prefix = "";
		return function(value) {
			return _prefix + value.toString();
		};
	},
	suffix: function suffix(part0, _suffix) {
		if (!_suffix) _suffix = "";
		return function(value) {
			return value.toString() + _suffix;
		};
	},
	uppercase: function uppercase() {
		return function(value) {
			return value.toString().toUpperCase();
		};
	},
	lowercase: function lowercase() {
		return function(value) {
			return value.toString().toLowerCase();
		};
	},
	urlencode: function urlencode() {
		return function(value) {
			return encodeURIComponent(value);
		};
	},
	number: function number(part0, minFractionDigits, maxFractionDigits) {
		var _resolveMinMaxFractio = resolveMinMaxFractionDigits(minFractionDigits, maxFractionDigits),
			minimumFractionDigits = _resolveMinMaxFractio.minimumFractionDigits,
			maximumFractionDigits = _resolveMinMaxFractio.maximumFractionDigits;

		var trimmable = maximumFractionDigits - minimumFractionDigits;

		if (trimmable > 0) {
			if (minimumFractionDigits == 0) ++trimmable;
			return function(value) {
				return trimFractionZeros(value.toFixed(maximumFractionDigits), trimmable);
			};
		}

		return function(value) {
			return value.toFixed(maximumFractionDigits);
		};
	},
	percentage: function percentage(part0, minFractionDigits, maxFractionDigits) {
		var numberFormatter = formatFactory.number(part0, minFractionDigits, maxFractionDigits);
		return function(value) {
			return numberFormatter(value * 100) + "%";
		};
	},
	percentageSign: function percentageSign(part0, minFractionDigits, maxFractionDigits) {
		var numberFormatter = formatFactory.number(part0, minFractionDigits, maxFractionDigits);
		return function(value) {
			return numberFormatter(value) + "%";
		};
	},
	date: function date() {
		return function(value) {
			var date = new Date(value);
			return date.getMonth() + 1 + "/" + date.getDate() + "/" + date.getFullYear();
		};
	},
	time: function time() {
		return function(value) {
			var date = new Date(value);
			var h = date.getHours() >= 10 ? date.getHours() : "0" + date.getHours();
			var m = date.getMinutes() >= 10 ? date.getMinutes() : "0" + date.getMinutes();
			return h + ":" + m;
		};
	},
	datetime: function datetime() {
		var date = formatFactory.date();
		var time = formatFactory.time();
		return function(value) {
			return date(value) + " " + time(value);
		};
	},
	ellipsis: function ellipsis(part0, length, where) {
		length = Number(length);
		if (!(length > 3)) length = 10;

		switch (where) {
			default:
			case "end":
				return function(value) {
					var s = String(value);
					if (s.length > length) return s.substring(0, length - 3) + "...";
					return s;
				};

			case "start":
				return function(value) {
					var s = String(value);
					if (s.length > length) return "..." + s.substring(s.length - length + 3);
					return s;
				};

			case "middle":
				return function(value) {
					var s = String(value);

					if (s.length > length) {
						var x = Math.floor(length - 2) / 2;
						return s.substring(0, x) + "..." + s.substring(s.length - (length - 3 - x));
					}

					return s;
				};
		}
	}
};
formatFactory.s = formatFactory.str = formatFactory.string;
formatFactory.f = formatFactory.fixed;
formatFactory.n = formatFactory.number;
formatFactory.p = formatFactory.percentage;
formatFactory.ps = formatFactory.percentageSign;
formatFactory.d = formatFactory.date;
formatFactory.t = formatFactory.time;
formatFactory.dt = formatFactory.datetime;

function buildFormatter(format) {
	var formatter = defaultFormatter,
		nullText = "";

	if (format) {
		var pipeParts = format.split("|");
		nullText = pipeParts[1] || "";
		var colonSepParts = pipeParts[0].split(":");

		for (var i = 0; i < colonSepParts.length; i++) {
			var parts = colonSepParts[i].split(";");
			var factory = formatFactory[parts[0]];
			if (!factory) debug("Unknown string format: " + format);
			else if (i == 0) formatter = factory.apply(void 0, parts);
			else {
				(function() {
					var outerFmt = factory.apply(void 0, parts);
					var innerFmt = formatter;

					formatter = function formatter(v) {
						return outerFmt(innerFmt(v));
					};
				})();
			}
		}
	}

	return function(v) {
		return v == null || v === "" ? nullText : formatter(v);
	};
}

var format = {
	cache: {}
};

function getFormatCache() {
	if (format.cacheIdentifier != GlobalCacheIdentifier.get()) {
		format = {
			cache: {},
			cacheIdentifier: GlobalCacheIdentifier.get()
		};
	}

	return format.cache;
}

function getFormatter(format) {
	if (!format) format = "";
	var formatCache = getFormatCache();
	var formatter = formatCache[format];
	if (!formatter) formatter = formatCache[format] = buildFormatter(format);
	return formatter;
}

var Format =
	/*#__PURE__*/
	(function() {
		function Format() {}

		Format.value = function value(v, format) {
			var formatter = getFormatter(format);
			return formatter(v);
		};

		Format.parse = function parse(format) {
			return getFormatter(format);
		};

		Format.register = function register(format, formatter) {
			this.registerFactory(format, function() {
				return formatter;
			});
		};

		Format.registerFactory = function registerFactory(format, factory) {
			var _this = this;

			if (isArray(format))
				format.forEach(function(f) {
					return _this.registerFactory(f, factory);
				});
			else formatFactory[format] = factory;
		};

		return Format;
	})();
function resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits) {
	minimumFractionDigits = minimumFractionDigits != null ? Number(minimumFractionDigits) : minimumFractionDigits;
	maximumFractionDigits = maximumFractionDigits != null ? Number(maximumFractionDigits) : maximumFractionDigits;

	if (isNumber(minimumFractionDigits)) {
		if (isUndefined(maximumFractionDigits)) maximumFractionDigits = minimumFractionDigits;
		else if (isNumber(maximumFractionDigits) && maximumFractionDigits < minimumFractionDigits)
			maximumFractionDigits = minimumFractionDigits;
	} else if (minimumFractionDigits == null && maximumFractionDigits == null) {
		minimumFractionDigits = 0;
		maximumFractionDigits = 18;
	}

	return {
		minimumFractionDigits: minimumFractionDigits,
		maximumFractionDigits: maximumFractionDigits
	};
}
function trimFractionZeros(str, max) {
	var cnt = 0,
		l = str.length;

	while (cnt < max && (str[l - 1 - cnt] === "0" || str[l - 1 - cnt] === ".")) {
		cnt++;
	}

	return cnt > 0 ? str.substring(0, l - cnt) : str;
}

function quoteStr(str) {
	if (str == null) return str;
	return "'" + str.replace(/'/g, "\\i") + "'";
}

function isDigit(x) {
	return x >= "0" && x <= "9";
}

/*
   Helper usage example

   Expression.registerHelper('_', _);
   let e = Expression.compile('_.min({data})');
 */

var expCache = {},
	helpers = {},
	helperNames = [],
	helperValues = [],
	expFatArrows = null;

function getExpr(expr) {
	if (expr.memoize) return expr;

	function memoize() {
		var lastValue,
			lastRunBindings = {},
			lastRunResults = {},
			getters = {},
			currentData,
			len = -1;

		var get = function get(bindingWithFormat) {
			var getter = getters[bindingWithFormat];

			if (!getter) {
				var binding = bindingWithFormat,
					format;
				var colonIndex = bindingWithFormat.indexOf(":");

				if (colonIndex != -1) {
					format = Format.parse(bindingWithFormat.substring(colonIndex + 1));
					binding = bindingWithFormat.substring(0, colonIndex);
				} else {
					var nullSeparatorIndex = bindingWithFormat.indexOf(":");

					if (nullSeparatorIndex != -1) {
						format = Format.parse(bindingWithFormat.substring(nullSeparatorIndex));
						binding = bindingWithFormat.substring(0, nullSeparatorIndex - 1);
					}
				}

				var b = Binding.get(binding);

				getter = function getter(data) {
					var value = b.value(data);
					lastRunBindings[len] = b.value;
					lastRunResults[len] = value;
					len++;
					return value;
				};

				if (format) {
					var valueGetter = getter;

					getter = function getter(data) {
						return format(valueGetter(data));
					};
				}

				getters[bindingWithFormat] = getter;
			}

			return getter(currentData);
		};

		return function(data) {
			var i = 0;

			for (; i < len; i++) {
				if (lastRunBindings[i](data) !== lastRunResults[i]) break;
			}

			if (i !== len) {
				len = 0;
				currentData = data;
				lastValue = expr(get);
			}

			return lastValue;
		};
	}

	var result = memoize();
	result.memoize = memoize;
	return result;
}

function expression(str) {
	var _ref;

	if (isFunction(str)) return getExpr(str);
	var r = expCache[str];
	if (r) return r;
	var quote = false;
	var termStart = -1,
		curlyBrackets = 0,
		percentExpression;
	var fb = ["return ("];
	var args = {};
	var formats = [];
	var subExpr = 0;

	for (var i = 0; i < str.length; i++) {
		var c = str[i];

		switch (c) {
			case "{":
				if (curlyBrackets > 0) curlyBrackets++;
				else {
					if (!quote && termStart < 0 && (str[i + 1] != "{" || str[i - 1] == "%")) {
						termStart = i + 1;
						curlyBrackets = 1;
						percentExpression = str[i - 1] == "%";
						if (percentExpression) fb.pop(); //%
					} else if (str[i - 1] != "{") fb.push(c);
				}
				break;

			case "}":
				if (termStart >= 0) {
					if (--curlyBrackets == 0) {
						var term = str.substring(termStart, i);
						var formatStart = 0;
						if (term[0] == "[") formatStart = term.indexOf("]");
						var colon = term.indexOf(":", formatStart > 0 ? formatStart : 0);
						var binding = colon == -1 ? term : term.substring(0, colon);
						var format = colon == -1 ? null : term.substring(colon + 1);

						if (colon == -1) {
							var nullSepIndex = binding.indexOf("|");

							if (nullSepIndex != -1) {
								format = binding.substring(nullSepIndex);
								binding = binding.substring(0, nullSepIndex);
							}
						}

						var argName = binding.replace(/\./g, "_");
						if (isDigit(argName[0])) argName = "$" + argName;

						if (percentExpression || (binding[0] == "[" && binding[binding.length - 1] == "]")) {
							argName = "expr" + ++subExpr;
							args[argName] = expression(percentExpression ? binding : binding.substring(1, binding.length - 1));
						} else args[argName] = binding;

						if (format) {
							var formatter = "fmt" + formats.length;
							fb.push(formatter, "(", argName, ", ", quoteStr(format), ")");
							formats.push(Format.parse(format));
						} else fb.push(argName);

						termStart = -1;
					}
				} else fb.push(c);

				break;

			case '"':
			case "'":
				if (curlyBrackets == 0) {
					if (!quote) quote = c;
					else if (str[i - 1] != "\\" && quote == c) quote = false;
					fb.push(c);
				}

				break;

			default:
				if (termStart < 0) fb.push(c);
				break;
		}
	}

	fb.push(")");
	var body = fb.join("");
	if (expFatArrows) body = expFatArrows(body); //console.log(body);

	var keys = Object.keys(args);

	var compute = (_ref = _construct(
		Function,
		formats
			.map(function(f, i) {
				return "fmt" + i;
			})
			.concat(keys, helperNames, [body])
	)).bind.apply(_ref, [Format].concat(formats, helperValues));

	var selector = computable.apply(
		void 0,
		keys
			.map(function(k) {
				return args[k];
			})
			.concat([compute])
	);
	expCache[str] = selector;
	return selector;
}
var Expression = {
	get: function get(str) {
		return expression(str);
	},
	compile: function compile(str) {
		return this.get(str).memoize();
	},
	registerHelper: function registerHelper(name, helper) {
		helpers[name] = helper;
		helperNames = Object.keys(helpers);
		helperValues = helperNames.map(function(n) {
			return helpers[n];
		});
	}
};
function invalidateExpressionCache() {
	expCache = {};
}

function plus(str) {
	return str.length ? str + " + " : str;
}

var tplCache = {};
function stringTemplate(str) {
	var expr = tplCache[str];
	if (expr) return expr;
	expr = "";
	var termStart = -1,
		quoteStart = 0,
		term,
		bracketsOpen = 0,
		percentSign;

	for (var i = 0; i < str.length; i++) {
		var c = str[i];

		switch (c) {
			case "{":
				if (termStart < 0) {
					if (str[i + 1] == "{" && str[i - 1] != "%") {
						expr = plus(expr) + quoteStr(str.substring(quoteStart, i) + "{");
						i++;
						quoteStart = i + 1;
					} else {
						termStart = i + 1;
						percentSign = str[i - 1] == "%";
						if (i > quoteStart) expr = plus(expr) + quoteStr(str.substring(quoteStart, percentSign ? i - 1 : i));
						bracketsOpen = 1;
					}
				} else bracketsOpen++;

				break;

			case "}":
				if (termStart >= 0) {
					if (--bracketsOpen == 0) {
						term = str.substring(termStart, i);

						if (term.indexOf(":") == -1) {
							var nullSepIndex = term.indexOf("|");
							if (nullSepIndex == -1) term += ":s";
							else term = term.substring(0, nullSepIndex) + ":s" + term.substring(nullSepIndex);
						}

						expr = plus(expr) + (percentSign ? "%{" : "{") + term + "}";
						termStart = -1;
						quoteStart = i + 1;
						bracketsOpen = 0;
					}
				} else if (str[i + 1] == "}") {
					expr = plus(expr) + quoteStr(str.substring(quoteStart, i) + "}");
					i++;
					quoteStart = i + 1;
				}

				break;
		}
	}

	if (quoteStart < str.length) expr = plus(expr) + quoteStr(str.substring(quoteStart)); //console.log(expr);

	return (tplCache[str] = expression(expr));
}
var StringTemplate = {
	get: function get(str) {
		return stringTemplate(str);
	},
	compile: function compile(str) {
		return stringTemplate(str).memoize();
	},
	format: function format(_format) {
		for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		return stringTemplate(_format)(args);
	}
};
function invalidateStringTemplateCache() {
	tplCache = {};
}

function createStructuredSelector(selector, constants) {
	var keys = Object.keys(selector);
	if (keys.length == 0)
		return function() {
			return constants;
		};

	function memoize() {
		var lastResult = Object.assign({}, constants);
		var memoizedSelectors = {};
		keys.forEach(function(key) {
			memoizedSelectors[key] = selector[key].memoize ? selector[key].memoize() : selector[key];
		});
		return function(data) {
			var result = lastResult,
				k,
				v,
				i;

			for (i = 0; i < keys.length; i++) {
				k = keys[i];
				v = memoizedSelectors[k](data);

				if (result === lastResult) {
					if (v === lastResult[k]) continue;
					result = Object.assign({}, lastResult);
				}

				result[k] = v;
			}

			return (lastResult = result);
		};
	}

	function evaluate(data) {
		var result = Object.assign({}, constants);

		for (var i = 0; i < keys.length; i++) {
			result[keys[i]] = selector[keys[i]](data);
		}

		return result;
	}

	evaluate.memoize = memoize;
	return evaluate;
}

function isSelector(config) {
	if (config == null) return true;

	switch (typeof config) {
		case "object":
			if (config.type || config.$type) return false;
			return !!(config.bind || config.tpl || config.expr || config.get);

		case "function":
			return true;

		case "string":
			return true;

		case "number":
			return true;

		case "boolean":
			return true;
	}

	return false;
}

var nullF = function nullF() {
	return null;
};

function getSelector(config) {
	if (config == null) return nullF;

	switch (typeof config) {
		case "object":
			if (isArray(config)) {
				var _selectors = config.map(function(x) {
					return getSelector(x);
				});

				return function(data) {
					return _selectors.map(function(elementSelector) {
						return elementSelector(data);
					});
				};
			}

			if (config.bind) return Binding.get(config.bind).value;
			if (config.tpl) return StringTemplate.get(config.tpl);
			if (config.expr) return Expression.get(config.expr);
			if (config.get) return config.get;
			var selectors = {};
			var constants = {};

			for (var key in config) {
				if (isSelector(config[key])) selectors[key] = getSelector(config[key]);
				else constants[key] = config[key];
			}

			return createStructuredSelector(selectors, constants);

		case "function":
			return config;

		default:
			return function() {
				return config;
			};
	}
}

function isDefined(v) {
	return v !== undefined;
}

function defaultValue(pv) {
	if (typeof pv == "object" && pv && pv.structured) return pv.defaultValue;
	return pv;
}

function getSelectorConfig(props, values, nameMap) {
	var functions = {},
		structures = {},
		defaultValues = {},
		constants,
		p,
		v,
		pv,
		constant = true;

	for (p in props) {
		v = values[p];
		pv = props[p];
		if (isUndefined(v) && pv && (pv.bind || pv.tpl || pv.expr)) v = pv;

		if (v === null) {
			if (!constants) constants = {};
			constants[p] = null;
		} else if (typeof v == "object") {
			if (v.bind) {
				if (isUndefined(v.defaultValue) && v != pv) v.defaultValue = defaultValue(pv);
				if (isDefined(v.defaultValue)) defaultValues[v.bind] = v.defaultValue;
				nameMap[p] = v.bind;
				functions[p] = Binding.get(v.bind).value;
				constant = false;
			} else if (v.expr) {
				functions[p] = Expression.get(v.expr);
				constant = false;
			} else if (v.get) {
				functions[p] = v.get;
				constant = false;
			} else if (v.tpl) {
				functions[p] = StringTemplate.get(v.tpl);
				constant = false;
			} else if (pv && typeof pv == "object" && pv.structured) {
				if (isArray(v)) functions[p] = getSelector(v);
				else {
					var s = getSelectorConfig(v, v, {});
					structures[p] = s;
					Object.assign(defaultValues, s.defaultValues);
				}
				constant = false;
			} else {
				if (!constants) constants = {};
				constants[p] = v;
			}
		} else if (isFunction(v)) {
			functions[p] = v;
			constant = false;
		} else {
			if (isUndefined(v)) {
				if (isUndefined(pv)) continue;
				v = defaultValue(pv);
			}

			if (isUndefined(v)) continue;
			if (!constants) constants = {};
			constants[p] = v;
		}
	}

	return {
		functions: functions,
		structures: structures,
		defaultValues: defaultValues,
		constants: constants,
		constant: constant
	};
}

function createSelector(_ref) {
	var functions = _ref.functions,
		structures = _ref.structures,
		constants = _ref.constants,
		defaultValues = _ref.defaultValues;
	var selector = {};

	for (var n in functions) {
		selector[n] = functions[n];
	}

	for (var _n in structures) {
		selector[_n] = createSelector(structures[_n]);
	}

	return createStructuredSelector(selector, constants);
}

var StructuredSelector =
	/*#__PURE__*/
	(function() {
		function StructuredSelector(_ref2) {
			var props = _ref2.props,
				values = _ref2.values;
			this.nameMap = {};
			this.config = getSelectorConfig(props, values, this.nameMap);
		}

		var _proto = StructuredSelector.prototype;

		_proto.init = function init(store) {
			store.init(this.config.defaultValues);
		};

		_proto.create = function create() {
			var selector = createSelector(this.config);
			if (selector.memoize) return selector.memoize();
			return selector;
		};

		_proto.createStoreSelector = function createStoreSelector() {
			if (this.config.constant) {
				var result = _objectSpread({}, this.config.constants);

				return function() {
					return result;
				};
			}

			var selector = this.create();
			return function(store) {
				return selector(store.getData());
			};
		};

		return StructuredSelector;
	})();

var VDOM$1 = VDOM;

var VDOM$2 = VDOM$1;
var widgetId = 100;
var Widget =
	/*#__PURE__*/
	(function(_Component) {
		_inheritsLoose(Widget, _Component);

		function Widget(config) {
			var _this;

			_this = _Component.call(this, config) || this;
			_this.widgetId = widgetId++;

			if (isArray(_this.jsxSpread)) {
				if (!_this.jsxAttributes) _this.jsxAttributes = [];

				_this.jsxSpread.forEach(function(spread) {
					for (var key in spread) {
						_this[key] = spread[key];

						_this.jsxAttributes.push(key);
					}
				});
			}

			return _this;
		}

		var _proto = Widget.prototype;

		_proto.init = function init() {
			if (this.styles) this.style = this.styles;
			if (this.styled) this.style = parseStyle(this.style);
			else if (this.style) {
				Console.warn(
					"Components that allow use of the style attribute should set styled = true on their prototype. This will be an error in future versions."
				);
				this.style = parseStyle(this.style);
				this.styled = true;
			}
			if (typeof this.if !== "undefined") this.visible = this.if;
			this.declareData();

			if (this.outerLayout) {
				if (isArray(this.outerLayout)) throw new Error("Only single element outer layout is supported."); //TODO: better handle the case when outer layout is an array. How to get around circular dependency to PureContainer

				this.outerLayout = Widget.create(this.outerLayout);
			}

			if (this.contentFor) this.putInto = this.contentFor;
			if (this.putInto) this.isContent = true;
			if (isString(this.CSS)) this.CSS = CSSHelper.get(this.CSS);
			this.initHelpers();
			this.initComponents();
			this.initialized = true;
		};

		_proto.initComponents = function initComponents() {
			if (arguments.length > 0) {
				this.components = Object.assign.apply(Object, arguments);

				for (var k in this.components) {
					if (!this.components[k]) delete this.components[k];
				}
			}
		};

		_proto.initHelpers = function initHelpers() {
			if (arguments.length > 0) {
				this.helpers = Object.assign.apply(Object, arguments);
			}
		};

		_proto.declareData = function declareData() {
			var options = {};
			if (this.styled)
				options.class = options.className = options.style = {
					structured: true
				};

			var props = _objectSpread(
				{
					visible: undefined,
					mod: {
						structured: true
					}
				},
				options
			);

			Object.assign.apply(Object, [props].concat(Array.prototype.slice.call(arguments)));
			this.selector = new StructuredSelector({
				props: props,
				values: this
			});
			this.nameMap = this.selector.nameMap;
		};

		_proto.prepareCSS = function prepareCSS(context, _ref) {
			var data = _ref.data;
			data.classNames = this.CSS.expand(
				this.CSS.block(this.baseClass, data.mod, data.stateMods),
				data.class,
				data.className
			);
			data.style = parseStyle(data.style);
		};

		_proto.prepareData = function prepareData(context, instance) {
			if (this.styled) this.prepareCSS(context, instance);
		};

		_proto.initInstance = function initInstance(context, instance) {
			if (this.onInit) this.onInit(context, instance);
		};

		_proto.initState = function initState(context, instance) {};

		_proto.checkVisible = function checkVisible(context, instance, data) {
			return data.visible;
		};

		_proto.explore = function explore(context, instance) {
			if (this.components) instance.components = {};

			for (var cmp in this.components) {
				var ins = instance.getChild(context, this.components[cmp], "cmp-" + cmp, instance.store);
				if (ins.scheduleExploreIfVisible(context)) instance.components[cmp] = ins;
			}
		};

		_proto.render = function render(context, instance, key) {
			throw new Error(
				"Widget's render method should be overridden. This error can happen if you forgot to import the component before using it."
			);
		};

		_proto.update = function update() {
			this.version = (this.version || 0) + 1;
		};

		Widget.resetCounter = function resetCounter() {
			widgetId = 100;
		};

		return Widget;
	})(Component);
Widget.prototype.visible = true;
Widget.prototype.memoize = true; //cache rendered content and use it if possible

Widget.prototype.CSS = "cx";
Widget.prototype.styled = false;
Widget.namespace = "ui.";
Widget.optimizePrepare = true;

Widget.factory = function(type, config, more) {
	throw new Error("Invalid widget type: " + type + ".");
};

function contentAppend(result, w, prependSpace) {
	if (w == null || w === false) return false;
	if (isArray(w))
		w.forEach(function(c) {
			return contentAppend(result, c);
		});
	else if (isDefined(w.content) && !w.atomic) return contentAppend(result, w.content);
	else {
		if (prependSpace) result.push(" ");
		result.push(w);
	}
	return true;
}
function getContentArray(x) {
	var result = [];
	contentAppend(result, x);
	return result;
}
function getContent(x) {
	var result = getContentArray(x);
	if (result.length == 0) return null;
	if (result.length == 1) return result[0];
	return result;
}

var StaticText =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(StaticText, _Widget);

		function StaticText() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = StaticText.prototype;

		_proto.render = function render() {
			return this.text;
		};

		return StaticText;
	})(Widget);
Widget.alias("static-text", StaticText);

var Text =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(Text, _Widget);

		function Text() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = Text.prototype;

		_proto.init = function init() {
			if (!this.value && (this.tpl || this.expr || this.bind))
				this.value = {
					tpl: this.tpl,
					expr: this.expr,
					bind: this.bind
				};

			_Widget.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[
					this,
					{
						value: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.render = function render(context, _ref, key) {
			var data = _ref.data;
			return data.value != null ? data.value : "";
		};

		return Text;
	})(Widget);
Widget.alias("text", Text);

function innerTextTrim(str) {
	str = str.replace(/\t/g, "");
	str = str.replace(/(\s*[\r\n]\s*)/g, "");
	return str;
}

function exploreChildren(context, instance, children, previousResult, key, store, beforeCallback, afterCallback) {
	var newChildren = previousResult || [];
	var oldChildren = previousResult || newChildren;
	var identical = previousResult ? 0 : -1; // if (children.length)
	//    context.exploreStack.hop();

	for (var c = 0; c < children.length; c++) {
		var cell = instance.getChild(context, children[c], key, store); // if (beforeCallback)
		//    beforeCallback(cell);

		if (cell.checkVisible(context)) {
			if (identical >= 0) {
				if (cell == oldChildren[identical]) identical++;
				else {
					newChildren = newChildren.slice(0, identical);
					identical = -1;
					newChildren.push(cell);
				}
			} else newChildren.push(cell);

			context.exploreStack.push(cell);
			if (cell.needsExploreCleanup) context.exploreStack.push(cell);
		}
	}

	if (identical >= 0 && identical != newChildren.length) newChildren = newChildren.slice(0, identical);
	return newChildren;
}

var Container =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(Container, _Widget);

		function Container() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = Container.prototype;

		_proto.init = function init(context) {
			if (typeof this.ws !== "undefined") this.preserveWhitespace = this.ws;
			if (this.preserveWhitespace) this.trimWhitespace = false;
			var items = this.items || this.children || [];
			delete this.children;
			this.items = [];

			if (this.layout) {
				var layout = Widget.create({
					type: this.layout,
					items: items
				});
				layout.init(context);
				this.layout = null;

				if (layout.noLayout) {
					this.useParentLayout = true;
					this.add(items);
				} else {
					this.add(layout);
					this.layout = layout;
				}
			} else {
				this.add(items);
			}

			_Widget.prototype.init.call(this, context);
		};

		_proto.exploreItems = function exploreItems(context, instance, items) {
			instance.children = exploreChildren(context, instance, items, instance.cached.children);
			if (instance.cache("children", instance.children)) instance.markShouldUpdate(context);
		};

		_proto.explore = function explore(context, instance) {
			_Widget.prototype.explore.call(this, context, instance);

			this.exploreItems(context, instance, this.items);
		};

		_proto.render = function render(context, instance) {
			return this.renderChildren(context, instance);
		};

		_proto.renderChildren = function renderChildren(context, instance) {
			var preserveComplexContent = this.useParentLayout;

			function append(result, r) {
				if (r == null) return; //react element

				if (!r.hasOwnProperty("content")) {
					contentAppend(result, r);
					return;
				}

				if (r.useParentLayout)
					return r.content.forEach(function(x) {
						return append(result, x);
					});

				if (r.atomic || preserveComplexContent) {
					result.push(r);
				} else {
					var first = true;

					for (var k in r) {
						if (contentAppend(result, r[k], !first)) first = false;
					}
				}
			}

			var result = [];

			for (var i = 0; i < instance.children.length; i++) {
				append(result, instance.children[i].vdom);
			}

			if (this.useParentLayout)
				return {
					useParentLayout: true,
					content: result
				};
			return result;
		};

		_proto.clear = function clear() {
			if (this.layout) this.layout.clear();
			else this.items = [];
		};

		_proto.add = function add() {
			var _this$layout,
				_this = this;

			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			if (this.layout) return (_this$layout = this.layout).add.apply(_this$layout, args);
			args.forEach(function(a) {
				if (!a) return;
				if (isArray(a))
					a.forEach(function(c) {
						return _this.add(c);
					});
				else if (isString(a)) {
					if (_this.trimWhitespace) a = innerTextTrim(a);
					if (a) _this.addText(a);
				} else if (a.isComponent) _this.items.push(_this.wrapItem(a));
				else {
					_this.add(Widget.create(a, _this.itemDefaults));
				}
			});
		};

		_proto.wrapItem = function wrapItem(item) {
			return item;
		};

		_proto.addText = function addText(text) {
			if (this.plainText || text.indexOf("{") == -1 || text.indexOf("}") == -1)
				this.add(
					Widget.create(StaticText, {
						text: text
					})
				);
			else
				this.add(
					Widget.create(Text, {
						text: {
							tpl: text
						}
					})
				);
		};

		_proto.find = function find(filter, options) {
			if (!options) options = {};
			if (!filter || !this.items) return [];
			var alias = filter;
			if (isString(filter))
				filter = function filter(w) {
					return w.componentAlias == alias;
				};
			if (filter.isComponentType)
				filter = function filter(w) {
					return w instanceof alias;
				};
			var results = [];

			for (var i = 0; i < this.items.length; i++) {
				var w = this.items[i];
				if (!w.initialized) w.init();

				if (filter(w)) {
					results.push(w);
					if (options.first) break;
				}

				if (w.find) results.push.apply(results, w.find(filter, options));
			}

			return results;
		};

		_proto.findFirst = function findFirst(filter, options) {
			return this.find(
				filter,
				_objectSpread({}, options, {
					first: true
				})
			)[0];
		};

		return Container;
	})(Widget);
Container.prototype.trimWhitespace = true;
Container.prototype.plainText = true;
Container.prototype.styled = false;

var PureContainer =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(PureContainer, _Container);

		function PureContainer() {
			return _Container.apply(this, arguments) || this;
		}

		return PureContainer;
	})(Container);
PureContainer.prototype.isPureContainer = true;
PureContainer.alias("pure-container", PureContainer);

var Rect =
	/*#__PURE__*/
	(function() {
		function Rect(config) {
			Object.assign(this, config);
		}

		var _proto = Rect.prototype;

		_proto.width = function width() {
			return this.r - this.l;
		};

		_proto.height = function height() {
			return this.b - this.t;
		};

		_proto.valid = function valid() {
			return this.r > this.l && this.b > this.t;
		};

		_proto.makeValid = function makeValid() {
			return new Rect({
				l: Math.min(this.l, this.r),
				r: Math.max(this.l, this.r),
				t: Math.min(this.t, this.b),
				b: Math.max(this.t, this.b)
			});
		};

		_proto.isEqual = function isEqual(r) {
			if (!r || !r.isRect) return false;
			return r.l == this.l && r.r == this.r && r.t == this.t && r.b == this.b;
		};

		Rect.add = function add(a, b) {
			return new Rect({
				l: a.l + b.l,
				t: a.t + b.t,
				r: a.r + b.r,
				b: a.b + b.b
			});
		};

		Rect.multiply = function multiply(a, b) {
			return new Rect({
				l: a.l + (a.r - a.l) * b.l,
				r: a.l + (a.r - a.l) * b.r,
				t: a.t + (a.b - a.t) * b.t,
				b: a.t + (a.b - a.t) * b.b
			});
		};

		Rect.margin = function margin(r, m) {
			var mr = Rect.convertMargin(m);
			return Rect.add(r, mr);
		};

		Rect.convertMargin = function convertMargin(m) {
			if (!m) return new Rect();
			if (m.isRect) return m;
			if (isNumber(m))
				return new Rect({
					l: m,
					t: m,
					r: -m,
					b: -m
				});
			var m = Rect.convert(m);
			m.b = -m.b;
			m.r = -m.r;
			return m;
		};

		Rect.convert = function convert(r) {
			if (!r)
				return new Rect({
					l: 0,
					r: 0,
					t: 0,
					b: 0
				});
			if (r.isRect) return r;
			if (typeof r === "string") r = r.split(" ");

			if (isArray(r)) {
				return new Rect({
					t: parseFloat(r[0]),
					r: parseFloat(r[1]),
					b: parseFloat(r[2]),
					l: parseFloat(r[3])
				});
			}

			return new Rect(r);
		};

		return Rect;
	})();
Rect.prototype.isRect = true;
Rect.prototype.l = 0; //left;

Rect.prototype.r = 0; //right

Rect.prototype.t = 0; //top

Rect.prototype.b = 0; //bottom

var BoundedObject =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(BoundedObject, _PureContainer);

		function BoundedObject() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = BoundedObject.prototype;

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[
					this,
					{
						anchors: undefined,
						offset: undefined,
						margin: undefined,
						padding: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			_PureContainer.prototype.prepareData.call(this, context, instance);

			var data = instance.data;
			data.anchors = Rect.convert(data.anchors);
			data.offset = Rect.convert(data.offset);
			data.margin = Rect.convertMargin(data.margin);
			data.padding = Rect.convertMargin(data.padding);
		};

		_proto.calculateBounds = function calculateBounds(context, instance) {
			var data = instance.data;
			return Rect.add(Rect.add(Rect.multiply(instance.parentRect, data.anchors), data.offset), data.margin);
		};

		_proto.prepareBounds = function prepareBounds(context, instance) {
			var data = instance.data;

			if (
				instance.shouldUpdate ||
				!instance.cached.parentRect ||
				!instance.cached.parentRect.isEqual(context.parentRect) ||
				!data.bounds
			) {
				if (!context.parentRect) throw new Error("Parent bounds were not provided through the context.");
				instance.parentRect = context.parentRect;
				instance.cache("parentRect", context.parentRect);
				instance.markShouldUpdate(context);
				data.bounds = this.calculateBounds(context, instance);
				data.childrenBounds = Rect.add(data.bounds, data.padding);
			}
		};

		_proto.prepare = function prepare(context, instance) {
			this.prepareBounds(context, instance);
			context.push("parentRect", instance.data.childrenBounds);
		};

		_proto.prepareCleanup = function prepareCleanup(context, instance) {
			context.pop("parentRect");
		};

		return BoundedObject;
	})(PureContainer);
BoundedObject.prototype.anchors = 0;
BoundedObject.prototype.margin = 0;
BoundedObject.prototype.offset = 0;
BoundedObject.prototype.padding = 0;
BoundedObject.prototype.isPureContainer = false;
BoundedObject.prototype.styled = true;

var Axis =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(Axis, _BoundedObject);

		function Axis() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = Axis.prototype;

		_proto.init = function init() {
			if (this.labelAnchor == "auto") this.labelAnchor = this.vertical ? (this.secondary ? "start" : "end") : "middle";
			if (this.labelDx == "auto") this.labelDx = 0;
			if (this.labelDy == "auto") this.labelDy = this.vertical ? "0.4em" : this.secondary ? 0 : "0.8em";
			if (isUndefined(this.minLabelDistance))
				this.minLabelDistance = this.vertical ? this.minLabelDistanceVertical : this.minLabelDistanceHorizontal;
			if (this.labelLineCountDyFactor == "auto")
				this.labelLineCountDyFactor = this.vertical ? -0.5 : this.secondary ? -1 : 0;

			_BoundedObject.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _BoundedObject$protot;

			(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
				_BoundedObject$protot,
				[
					this,
					{
						anchors: undefined,
						hideLabels: undefined,
						labelRotation: undefined,
						labelAnchor: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.report = function report(context, instance) {
			return instance.calculator;
		};

		_proto.renderTicksAndLabels = function renderTicksAndLabels(context, instance, valueFormatter) {
			var _this = this;

			if (this.hidden) return false;
			var data = instance.data,
				calculator = instance.calculator;
			var bounds = data.bounds;
			var size = calculator.findTickSize(this.minLabelDistance);
			var labelClass = this.CSS.element(this.baseClass, "label");
			var offsetClass = this.CSS.element(this.baseClass, "label-offset");
			var x1,
				y1,
				x2,
				y2,
				tickSize = this.tickSize;

			if (this.vertical) {
				x1 = x2 = this.secondary ? bounds.r : bounds.l;
				y1 = bounds.b;
				y2 = bounds.t;
			} else {
				x1 = bounds.l;
				x2 = bounds.r;
				y1 = y2 = this.secondary ? bounds.t : bounds.b;
			}

			var res = [
				VDOM$2.createElement("line", {
					key: "line",
					className: this.CSS.element(this.baseClass, "line"),
					x1: x1,
					y1: y1,
					x2: x2,
					y2: y2
				}),
				null
			];
			var t = [];

			if (size > 0 && !data.hideLabels) {
				var ticks = calculator.getTicks([size]);
				ticks.forEach(function(serie, si) {
					serie.forEach(function(v, i) {
						var s = calculator.map(v);

						if (_this.secondary) {
							x1 = _this.vertical ? bounds.r : s;
							y1 = _this.vertical ? s : bounds.t;
							x2 = _this.vertical ? bounds.r + tickSize : s;
							y2 = _this.vertical ? s : bounds.t - tickSize;
						} else {
							x1 = _this.vertical ? bounds.l : s;
							y1 = _this.vertical ? s : bounds.b;
							x2 = _this.vertical ? bounds.l - tickSize : s;
							y2 = _this.vertical ? s : bounds.b + tickSize;
						}

						t.push("M " + x1 + " " + y1 + " L " + x2 + " " + y2);
						var x, y;

						if (_this.secondary) {
							x = _this.vertical ? bounds.r + _this.labelOffset : s;
							y = _this.vertical ? s : bounds.t - _this.labelOffset;
						} else {
							x = _this.vertical ? bounds.l - _this.labelOffset : s;
							y = _this.vertical ? s : bounds.b + _this.labelOffset;
						}

						var transform = data.labelRotation ? "rotate(" + data.labelRotation + " " + x + " " + y + ")" : null;
						res.push(
							VDOM$2.createElement(
								"text",
								{
									key: "label-" + si + "-" + i,
									className: labelClass,
									x: x,
									y: y,
									dx: _this.labelDx,
									textAnchor: data.labelAnchor,
									transform: transform
								},
								_this.wrapLines(valueFormatter(v), x, _this.labelDy, offsetClass)
							)
						);
					});
				});
			}

			res[1] = VDOM$2.createElement("path", {
				key: "ticks",
				className: this.CSS.element(this.baseClass, "ticks"),
				d: t.join(" ")
			});
			return res;
		};

		_proto.wrapLines = function wrapLines(str, x, dy, offsetClass) {
			if (!this.labelWrap || typeof str != "string")
				return VDOM$2.createElement(
					"tspan",
					{
						x: x,
						dy: dy
					},
					str
				);
			var parts = str.split(" ");
			if (parts.length == 0) return null;
			var lines = [];
			var line = null;

			for (var i = 0; i < parts.length; i++) {
				if (!line) line = parts[i];
				else if (parts[i].length + line.length < this.labelMaxLineLength) line += " " + parts[i];
				else {
					lines.push(line);
					line = parts[i];
				}
			}

			lines.push(line);
			if (lines.length == 1)
				return VDOM$2.createElement(
					"tspan",
					{
						x: x,
						dy: dy
					},
					str
				);
			var offset = this.labelLineCountDyFactor * (lines.length - 1);
			var result = [
				dy != null &&
					VDOM$2.createElement(
						"tspan",
						{
							key: -2,
							className: offsetClass,
							dy: dy
						},
						"_"
					)
			];
			lines.forEach(function(p, i) {
				result.push(
					VDOM$2.createElement(
						"tspan",
						{
							key: i,
							dy: (i == 0 ? offset : 1) + "em",
							x: x
						},
						p
					)
				);
			});
			return result;
		};

		_proto.prepare = function prepare(context, instance) {
			_BoundedObject.prototype.prepare.call(this, context, instance);

			var bounds = instance.data.bounds;

			var _ref = !this.vertical ? [bounds.l, bounds.r] : [bounds.b, bounds.t],
				a = _ref[0],
				b = _ref[1];

			instance.calculator.measure(a, b);
			if (!instance.calculator.isSame(instance.cached.axis)) instance.markShouldUpdate(context);
		};

		_proto.cleanup = function cleanup(context, instance) {
			var cached = instance.cached,
				calculator = instance.calculator;
			cached.axis = calculator.hash();
		};

		return Axis;
	})(BoundedObject);
Axis.prototype.anchors = "0 1 1 0";
Axis.prototype.vertical = false;
Axis.prototype.secondary = false;
Axis.prototype.inverted = false;
Axis.prototype.hidden = false;
Axis.prototype.hideLabels = false;
Axis.prototype.tickSize = 3;
Axis.prototype.minTickDistance = 25;
Axis.prototype.minLabelDistanceVertical = 40;
Axis.prototype.minLabelDistanceHorizontal = 50;
Axis.prototype.labelOffset = 10;
Axis.prototype.labelRotation = 0;
Axis.prototype.labelAnchor = "auto";
Axis.prototype.labelDx = "auto";
Axis.prototype.labelDy = "auto";
Axis.prototype.labelWrap = false;
Axis.prototype.labelLineCountDyFactor = "auto";
Axis.prototype.labelMaxLineLength = 10;
Axis.namespace = "ui.svg.chart.axis";

var Chart =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(Chart, _BoundedObject);

		function Chart() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = Chart.prototype;

		_proto.init = function init() {
			_BoundedObject.prototype.init.call(this);

			if (!this.axes) this.axes = {};

			for (var axis in this.axes) {
				this.axes[axis] = Axis.create(this.axes[axis]);
			}
		};

		_proto.explore = function explore(context, instance) {
			instance.calculators = _objectSpread({}, context.axes);
			context.push("axes", instance.calculators);
			instance.axes = {}; //axes need to be registered before children to be processed first

			for (var axis in this.axes) {
				var axisInstance = instance.getChild(context, this.axes[axis]);

				if (axisInstance.scheduleExploreIfVisible(context)) {
					instance.axes[axis] = axisInstance;
					instance.calculators[axis] = this.axes[axis].report(context, axisInstance);
				}
			}

			_BoundedObject.prototype.explore.call(this, context, instance);
		};

		_proto.exploreCleanup = function exploreCleanup(context, instance) {
			context.pop("axes");
		};

		_proto.prepare = function prepare(context, instance) {
			context.push("axes", instance.calculators);

			_BoundedObject.prototype.prepare.call(this, context, instance);
		};

		_proto.prepareCleanup = function prepareCleanup(context, instance) {
			context.pop("axes");

			_BoundedObject.prototype.prepareCleanup.call(this, context, instance);
		};

		_proto.render = function render(context, instance, key) {
			var axes = [];

			for (var k in instance.axes) {
				axes.push(getContent(instance.axes[k].render(context, key + "-axis-" + k)));
			}

			return [axes, this.renderChildren(context, instance)];
		};

		return Chart;
	})(BoundedObject);
Chart.prototype.anchors = "0 1 1 0";
Chart.prototype.styled = true;
Chart.prototype.isPureContainer = true;
Widget.alias("chart", Chart);

var Selection =
	/*#__PURE__*/
	(function(_Component) {
		_inheritsLoose(Selection, _Component);

		function Selection() {
			return _Component.apply(this, arguments) || this;
		}

		var _proto = Selection.prototype;

		_proto.isSelected = function isSelected(store, record, index) {
			return this.bind && store.get(this.bind) === record;
		};

		_proto.getIsSelectedDelegate = function getIsSelectedDelegate(store) {
			var _this = this;

			return function(record, index) {
				return _this.isSelected(store, record, index);
			};
		};

		_proto.select = function select(store, record, index, options) {
			this.selectMultiple(store, [record], [index], options);
		};

		_proto.selectMultiple = function selectMultiple(store, records, indexes, options) {
			//abstract
		};

		_proto.declareData = function declareData() {
			var declaration = {
				$selection: {
					structured: true
				}
			};
			return Object.assign.apply(Object, [declaration].concat(Array.prototype.slice.call(arguments)));
		};

		_proto.configureWidget = function configureWidget(widget) {
			if (this.record || this.index) {
				widget.$selection = Object.assign(widget.$selection || {}, {
					record: this.record,
					index: this.index
				});
			}

			return this.declareData();
		};

		_proto.selectInstance = function selectInstance(instance) {
			var store = instance.store,
				data = instance.data;
			if (!data.$selection)
				throw new Error(
					"Selection model not properly configured. Using the selectInstance method without specified record and index bindings."
				);
			return this.select(store, data.$selection.record, data.$selection.index);
		};

		_proto.isInstanceSelected = function isInstanceSelected(instance) {
			var store = instance.store,
				data = instance.data;
			return data.$selection && this.isSelected(store, data.$selection.record, data.$selection.index);
		};

		return Selection;
	})(Component);
Selection.prototype.toggle = false;
Selection.namespace = "ui.selection.";

var SimpleSelection =
	/*#__PURE__*/
	(function(_Selection) {
		_inheritsLoose(SimpleSelection, _Selection);

		function SimpleSelection() {
			return _Selection.apply(this, arguments) || this;
		}

		var _proto2 = SimpleSelection.prototype;

		_proto2.isSelected = function isSelected(store, record, index) {
			return this.getIsSelectedDelegate(store)(record, index);
		};

		_proto2.getIsSelectedDelegate = function getIsSelectedDelegate(store) {
			var selection = this.bind && store.get(this.bind);
			return function(record, index) {
				return record === selection;
			};
		};

		_proto2.selectMultiple = function selectMultiple(store, records, index) {
			if (this.bind) store.set(this.bind, records[0]);
		};

		return SimpleSelection;
	})(Selection);

var DummySelection =
	/*#__PURE__*/
	(function(_Selection2) {
		_inheritsLoose(DummySelection, _Selection2);

		function DummySelection() {
			return _Selection2.apply(this, arguments) || this;
		}

		var _proto3 = DummySelection.prototype;

		_proto3.isSelected = function isSelected(store, record, index) {
			return false;
		};

		_proto3.selectMultiple = function selectMultiple() {
			//dummy
		};

		_proto3.selectInstance = function selectInstance() {
			//dummy
		};

		return DummySelection;
	})(Selection);

DummySelection.prototype.isDummy = true;

Selection.factory = function(name) {
	if (typeof name == "object") return new SimpleSelection(name);
	return new DummySelection();
};

var impl = false;
function tooltipMouseMove(e, parentInstance, tooltip, options) {
	if (options === void 0) {
		options = {};
	}

	return impl && impl.tooltipMouseMove.apply(impl, arguments);
}
function tooltipMouseLeave(e, parentInstance, tooltip, options) {
	return impl && impl.tooltipMouseLeave.apply(impl, arguments);
}
function tooltipParentDidMount(element, parentInstance, tooltip, options) {
	return impl && impl.tooltipParentDidMount.apply(impl, arguments);
}
function tooltipParentWillReceiveProps(element, parentInstance, tooltip, options) {
	return impl && impl.tooltipParentWillReceiveProps.apply(impl, arguments);
}
function tooltipParentWillUnmount(parentInstance) {
	return impl && impl.tooltipParentWillUnmount.apply(impl, arguments);
}

function shallowEquals(v1, v2) {
	if (v1 === v2) return true;
	var t1 = typeof v1,
		t2 = typeof v2,
		k,
		i;
	if (t1 != t2) return false;
	if (v1 == null || v2 == null)
		//this captures undefined too
		return false;

	if (t1 == "object") {
		if (isArray(v1)) {
			if (!isArray(v2) || v1.length != v2.length) return false;

			for (i = 0; i < v1.length; i++) {
				if (!shallowEquals(v1[i], v2[i])) return false;
			}

			return true;
		} else {
			for (k in v1) {
				if (v1.hasOwnProperty(k) && (!v2.hasOwnProperty(k) || v1[k] !== v2[k])) return false;
			}

			for (k in v2) {
				if (v2.hasOwnProperty(k) && (!v1.hasOwnProperty(k) || v1[k] !== v2[k])) return false;
			}

			return true;
		}
	}

	return v1 === v2;
}

var PieChart =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(PieChart, _BoundedObject);

		function PieChart() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = PieChart.prototype;

		_proto.declareData = function declareData() {
			var _BoundedObject$protot;

			(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
				_BoundedObject$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						angle: undefined
					}
				])
			);
		};

		_proto.explore = function explore(context, instance) {
			if (!instance.pie) instance.pie = new PieCalculator();
			var data = instance.data;
			instance.pie.reset(data.angle);
			context.push("pie", instance.pie);

			_BoundedObject.prototype.explore.call(this, context, instance);
		};

		_proto.exploreCleanup = function exploreCleanup(context, instance) {
			context.pop("pie");
		};

		_proto.prepare = function prepare(context, instance) {
			this.prepareBounds(context, instance);
			var data = instance.data,
				pie = instance.pie;
			pie.measure(data.bounds);
			var hash = pie.hash();
			instance.cache("hash", hash);
			pie.shouldUpdate = !shallowEquals(hash, instance.cached.hash);
			if (!pie.shouldUpdate) instance.markShouldUpdate(context);

			_BoundedObject.prototype.prepare.call(this, context, instance);
		};

		return PieChart;
	})(BoundedObject);
PieChart.prototype.anchors = "0 1 1 0";

var PieCalculator =
	/*#__PURE__*/
	(function() {
		function PieCalculator() {}

		var _proto2 = PieCalculator.prototype;

		_proto2.reset = function reset(angle) {
			this.angleTotal = angle / 180 * Math.PI;
			this.stacks = {};
		};

		_proto2.acknowledge = function acknowledge(stack, value) {
			var s = this.stacks[stack];
			if (!s)
				s = this.stacks[stack] = {
					total: 0
				};
			if (value > 0) s.total += value;
		};

		_proto2.hash = function hash() {
			var _this = this;

			return {
				angleTotal: this.angleTotal,
				stacks: Object.keys(this.stacks)
					.map(function(s) {
						return "" + _this.stacks[s].angleFactor;
					})
					.join(":"),
				cx: this.cx,
				cy: this.cy,
				R: this.R
			};
		};

		_proto2.measure = function measure(rect) {
			for (var s in this.stacks) {
				var stack = this.stacks[s];
				stack.angleFactor = stack.total > 0 ? this.angleTotal / stack.total : 0;
				stack.lastAngle = 0;
			}

			this.cx = (rect.l + rect.r) / 2;
			this.cy = (rect.t + rect.b) / 2;
			this.R = Math.max(0, Math.min(rect.width(), rect.height())) / 2;
		};

		_proto2.map = function map(stack, value) {
			var s = this.stacks[stack];
			var angle = value * s.angleFactor;
			var startAngle = s.lastAngle;
			s.lastAngle += angle;
			return {
				startAngle: startAngle,
				endAngle: s.lastAngle,
				midAngle: (startAngle + s.lastAngle) / 2,
				cx: this.cx,
				cy: this.cy,
				R: this.R
			};
		};

		return PieCalculator;
	})();

function createSvgArc(x, y, r0, r, startAngle, endAngle) {
	if (startAngle > endAngle) {
		var s = startAngle;
		startAngle = endAngle;
		endAngle = s;
	}

	var largeArc = endAngle - startAngle <= Math.PI ? 0 : 1;
	if (endAngle - startAngle >= 2 * Math.PI - 0.0001) endAngle = startAngle + 2 * Math.PI - 0.0001;
	var result = [];
	var startX, startY;

	if (r0 > 0) {
		startX = x + Math.cos(endAngle) * r0;
		startY = y - Math.sin(endAngle) * r0;
		result.push("M", startX, startY);
		result.push("A", r0, r0, 0, largeArc, 1, x + Math.cos(startAngle) * r0, y - Math.sin(startAngle) * r0);
	} else {
		startX = x;
		startY = y;
		result.push("M", startX, startY);
	}

	result.push(
		"L",
		x + Math.cos(startAngle) * r,
		y - Math.sin(startAngle) * r,
		"A",
		r,
		r,
		0,
		largeArc,
		0,
		x + Math.cos(endAngle) * r,
		y - Math.sin(endAngle) * r,
		"L",
		startX,
		startY
	);
	return result.join(" ");
}

PieChart.prototype.anchors = "0 1 1 0";
PieChart.prototype.angle = 360;
Widget.alias("pie-slice");
var PieSlice =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(PieSlice, _Container);

		function PieSlice() {
			return _Container.apply(this, arguments) || this;
		}

		var _proto3 = PieSlice.prototype;

		_proto3.init = function init() {
			this.selection = Selection.create(this.selection);

			_Container.prototype.init.call(this);
		};

		_proto3.declareData = function declareData() {
			var _Container$prototype$;

			var selection = this.selection.configureWidget(this);

			(_Container$prototype$ = _Container.prototype.declareData).call.apply(
				_Container$prototype$,
				[this].concat(Array.prototype.slice.call(arguments), [
					selection,
					{
						active: true,
						r0: undefined,
						r: undefined,
						colorIndex: undefined,
						colorMap: undefined,
						colorName: undefined,
						offset: undefined,
						value: undefined,
						disabled: undefined,
						innerPointRadius: undefined,
						outerPointRadius: undefined,
						name: undefined,
						stack: undefined,
						legend: undefined
					}
				])
			);
		};

		_proto3.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			if (data.name && !data.colorName) data.colorName = data.name;

			_Container.prototype.prepareData.call(this, context, instance);
		};

		_proto3.explore = function explore(context, instance) {
			instance.pie = context.pie;
			if (!instance.pie) throw new Error("Pie.Slice must be placed inside a Pie.");
			var data = instance.data;
			instance.valid = isNumber(data.value) && data.value > 0;
			instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
			if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

			if (instance.valid && data.active) {
				instance.pie.acknowledge(data.stack, data.value);

				_Container.prototype.explore.call(this, context, instance);
			}
		};

		_proto3.prepare = function prepare(context, instance) {
			var _this2 = this;

			var data = instance.data,
				segment = instance.segment,
				pie = instance.pie,
				colorMap = instance.colorMap;

			if (colorMap && data.colorName) {
				data.colorIndex = colorMap.map(data.colorName);
				if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
			}

			if (instance.valid && data.active) {
				var seg = pie.map(data.stack, data.value);

				if (
					!segment ||
					instance.shouldUpdate ||
					seg.startAngle != segment.startAngle ||
					seg.endAngle != segment.endAngle ||
					pie.shouldUpdate
				) {
					if (data.offset > 0) {
						seg.ox = seg.cx + Math.cos(seg.midAngle) * data.offset;
						seg.oy = seg.cy - Math.sin(seg.midAngle) * data.offset;
					} else {
						seg.ox = seg.cx;
						seg.oy = seg.cy;
					}

					seg.radiusMultiplier = 1;
					if (this.percentageRadius) seg.radiusMultiplier = seg.R / 100;
					var innerR = data.innerPointRadius != null ? data.innerPointRadius : data.r0;
					var outerR = data.outerPointRadius != null ? data.outerPointRadius : data.r;
					var ix = seg.ox + Math.cos(seg.midAngle) * innerR * seg.radiusMultiplier;
					var iy = seg.oy - Math.sin(seg.midAngle) * innerR * seg.radiusMultiplier;
					var ox = seg.ox + Math.cos(seg.midAngle) * outerR * seg.radiusMultiplier;
					var oy = seg.oy - Math.sin(seg.midAngle) * outerR * seg.radiusMultiplier;
					instance.segment = seg;
					instance.bounds = new Rect({
						l: ix,
						r: ox,
						t: iy,
						b: oy
					});
					instance.markShouldUpdate(context);
				}

				context.push("parentRect", instance.bounds);
			}

			if (data.name && data.legend && context.addLegendEntry)
				context.addLegendEntry(data.legend, {
					name: data.name,
					active: data.active,
					colorIndex: data.colorIndex,
					disabled: data.disabled,
					selected: this.selection.isInstanceSelected(instance),
					style: data.style,
					shape: this.legendShape,
					onClick: function onClick(e) {
						_this2.onLegendClick(e, instance);
					}
				});
		};

		_proto3.prepareCleanup = function prepareCleanup(context, instance) {
			if (instance.valid && instance.data.active) {
				context.pop("parentRect");
			}
		};

		_proto3.onLegendClick = function onLegendClick(e, instance) {
			var allActions = this.legendAction == "auto";
			var data = instance.data;
			if (allActions || this.legendAction == "toggle") if (instance.set("active", !data.active)) return;
			if (allActions || this.legendAction == "select") this.handleClick(e, instance);
		};

		_proto3.render = function render(context, instance, key) {
			var _stateMods,
				_this3 = this;

			var segment = instance.segment,
				data = instance.data;
			if (!instance.valid || !data.active) return null;
			var stateMods = ((_stateMods = {
				selected: this.selection.isInstanceSelected(instance),
				disabled: data.disabled,
				selectable: !this.selection.isDummy
			}),
			(_stateMods["color-" + data.colorIndex] = data.colorIndex != null),
			_stateMods);
			var d = createSvgArc(
				segment.ox,
				segment.oy,
				data.r0 * segment.radiusMultiplier,
				data.r * segment.radiusMultiplier,
				segment.startAngle,
				segment.endAngle
			);
			return VDOM$2.createElement(
				"g",
				{
					key: key,
					className: data.classNames
				},
				VDOM$2.createElement("path", {
					className: this.CSS.element(this.baseClass, "slice", stateMods),
					style: data.style,
					d: d,
					onMouseMove: function onMouseMove(e) {
						tooltipMouseMove(e, instance, _this3.tooltip);
					},
					onMouseLeave: function onMouseLeave(e) {
						tooltipMouseLeave(e, instance, _this3.tooltip);
					},
					onClick: function onClick(e) {
						_this3.handleClick(e, instance);
					}
				}),
				this.renderChildren(context, instance)
			);
		};

		_proto3.handleClick = function handleClick(e, instance) {
			if (!this.selection.isDummy) {
				this.selection.selectInstance(instance);
				e.stopPropagation();
				e.preventDefault();
			}
		};

		return PieSlice;
	})(Container);
PieSlice.prototype.offset = 0;
PieSlice.prototype.r0 = 0;
PieSlice.prototype.r = 50;
PieSlice.prototype.percentageRadius = true;
PieSlice.prototype.baseClass = "pieslice";
PieSlice.prototype.legend = "legend";
PieSlice.prototype.active = true;
PieSlice.prototype.stack = "stack";
PieSlice.prototype.legendAction = "auto";
PieSlice.prototype.legendShape = "rect";
PieSlice.prototype.styled = true;
Widget.alias("pie-chart", PieChart);

debug("The Pie class is deprecated. Please use PieChart instead.");
var Pie = PieChart;
Pie.Slice = PieSlice;

var ColumnBarBase =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(ColumnBarBase, _PureContainer);

		function ColumnBarBase() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = ColumnBarBase.prototype;

		_proto.init = function init() {
			this.selection = Selection.create(this.selection);

			_PureContainer.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			var selection = this.selection.configureWidget(this);
			return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					selection,
					{
						x: undefined,
						y: undefined,
						style: {
							structured: true
						},
						class: {
							structured: true
						},
						className: {
							structured: true
						},
						disabled: undefined,
						colorIndex: undefined,
						colorMap: undefined,
						colorName: undefined,
						name: undefined,
						active: true,
						stacked: undefined,
						stack: undefined,
						offset: undefined
					}
				])
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			instance.axes = context.axes;
			instance.xAxis = context.axes[this.xAxis];
			instance.yAxis = context.axes[this.yAxis];
			var data = instance.data;
			data.valid = this.checkValid(data);
			if (!data.colorName && data.name) data.colorName = data.name;

			_PureContainer.prototype.prepareData.call(this, context, instance);
		};

		_proto.checkValid = function checkValid(data) {
			return true;
		};

		_proto.prepare = function prepare(context, instance) {
			var _this = this;

			var data = instance.data,
				colorMap = instance.colorMap;

			if (colorMap && data.colorName) {
				data.colorIndex = colorMap.map(data.colorName);
				if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
			}

			if (!data.valid) return;

			if (data.active) {
				instance.bounds = this.calculateRect(instance);
				instance.cache("bounds", instance.bounds);
				if (!instance.bounds.isEqual(instance.cached.bounds)) instance.markShouldUpdate(context);
				context.push("parentRect", instance.bounds);
				if (instance.xAxis.shouldUpdate || instance.yAxis.shouldUpdate) instance.markShouldUpdate(context);
			}

			if (data.name && context.addLegendEntry)
				context.addLegendEntry(this.legend, {
					name: data.name,
					active: data.active,
					colorIndex: data.colorIndex,
					disabled: data.disabled,
					selected: this.selection.isInstanceSelected(instance),
					style: data.style,
					shape: this.legendShape,
					onClick: function onClick(e) {
						_this.onLegendClick(e, instance);
					}
				});
		};

		_proto.prepareCleanup = function prepareCleanup(context, instance) {
			var data = instance.data;
			if (data.valid && data.active) context.pop("parentRect");
		};

		_proto.onLegendClick = function onLegendClick(e, instance) {
			var allActions = this.legendAction == "auto";
			var data = instance.data;
			if (allActions || this.legendAction == "toggle") if (instance.set("active", !data.active)) return;
			if (allActions || this.legendAction == "select") this.handleClick(e, instance);
		};

		_proto.calculateRect = function calculateRect(context, instance) {
			throw new Error("Abstract method.");
		};

		_proto.render = function render(context, instance, key) {
			var _stateMods,
				_this2 = this;

			var data = instance.data,
				bounds = instance.bounds;
			if (!data.active || !data.valid) return null;
			var stateMods = ((_stateMods = {
				selected: this.selection.isInstanceSelected(instance),
				disabled: data.disabled,
				selectable: !this.selection.isDummy
			}),
			(_stateMods["color-" + data.colorIndex] = data.colorIndex != null),
			_stateMods);
			return VDOM$2.createElement(
				"g",
				{
					className: data.classNames,
					key: key
				},
				VDOM$2.createElement("rect", {
					className: this.CSS.element(this.baseClass, "rect", stateMods),
					style: data.style,
					x: bounds.l,
					y: bounds.t,
					width: Math.max(0.0001, bounds.width()),
					height: Math.max(0.0001, bounds.height()),
					onMouseMove: function onMouseMove(e) {
						tooltipMouseMove(e, instance, _this2.tooltip);
					},
					onMouseLeave: function onMouseLeave(e) {
						tooltipMouseLeave(e, instance, _this2.tooltip);
					},
					onClick: function onClick(e) {
						_this2.handleClick(e, instance);
					}
				}),
				this.renderChildren(context, instance)
			);
		};

		_proto.handleClick = function handleClick(e, instance) {
			if (!this.selection.isDummy) {
				this.selection.selectInstance(instance);
				e.stopPropagation();
				e.preventDefault();
			}
		};

		return ColumnBarBase;
	})(PureContainer);
ColumnBarBase.prototype.xAxis = "x";
ColumnBarBase.prototype.yAxis = "y";
ColumnBarBase.prototype.offset = 0;
ColumnBarBase.prototype.legend = "legend";
ColumnBarBase.prototype.legendAction = "auto";
ColumnBarBase.prototype.active = true;
ColumnBarBase.prototype.stacked = false;
ColumnBarBase.prototype.stack = "stack";
ColumnBarBase.prototype.legendShape = "rect";
ColumnBarBase.prototype.styled = true;

var Column =
	/*#__PURE__*/
	(function(_ColumnBarBase) {
		_inheritsLoose(Column, _ColumnBarBase);

		function Column() {
			return _ColumnBarBase.apply(this, arguments) || this;
		}

		var _proto = Column.prototype;

		_proto.init = function init() {
			if (isDefined(this.width)) this.size = this.width;

			_ColumnBarBase.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _ColumnBarBase$protot;

			return (_ColumnBarBase$protot = _ColumnBarBase.prototype.declareData).call.apply(
				_ColumnBarBase$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						y0: undefined,
						size: undefined,
						autoSize: undefined
					}
				])
			);
		};

		_proto.checkValid = function checkValid(data) {
			return data.x != null && data.y != null && data.y0 != null;
		};

		_proto.explore = function explore(context, instance) {
			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis;
			instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
			if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);
			if (!data.valid) return;

			if (data.active) {
				xAxis.acknowledge(data.x, data.size, data.offset);
				if (data.autoSize) xAxis.book(data.x, data.stacked ? data.stack : data.name);

				if (data.stacked) {
					yAxis.stacknowledge(data.stack, data.x, data.y0);
					yAxis.stacknowledge(data.stack, data.x, data.y);
				} else {
					if (!this.hiddenBase) yAxis.acknowledge(data.y0);
					yAxis.acknowledge(data.y);
				}

				_ColumnBarBase.prototype.explore.call(this, context, instance);
			}
		};

		_proto.calculateRect = function calculateRect(instance) {
			var data = instance.data;
			var offset = data.offset,
				size = data.size;

			if (data.autoSize) {
				var _instance$xAxis$locat = instance.xAxis.locate(data.x, data.stacked ? data.stack : data.name),
					index = _instance$xAxis$locat[0],
					count = _instance$xAxis$locat[1];

				offset = size / count * (index - count / 2 + 0.5);
				size = size / count;
			}

			var x1 = instance.xAxis.map(data.x, offset - size / 2);
			var x2 = instance.xAxis.map(data.x, offset + size / 2);
			var y1 = data.stacked ? instance.yAxis.stack(data.stack, data.x, data.y0) : instance.yAxis.map(data.y0);
			var y2 = data.stacked ? instance.yAxis.stack(data.stack, data.x, data.y) : instance.yAxis.map(data.y);
			var bounds = new Rect({
				l: Math.min(x1, x2),
				r: Math.max(x1, x2),
				t: Math.min(y1, y2),
				b: Math.max(y1, y2)
			});
			return bounds;
		};

		return Column;
	})(ColumnBarBase);
Column.prototype.baseClass = "column";
Column.prototype.y0 = 0;
Column.prototype.size = 1;
Column.prototype.autoSize = false;
Column.prototype.legendShape = "column";
Column.prototype.hiddenBase = false;
Widget.alias("column", Column);

var Bar =
	/*#__PURE__*/
	(function(_ColumnBarBase) {
		_inheritsLoose(Bar, _ColumnBarBase);

		function Bar() {
			return _ColumnBarBase.apply(this, arguments) || this;
		}

		var _proto = Bar.prototype;

		_proto.init = function init() {
			if (isDefined(this.height)) this.size = this.height;

			_ColumnBarBase.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _ColumnBarBase$protot;

			return (_ColumnBarBase$protot = _ColumnBarBase.prototype.declareData).call.apply(
				_ColumnBarBase$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						x0: undefined,
						size: undefined,
						autoSize: undefined
					}
				])
			);
		};

		_proto.checkValid = function checkValid(data) {
			return data.y != null && data.x != null && data.x0 != null;
		};

		_proto.explore = function explore(context, instance) {
			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis;
			instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
			if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);
			if (!data.valid) return;

			if (data.active) {
				yAxis.acknowledge(data.y, data.size, data.offset);
				if (data.autoSize) yAxis.book(data.y, data.stacked ? data.stack : data.name);

				if (data.stacked) {
					xAxis.stacknowledge(data.stack, data.y, data.x0);
					xAxis.stacknowledge(data.stack, data.y, data.x);
				} else {
					if (!this.hiddenBase) xAxis.acknowledge(data.x0);
					xAxis.acknowledge(data.x);
				}

				_ColumnBarBase.prototype.explore.call(this, context, instance);
			}
		};

		_proto.calculateRect = function calculateRect(instance) {
			var data = instance.data;
			var offset = data.offset,
				size = data.size;

			if (data.autoSize) {
				var _instance$yAxis$locat = instance.yAxis.locate(data.y, data.stacked ? data.stack : data.name),
					index = _instance$yAxis$locat[0],
					count = _instance$yAxis$locat[1];

				offset = size / count * (index - count / 2 + 0.5);
				size = size / count;
			}

			var x1 = data.stacked ? instance.xAxis.stack(data.stack, data.y, data.x0) : instance.xAxis.map(data.x0);
			var x2 = data.stacked ? instance.xAxis.stack(data.stack, data.y, data.x) : instance.xAxis.map(data.x);
			var y1 = instance.yAxis.map(data.y, offset - size / 2);
			var y2 = instance.yAxis.map(data.y, offset + size / 2);
			var bounds = new Rect({
				l: Math.min(x1, x2),
				r: Math.max(x1, x2),
				t: Math.min(y1, y2),
				b: Math.max(y1, y2)
			});
			return bounds;
		};

		return Bar;
	})(ColumnBarBase);
Bar.prototype.baseClass = "bar";
Bar.prototype.x0 = 0;
Bar.prototype.size = 1;
Bar.prototype.autoSize = false;
Bar.prototype.legendShape = "bar";
Bar.prototype.hiddenBase = false;
Widget.alias("bar", Bar);

var Url =
	/*#__PURE__*/
	(function() {
		function Url() {}

		Url.resolve = function resolve(path) {
			return path.replace("~/", this.base);
		};

		Url.absolute = function absolute(path) {
			return path.replace("~/", this.absoluteBase);
		};

		Url.unresolve = function unresolve(path) {
			if (path.indexOf("~/") == 0) return path;
			var absBase = this.absoluteBase || "";
			if (path.indexOf(absBase) == 0) return "~/" + path.substring(absBase.length);
			return "~/" + path.substring(this.base.length);
		};

		Url.getAbsoluteBase = function getAbsoluteBase() {
			return this.absoluteBase;
		};

		Url.isLocal = function isLocal(url) {
			var absBase = this.getAbsoluteBase();
			return url.indexOf("~/") == 0 || url.indexOf(absBase) == 0 || url.indexOf(this.base) == 0;
		};

		Url.setBase = function setBase(base) {
			if (!base || base[base.length - 1] != "/") base += "/";
			this.base = base;
			if (typeof window != "undefined")
				this.absoluteBase = window.location.protocol + "//" + window.location.host + this.base;
		};

		Url.getOrigin = function getOrigin() {
			if (typeof window == "undefined") return "";
			return (
				window.location.protocol +
				"//" +
				window.location.hostname +
				(window.location.port ? ":" + window.location.port : "")
			);
		};

		Url.getBaseFromScriptSrc = function getBaseFromScriptSrc(src, scriptPath) {
			if (!(scriptPath instanceof RegExp)) scriptPath = getBasePathRegex(scriptPath);
			var index = src.search(scriptPath);
			if (index == -1) return false;
			var origin = this.getOrigin();
			return src.substring(src.indexOf(origin) == 0 ? origin.length : 0, index);
		};

		Url.setBaseFromScript = function setBaseFromScript(scriptPath) {
			var scripts = document.getElementsByTagName("script"),
				base;
			if (!(scriptPath instanceof RegExp)) scriptPath = getBasePathRegex(scriptPath);

			for (var i = 0; i < scripts.length; i++) {
				base = this.getBaseFromScriptSrc(scripts[i].src, scriptPath);

				if (base) {
					this.setBase(base);
					return;
				}
			}

			throw new Error("Could not resolve url base from script matching '" + scriptPath + "'.");
		};

		return Url;
	})();
Url.setBase("/");

function getBasePathRegex(str) {
	var regex = "";
	var start = 0;
	if (str.indexOf("~/") == 0) start = 2;

	for (var i = start; i < str.length; i++) {
		switch (str[i]) {
			case ".":
				regex += "\\.";
				break;

			case "*":
				regex += ".*";
				break;

			default:
				regex += str[i];
		}
	}

	return new RegExp(regex + "(\\?.*)?$", "i");
}

var isDataAttribute = function isDataAttribute(attr) {
	return attr.indexOf("data-") == 0 ? attr.substring(5) : false;
};

var urlAttributes = {
	"a.href": true,
	"img.src": true,
	"iframe.src": true
};
var HtmlElement =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(HtmlElement, _Container);

		function HtmlElement(config) {
			var _context;

			var _this;

			_this = _Container.call(this, config) || this;
			if (isUndefined(_this.jsxAttributes) && config)
				_this.jsxAttributes = Object.keys(config).filter((_context = _this).isValidHtmlAttribute.bind(_context));
			return _this;
		}

		var _proto = HtmlElement.prototype;

		_proto.declareData = function declareData() {
			var _this2 = this,
				_Container$prototype$;

			var data = {
				text: undefined,
				innerHtml: undefined,
				attrs: {
					structured: true
				},
				data: {
					structured: true
				}
			};
			var name;
			this.urlAttributes = [];

			if (this.jsxAttributes) {
				this.jsxAttributes.forEach(function(attr) {
					if (urlAttributes[_this2.tag + "." + attr]) _this2.urlAttributes.push(attr);

					if ((name = isDataAttribute(attr))) {
						if (!_this2.data) _this2.data = {};
						_this2.data[name] = _this2[attr];
					} else if ((name = _this2.isValidHtmlAttribute(attr)) && !data.hasOwnProperty(name)) {
						if (name.indexOf("on") == 0) {
							if (_this2[attr]) {
								if (!_this2.events) _this2.events = {};
								_this2.events[name] = _this2[attr];
							}
						} else {
							if (!_this2.attrs) _this2.attrs = {};
							_this2.attrs[name] = _this2[attr];
						}
					}
				});
			}

			if (this.urlAttributes.length == 0) delete this.urlAttributes;

			(_Container$prototype$ = _Container.prototype.declareData).call.apply(
				_Container$prototype$,
				[this].concat(Array.prototype.slice.call(arguments), [data])
			);
		};

		_proto.isValidHtmlAttribute = function isValidHtmlAttribute(attrName) {
			switch (attrName) {
				case "tag":
				case "type":
				case "$type":
				case "$props":
				case "text":
				case "layout":
				case "class":
				case "className":
				case "style":
				case "controller":
				case "outerLayout":
				case "items":
				case "children":
				case "visible":
				case "if":
				case "mod":
				case "putInto":
				case "contentFor":
				case "trimWhitespace":
				case "preserveWhitespace":
				case "ws":
				case "plainText":
				case "vertical":
				case "memoize":
				case "onInit":
				case "onExplore":
				case "onDestroy":
				case "html":
				case "innerText":
				case "baseClass":
				case "CSS":
				case "tooltip":
				case "styles":
				case "jsxAttributes":
				case "jsxSpread":
				case "instance":
				case "store":
					return false;

				default:
					if (isDataAttribute(attrName)) return false;
					break;
			}

			return attrName;
		};

		_proto.init = function init() {
			if (this.html) this.innerHtml = this.html;
			if (this.innerText) this.text = this.innerText;

			_Container.prototype.init.call(this);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;

			if (this.urlAttributes && data.attrs) {
				data.attrs = _objectSpread({}, data.attrs);
				this.urlAttributes.forEach(function(attr) {
					if (isString(data.attrs[attr])) data.attrs[attr] = Url.resolve(data.attrs[attr]);
				});
			}

			_Container.prototype.prepareData.call(this, context, instance);
		};

		_proto.attachProps = function attachProps(context, instance, props) {
			Object.assign(props, this.extraProps);
			if (!isString(this.tag)) props.instance = instance;
		};

		_proto.render = function render(context, instance, key) {
			//rebind events to pass instance
			if (this.events && !instance.events) {
				instance.events = {};

				var _loop = function _loop(eventName) {
					instance.events[eventName] = function(e) {
						return instance.invoke(eventName, e, instance);
					};
				};

				for (var eventName in this.events) {
					_loop(eventName);
				}
			}

			var data = instance.data,
				events = instance.events;
			var props = Object.assign(
				{
					key: key
				},
				data.attrs,
				events
			);
			if (data.classNames) props.className = data.classNames;
			if (data.style) props.style = data.style;
			var children;
			if (isDefined(data.text)) children = data.text;
			else if (isString(data.innerHtml)) {
				props.dangerouslySetInnerHTML = {
					__html: data.innerHtml
				};
			} else {
				children = this.renderChildren(context, instance);
				if (children && isArray(children) && children.length == 0) children = undefined;
			}
			props.children = children;
			this.attachProps(context, instance, props);
			if (this.tooltip)
				return VDOM$2.createElement(
					ContainerComponent,
					{
						key: key,
						tag: this.tag,
						props: props,
						instance: instance,
						data: data
					},
					props.children
				);
			return VDOM$2.createElement(this.tag, props, props.children);
		};

		return HtmlElement;
	})(Container);
HtmlElement.prototype.tag = "div";
HtmlElement.prototype.styled = true;

var ContainerComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(ContainerComponent, _VDOM$Component);

		function ContainerComponent() {
			return _VDOM$Component.apply(this, arguments) || this;
		}

		var _proto2 = ContainerComponent.prototype;

		_proto2.render = function render() {
			var _this3 = this;

			var _this$props = this.props,
				tag = _this$props.tag,
				props = _this$props.props,
				children = _this$props.children,
				instance = _this$props.instance;

			if (instance.widget.tooltip) {
				props.ref = function(c) {
					_this3.el = c;
				};

				var onMouseLeave = props.onMouseLeave,
					onMouseMove = props.onMouseMove;

				props.onMouseLeave = function(e) {
					tooltipMouseLeave(e, instance, instance.widget.tooltip);
					if (onMouseLeave) onMouseLeave(e);
				};

				props.onMouseMove = function(e) {
					tooltipMouseMove(e, instance, instance.widget.tooltip);
					if (onMouseMove) onMouseMove(e);
				};
			}

			return VDOM$2.createElement(tag, props, children);
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			tooltipParentWillUnmount(this.props.instance);
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			tooltipParentWillReceiveProps(this.el, props.instance, this.props.instance.widget.tooltip);
		};

		_proto2.componentDidMount = function componentDidMount() {
			tooltipParentDidMount(this.el, this.props.instance, this.props.instance.widget.tooltip);
		};

		return ContainerComponent;
	})(VDOM$2.Component);

var originalWidgetFactory = Widget.factory; //support for React components

Widget.factory = function(type, config, more) {
	var typeType = typeof type;

	if (typeType == "undefined") {
		debug("Creating a widget of unknown type.", config, more);
		return new HtmlElement(Object.assign({}, config, more));
	}

	if (typeType == "function")
		return HtmlElement.create(
			HtmlElement,
			{
				tag: type
			},
			config
		);
	return originalWidgetFactory.call(Widget, type, config, more);
};

Widget.alias("html-element", HtmlElement);

var shapes = {};
var warnings = {};
function registerShape(name, callback) {
	shapes[name] = callback;
}
function getShape(shapeName) {
	if (shapes[shapeName]) return shapes[shapeName];

	if (!warnings[shapeName]) {
		warnings[shapeName] = true;
		debug("Unknown shape '" + shapeName + "'. Using square instead.");
	}

	return shapes["square"];
}
function getAvailableShapes() {
	return Object.keys(shapes);
}
function circle(cx, cy, size, props, options) {
	return VDOM$2.createElement(
		"circle",
		_extends({}, props, {
			cx: cx,
			cy: cy,
			r: size / 2
		})
	);
}
registerShape("circle", circle);
function square(cx, cy, size, props, options) {
	size *= 0.9;
	return VDOM$2.createElement(
		"rect",
		_extends({}, props, {
			x: cx - size / 2,
			y: cy - size / 2,
			width: size,
			height: size
		})
	);
}
registerShape("square", square);
registerShape("rect", square);
function bar(cx, cy, size, props, options) {
	size *= 0.9;
	return VDOM$2.createElement(
		"rect",
		_extends({}, props, {
			x: cx - size / 2,
			y: cy - size / 4,
			width: size,
			height: size / 2
		})
	);
}
registerShape("bar", bar);
function column(cx, cy, size, props, options) {
	size *= 0.9;
	return VDOM$2.createElement(
		"rect",
		_extends({}, props, {
			x: cx - size / 4,
			y: cy - size / 2,
			width: size / 2,
			height: size
		})
	);
}
registerShape("column", column);
function line(cx, cy, size, props, options) {
	size *= 0.9;
	return VDOM$2.createElement(
		"line",
		_extends({}, props, {
			x1: cx - size / 2,
			y1: cy,
			x2: cx + size / 2,
			y2: cy
		})
	);
}
registerShape("line", line);
registerShape("hline", line);
function vline(cx, cy, size, props, options) {
	size *= 0.9;
	return VDOM$2.createElement(
		"line",
		_extends({}, props, {
			x1: cx,
			y1: cy - size / 2,
			x2: cx,
			y2: cy + size / 2
		})
	);
}
registerShape("vline", vline);
function triangle(cx, cy, size, props, options) {
	size *= 1.29;
	var d = "";
	var cos = Math.cos(Math.PI / 6);
	var sin = Math.sin(Math.PI / 6);
	d += "M " + cx + " " + (cy - size / 2) + " ";
	d += "L " + (cx + cos * size / 2) + " " + (cy + sin * size / 2) + " ";
	d += "L " + (cx - cos * size / 2) + " " + (cy + sin * size / 2) + " ";
	d += "Z";
	return VDOM$2.createElement(
		"path",
		_extends({}, props, {
			d: d
		})
	);
}
registerShape("triangle", triangle);

var Legend =
	/*#__PURE__*/
	(function(_HtmlElement) {
		_inheritsLoose(Legend, _HtmlElement);

		function Legend() {
			return _HtmlElement.apply(this, arguments) || this;
		}

		var _proto = Legend.prototype;

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			data.stateMods = Object.assign(data.stateMods || {}, {
				vertical: this.vertical
			});

			_HtmlElement.prototype.prepareData.call(this, context, instance);
		};

		_proto.isValidHtmlAttribute = function isValidHtmlAttribute(attrName) {
			switch (attrName) {
				case "shapeSize":
					return false;

				default:
					return _HtmlElement.prototype.isValidHtmlAttribute.call(this, attrName);
			}
		};

		_proto.explore = function explore(context, instance) {
			if (!context.legends) context.legends = {};
			instance.legends = context.legends;

			context.addLegendEntry = function(legendName, entry) {
				//case when all legends are scoped and new entry is added outside the scope
				if (!context.legends) return;
				var legend = context.legends[legendName];
				if (!legend)
					legend = context.legends[legendName] = {
						entries: [],
						names: {}
					};

				if (!legend.names[entry.name]) {
					legend.entries.push(entry);
					legend.names[entry.name] = entry;
				}
			};

			_HtmlElement.prototype.explore.call(this, context, instance);
		};

		_proto.renderChildren = function renderChildren(context, instance) {
			var _this = this;

			var CSS = this.CSS;
			var entries = instance.legends[this.name] && instance.legends[this.name].entries,
				list;

			if (isArray(entries) && entries.length > 0) {
				list = VDOM$2.createElement(
					"div",
					{
						key: "wrap",
						className: CSS.element(this.baseClass, "wrap")
					},
					entries.map(function(e, i) {
						return VDOM$2.createElement(
							"div",
							{
								key: i,
								className: CSS.element(_this.baseClass, "entry"),
								onClick: e.onClick
							},
							_this.renderShape(e),
							e.name
						);
					})
				);
			}

			return [list, _HtmlElement.prototype.renderChildren.call(this, context, instance)];
		};

		_proto.renderShape = function renderShape(entry) {
			var _this$CSS$element;

			var className = this.CSS.element(
				this.baseClass,
				"shape",
				((_this$CSS$element = {
					disabled: entry.disabled,
					selected: entry.selected
				}),
				(_this$CSS$element["color-" + entry.colorIndex] =
					entry.colorIndex != null && (isUndefined(entry.active) || entry.active)),
				_this$CSS$element)
			);
			var shape = getShape(entry.shape || "square");
			return VDOM$2.createElement(
				"svg",
				{
					className: this.CSS.element(this.baseClass, "svg"),
					style: {
						width: this.svgSize + "px",
						height: this.svgSize + "px",
						marginTop: -this.svgSize / 2 + "px"
					}
				},
				shape(this.svgSize / 2, this.svgSize / 2, entry.shapeSize || this.shapeSize, {
					style: entry.style,
					className: className
				})
			);
		};

		return Legend;
	})(HtmlElement);
Legend.prototype.name = "legend";
Legend.prototype.baseClass = "legend";
Legend.prototype.vertical = false;
Legend.prototype.memoize = false;
Legend.prototype.shapeSize = 18;
Legend.prototype.svgSize = 20;
Widget.alias("legend", Legend);

Legend.Scope =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(_class, _PureContainer);

		function _class() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto2 = _class.prototype;

		_proto2.explore = function explore(context, instance) {
			context.push("legends", (instance.legends = {}));

			_PureContainer.prototype.explore.call(this, context, instance);
		};

		_proto2.exploreCleanup = function exploreCleanup(context, instance) {
			context.pop("legends");
		};

		_proto2.prepare = function prepare(context, instance) {
			context.push("legends", instance.legends);
		};

		_proto2.prepareCleanup = function prepareCleanup(context, instance) {
			context.pop("legends");
		};

		return _class;
	})(PureContainer);

var stopPropagation = function stopPropagation(e) {
	return e.stopPropagation();
};

var LegendEntry =
	/*#__PURE__*/
	(function(_HtmlElement) {
		_inheritsLoose(LegendEntry, _HtmlElement);

		function LegendEntry() {
			return _HtmlElement.apply(this, arguments) || this;
		}

		var _proto = LegendEntry.prototype;

		_proto.init = function init() {
			this.selection = Selection.create(this.selection);

			_HtmlElement.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _HtmlElement$prototyp;

			var selection = this.selection.configureWidget(this);

			(_HtmlElement$prototyp = _HtmlElement.prototype.declareData).call.apply(
				_HtmlElement$prototyp,
				[this].concat(Array.prototype.slice.call(arguments), [
					selection,
					{
						selected: undefined,
						shape: undefined,
						colorIndex: undefined,
						colorMap: undefined,
						colorName: undefined,
						name: undefined,
						active: true,
						size: undefined
					}
				])
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			if (data.name && !data.colorName) data.colorName = data.name;

			_HtmlElement.prototype.prepareData.call(this, context, instance);
		};

		_proto.explore = function explore(context, instance) {
			var data = instance.data;
			instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
			if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

			_HtmlElement.prototype.explore.call(this, context, instance);
		};

		_proto.prepare = function prepare(context, instance) {
			var data = instance.data,
				colorMap = instance.colorMap;

			if (colorMap && data.colorName) {
				data.colorIndex = colorMap.map(data.colorName);
				if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
			}
		};

		_proto.attachProps = function attachProps(context, instance, props) {
			var _this = this;

			var shape = this.renderShape(instance);
			props.children = [shape, props.children];
			props.onMouseDown = stopPropagation;

			props.onClick = function(e) {
				_this.handleClick(e, instance);
			};

			delete props.active;
			delete props.selection;
			delete props.colorMap;
			delete props.colorIndex;
			delete props.shape;
			delete props.name;
			delete props.selected;
		};

		_proto.handleClick = function handleClick(e, instance) {
			if (this.onClick && instance.invoke("onClick", e, instance) === false) return;
			e.stopPropagation();
			var any = this.legendAction == "auto";
			if (any || this.legendAction == "toggle") if (instance.set("active", !instance.data.active)) return;
			if ((any || this.legendAction == "select") && !this.selection.isDummy) this.selection.selectInstance(instance);
		};

		_proto.renderShape = function renderShape(instance) {
			var _this$CSS$element;

			var entry = instance.data;
			var className = this.CSS.element(
				this.baseClass,
				"shape",
				((_this$CSS$element = {
					disabled: entry.disabled,
					selected: entry.selected || this.selection.isInstanceSelected(instance)
				}),
				(_this$CSS$element["color-" + entry.colorIndex] =
					entry.colorIndex != null && (isUndefined(entry.active) || entry.active)),
				_this$CSS$element)
			);
			var shape = getShape(entry.shape || "square");
			return VDOM$2.createElement(
				"svg",
				{
					key: "svg",
					className: this.CSS.element(this.baseClass, "svg"),
					style: {
						width: this.svgSize + "px",
						height: this.svgSize + "px",
						marginTop: -this.svgSize / 2 + "px"
					}
				},
				shape(this.svgSize / 2, this.svgSize / 2, entry.size, {
					style: entry.style,
					className: className
				})
			);
		};

		return LegendEntry;
	})(HtmlElement);
LegendEntry.prototype.baseClass = "legendentry";
LegendEntry.prototype.shape = "square";
LegendEntry.prototype.legendAction = "auto";
LegendEntry.prototype.size = 18;
LegendEntry.prototype.svgSize = 20;
Widget.alias("legend-entry", LegendEntry);

var ColorMap =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(ColorMap, _Widget);

		function ColorMap() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = ColorMap.prototype;

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						names: undefined,
						offset: undefined,
						step: undefined,
						size: undefined
					}
				])
			);
		};

		_proto.explore = function explore(context, instance) {
			var _this = this;

			if (!context.colorMaps) context.colorMaps = {};

			context.getColorMap = function(colorMap) {
				var map = context.colorMaps[colorMap];

				if (!map) {
					var cache = _this.onGetCache ? instance.invoke("onGetCache") : {};
					map = cache[colorMap];

					if (!map) {
						var data = instance.data;
						map = context.colorMaps[colorMap] = cache[colorMap] = new ColorIndex({
							offset: data.offset,
							step: data.step,
							size: data.size
						});
					}

					if (Array.isArray(instance.data.names))
						instance.data.names.forEach(function(name) {
							return map.acknowledge(name);
						});
				}

				return map;
			};
		};

		_proto.render = function render() {
			return null;
		};

		return ColorMap;
	})(Widget);
ColorMap.prototype.offset = 0;
ColorMap.prototype.step = null;
ColorMap.prototype.size = 16;
var ColorMapScope =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(ColorMapScope, _PureContainer);

		function ColorMapScope() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto2 = ColorMapScope.prototype;

		_proto2.explore = function explore(context, instance) {
			context.push("colorMaps", (instance.colorMaps = {}));

			_PureContainer.prototype.explore.call(this, context, instance);
		};

		_proto2.exploreCleanup = function exploreCleanup(context, instance) {
			context.pop("colorMaps");
		};

		_proto2.prepare = function prepare(context, instance) {
			context.push("colorMaps", instance.colorMaps);
		};

		_proto2.prepareCleanup = function prepareCleanup(context, instance) {
			context.pop("colorMaps");
		};

		return ColorMapScope;
	})(PureContainer);
ColorMap.Scope = ColorMapScope;
Widget.alias("color-map", ColorMap);
var ColorIndex =
	/*#__PURE__*/
	(function() {
		function ColorIndex(_ref) {
			var offset = _ref.offset,
				step = _ref.step,
				size = _ref.size;
			this.colorMap = {};
			this.dirty = true;
			this.offset = offset;
			this.step = step;
			this.size = size;
		}

		var _proto3 = ColorIndex.prototype;

		_proto3.acknowledge = function acknowledge(name) {
			if (!(name in this.colorMap)) {
				this.colorMap[name] = Object.keys(this.colorMap).length;
				this.dirty = true;
			}
		};

		_proto3.map = function map(name) {
			if (this.dirty) {
				this.dirty = false;

				if (!this.step) {
					var n = Object.keys(this.colorMap).length;
					this.step = n > 0 ? this.size / n : 1;
				}
			}

			var index = this.colorMap[name] || 0;
			return Math.round(this.offset + this.step * index + this.size) % this.size;
		};

		return ColorIndex;
	})();

var SubscriberList =
	/*#__PURE__*/
	(function() {
		function SubscriberList() {
			this.clear();
		}

		var _proto = SubscriberList.prototype;

		_proto.getSlot = function getSlot() {
			if (this.freeSlots.length) return this.freeSlots.pop();
			var slot = String(this.nextSlot++);
			return slot;
		};

		_proto.recycle = function recycle(slot, callback) {
			if (this.subscriptions[slot] === callback) {
				this.freeSlots.push(slot);
				delete this.subscriptions[slot];
				this.subscriptionCount--;
			}
		};

		_proto.subscribe = function subscribe(callback) {
			var _this = this;

			var slot = this.getSlot();
			this.subscriptions[slot] = callback;
			this.subscriptionCount++;
			return function() {
				_this.recycle(slot, callback);
			};
		};

		_proto.clear = function clear() {
			this.subscriptions = {};
			this.freeSlots = [];
			this.nextSlot = 1;
			this.subscriptionCount = 0;
		};

		_proto.isEmpty = function isEmpty() {
			return this.subscriptionCount == 0;
		};

		_proto.getSubscribers = function getSubscribers() {
			var result = [];

			for (var key in this.subscriptions) {
				result.push(this.subscriptions[key]);
			}

			return result;
		};

		_proto.notify = function notify() {
			for (var key in this.subscriptions) {
				var _this$subscriptions;

				(_this$subscriptions = this.subscriptions)[key].apply(_this$subscriptions, arguments);
			}
		};

		_proto.execute = function execute(callback) {
			for (var key in this.subscriptions) {
				callback(this.subscriptions[key]);
			}
		};

		return SubscriberList;
	})();

var promiseSubscribers = new SubscriberList();
function batchUpdates(callback) {
	if (VDOM$2.DOM.unstable_batchedUpdates)
		VDOM$2.DOM.unstable_batchedUpdates(function() {
			try {
				callback();
			} finally {
			}
		});
	else callback();
}

function getParentFrameBoundingClientRect(el) {
	if (el.ownerDocument == document) {
		return {
			top: 0,
			left: 0,
			right: window.innerWidth,
			bottom: window.innerHeight,
			width: window.innerWidth,
			height: window.innerHeight
		};
	}

	var frames = document.getElementsByTagName("iframe");

	for (var i = 0; i < frames.length; i++) {
		if (frames[i].contentDocument == el.ownerDocument) {
			return frames[i].getBoundingClientRect();
		}
	}
}

function captureMouse(e, onMouseMove, onMouseUp, captureData, cursor) {
	var surface = document.createElement("div");
	surface.className = "cxb-mousecapture";
	if (cursor) surface.style.cursor = cursor;
	document.body.appendChild(surface);

	if (surface.setCapture) {
		e.preventDefault();
		surface.setCapture(true);
	}

	var move = function move(e) {
		batchUpdates(function() {
			if (onMouseMove) onMouseMove(e, captureData);
			e.stopPropagation();
			e.preventDefault(); //disable text selection
		});
	};

	var end = function end(e) {
		batchUpdates(function() {
			if (surface.releaseCapture) surface.releaseCapture();
			surface.style.display = "none";

			try {
				if (onMouseUp) onMouseUp(e, captureData);
			} finally {
				surface.removeEventListener("mousemove", move);
				surface.removeEventListener("mouseup", end);
				document.body.removeChild(surface);
			}
		});
	};

	surface.addEventListener("mousemove", move);
	surface.addEventListener("mouseup", end);
	e.stopPropagation();
}
function captureMouseOrTouch(e, onMouseMove, onMouseUp, captureData, cursor) {
	if (e.type.indexOf("touch") == 0) {
		var el = e.currentTarget;

		var move = function move(e) {
			batchUpdates(function() {
				if (onMouseMove) onMouseMove(e, captureData);
				e.preventDefault();
			});
		};

		var end = function end(e) {
			batchUpdates(function() {
				el.removeEventListener("touchmove", move);
				el.removeEventListener("touchend", end);
				if (onMouseUp) onMouseUp(e);
				e.preventDefault();
			});
		};

		el.addEventListener("touchmove", move);
		el.addEventListener("touchend", end);
		e.stopPropagation();
	} else captureMouse(e, onMouseMove, onMouseUp, captureData, cursor || e.target.style.cursor);
}
function getCursorPos(e) {
	var p = (e.touches && e.touches[0]) || e;
	var offset = getParentFrameBoundingClientRect(e.target);
	return {
		clientX: p.clientX + offset.left,
		clientY: p.clientY + offset.top
	};
}

function closest(el, condition) {
	while (el) {
		if (condition(el)) return el;
		el = el.parentNode;
	}

	return null;
}

function getTopLevelBoundingClientRect(el) {
	var bounds = el.getBoundingClientRect();
	var offset = getParentFrameBoundingClientRect(el);
	return {
		top: bounds.top + offset.top,
		left: bounds.left + offset.left,
		bottom: bounds.bottom + offset.top,
		right: bounds.right + offset.left,
		width: bounds.right - bounds.left,
		height: bounds.bottom - bounds.top
	};
}

var Marker =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(Marker, _BoundedObject);

		function Marker() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = Marker.prototype;

		_proto.init = function init() {
			this.selection = Selection.create(this.selection);

			if (this.draggable) {
				this.draggableX = true;
				this.draggableY = true;
			}

			if (this.constrain) {
				this.constrainX = true;
				this.constrainY = true;
			}

			_BoundedObject.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _BoundedObject$protot;

			var selection = this.selection.configureWidget(this);
			return (_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
				_BoundedObject$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					selection,
					{
						x: undefined,
						y: undefined,
						size: undefined,
						shape: undefined,
						disabled: undefined,
						colorMap: undefined,
						colorIndex: undefined,
						colorName: undefined,
						legendColorIndex: undefined,
						name: undefined,
						active: true
					}
				])
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			instance.axes = context.axes;
			instance.xAxis = context.axes[this.xAxis];
			instance.yAxis = context.axes[this.yAxis];
			var data = instance.data;
			data.selected = this.selection.isInstanceSelected(instance);
			data.stateMods = {
				selected: data.selected,
				disabled: data.disabled,
				selectable: !this.selection.isDummy,
				"draggable-x": this.draggableX && !this.draggableY,
				"draggable-y": this.draggableY && !this.draggableX,
				"draggable-xy": this.draggableY && this.draggableX
			};
			if (data.name && !data.colorName) data.colorName = data.name;

			_BoundedObject.prototype.prepareData.call(this, context, instance);
		};

		_proto.calculateBounds = function calculateBounds(context, instance) {
			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis;
			var x, y;

			if (data.x == null || data.y == null) {
				var bounds = _BoundedObject.prototype.calculateBounds.call(this, context, instance);

				x = (bounds.l + bounds.r) / 2;
				y = (bounds.t + bounds.b) / 2;
			}

			if (data.x != null) x = xAxis.map(data.x);
			if (data.y != null) y = yAxis.map(data.y);
			return new Rect({
				l: x - data.size / 2,
				r: x + data.size / 2,
				t: y - data.size / 2,
				b: y + data.size / 2
			});
		};

		_proto.explore = function explore(context, instance) {
			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis;
			instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
			if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

			if (data.active) {
				if (xAxis && data.x != null) xAxis.acknowledge(data.x, 0, this.xOffset);
				if (yAxis && data.y != null) yAxis.acknowledge(data.y, 0, this.yOffset);
				if (context.pointReducer) context.pointReducer(data.x, data.y, data.name, data);

				_BoundedObject.prototype.explore.call(this, context, instance);
			}
		};

		_proto.prepare = function prepare(context, instance) {
			var _this = this;

			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis,
				colorMap = instance.colorMap;

			if (colorMap && data.colorName) {
				data.colorIndex = colorMap.map(data.colorName);
				if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
			}

			if (data.active) {
				if (xAxis && xAxis.shouldUpdate) instance.markShouldUpdate(context);
				if (yAxis && yAxis.shouldUpdate) instance.markShouldUpdate(context);
			}

			_BoundedObject.prototype.prepare.call(this, context, instance);

			if (data.name && context.addLegendEntry)
				context.addLegendEntry(this.legend, {
					name: data.name,
					active: data.active,
					colorIndex: data.legendColorIndex || data.colorIndex,
					disabled: data.disabled,
					selected: data.selected,
					style: data.style,
					shape: data.shape,
					onClick: function onClick(e) {
						_this.onLegendClick(e, instance);
					}
				});
		};

		_proto.onLegendClick = function onLegendClick(e, instance) {
			var allActions = this.legendAction == "auto";
			var data = instance.data;
			if (allActions || this.legendAction == "toggle") if (instance.set("active", !data.active)) return;
			if (allActions || this.legendAction == "select") this.handleClick(e, instance);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			if (!data.active || data.x === null || data.y === null) return null;
			return VDOM$2.createElement(
				MarkerComponent,
				{
					key: key,
					instance: instance,
					data: instance.data,
					shouldUpdate: instance.shouldUpdate
				},
				this.renderChildren(context, instance)
			);
		};

		_proto.handleMouseDown = function handleMouseDown(e, instance) {
			var _this2 = this;

			if (this.draggableX || this.draggableY) {
				var svgEl = closest(e.target, function(el) {
					return el.tagName == "svg";
				});
				if (svgEl)
					captureMouseOrTouch(
						e,
						function(e, captureData) {
							_this2.handleDragMove(e, instance, captureData);
						},
						null,
						{
							svgEl: svgEl,
							el: e.target
						},
						e.target.style.cursor
					);
			} else {
				if (!this.selection.isDummy) this.selection.selectInstance(instance);
			}
		};

		_proto.handleClick = function handleClick(e, instance) {
			if (this.onClick) instance.invoke("onClick", e, instance);
		};

		_proto.handleDragMove = function handleDragMove(e, instance, captureData) {
			var cursor = getCursorPos(e);
			var svgBounds = getTopLevelBoundingClientRect(captureData.svgEl);
			var xAxis = instance.xAxis,
				yAxis = instance.yAxis;

			if (this.draggableX && xAxis) {
				var x = xAxis.trackValue(cursor.clientX - svgBounds.left, this.xOffset);
				if (this.constrainX) x = xAxis.constrainValue(x);
				instance.set("x", xAxis.encodeValue(x));
			}

			if (this.draggableY && yAxis) {
				var y = yAxis.trackValue(cursor.clientY - svgBounds.top, this.yOffset);
				if (this.constrainY) y = yAxis.constrainValue(y);
				instance.set("y", yAxis.encodeValue(y));
			}

			tooltipMouseMove(e, instance, this.tooltip, {
				target: captureData.el
			});
		};

		return Marker;
	})(BoundedObject);
Marker.prototype.xOffset = 0;
Marker.prototype.yOffset = 0;
Marker.prototype.size = 5;
Marker.prototype.anchors = "0.5 0.5 0.5 0.5";
Marker.prototype.xAxis = "x";
Marker.prototype.yAxis = "y";
Marker.prototype.baseClass = "marker";
Marker.prototype.draggableX = false;
Marker.prototype.draggableY = false;
Marker.prototype.draggable = false;
Marker.prototype.constrainX = false;
Marker.prototype.constrainY = false;
Marker.prototype.constrain = false;
Marker.prototype.legend = "legend";
Marker.prototype.legendAction = "auto";
Marker.prototype.shape = "circle";
Marker.prototype.styled = true;
Marker.prototype.hidden = false;
BoundedObject.alias("marker", Marker);

var MarkerComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(MarkerComponent, _VDOM$Component);

		function MarkerComponent() {
			return _VDOM$Component.apply(this, arguments) || this;
		}

		var _proto2 = MarkerComponent.prototype;

		_proto2.shouldComponentUpdate = function shouldComponentUpdate(props) {
			return props.shouldUpdate;
		};

		_proto2.render = function render() {
			var _CSS$element,
				_this3 = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				children = _this$props.children,
				data = _this$props.data;
			var widget = instance.widget;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var bounds = data.bounds,
				shape = data.shape;
			var shapeRenderer = getShape(shape);
			var shapeProps = {
				className: CSS.element(
					baseClass,
					"shape",
					((_CSS$element = {}),
					(_CSS$element["color-" + data.colorIndex] = data.colorIndex != null),
					(_CSS$element.selected = data.selected),
					_CSS$element)
				),
				style: data.style,
				cx: (bounds.l + bounds.r) / 2,
				cy: (bounds.t + bounds.b) / 2,
				r: data.size / 2,
				onMouseMove: function onMouseMove(e) {
					tooltipMouseMove(e, instance, widget.tooltip);
				},
				onMouseLeave: function onMouseLeave(e) {
					tooltipMouseLeave(e, instance, widget.tooltip);
				},
				onMouseDown: function onMouseDown(e) {
					widget.handleMouseDown(e, instance);
				},
				onTouchStart: function onTouchStart(e) {
					widget.handleMouseDown(e, instance);
				},
				onClick: function onClick(e) {
					widget.handleClick(e, instance);
				}
			};

			if (widget.tooltip) {
				shapeProps.ref = function(c) {
					_this3.el = c;
				};
			}

			return VDOM$2.createElement(
				"g",
				{
					className: data.classNames
				},
				!widget.hidden && shapeRenderer((bounds.l + bounds.r) / 2, (bounds.t + bounds.b) / 2, data.size, shapeProps),
				children
			);
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			tooltipParentWillUnmount(this.props.instance);
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			tooltipParentWillReceiveProps(this.el, props.instance, props.instance.widget.tooltip);
		};

		_proto2.componentDidMount = function componentDidMount() {
			tooltipParentDidMount(this.el, this.props.instance, this.props.instance.widget.tooltip);
		};

		return MarkerComponent;
	})(VDOM$2.Component);

var MarkerLine =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(MarkerLine, _BoundedObject);

		function MarkerLine() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = MarkerLine.prototype;

		_proto.init = function init() {
			if (isDefined(this.x)) this.x1 = this.x2 = this.x;
			if (isDefined(this.y)) this.y1 = this.y2 = this.y;

			_BoundedObject.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _BoundedObject$protot;

			(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
				_BoundedObject$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						x1: undefined,
						y1: undefined,
						x2: undefined,
						y2: undefined,
						colorIndex: undefined,
						active: true,
						name: undefined,
						legend: undefined
					}
				])
			);
		};

		_proto.explore = function explore(context, instance) {
			var data = instance.data;
			var xAxis = (instance.xAxis = context.axes[this.xAxis]);
			var yAxis = (instance.yAxis = context.axes[this.yAxis]);

			if (data.active) {
				if (data.x1 != null) xAxis.acknowledge(data.x1);
				if (data.x2 != null) xAxis.acknowledge(data.x2);
				if (data.y1 != null) yAxis.acknowledge(data.y1);
				if (data.y2 != null) yAxis.acknowledge(data.y2);

				_BoundedObject.prototype.explore.call(this, context, instance);
			}
		};

		_proto.prepare = function prepare(context, instance) {
			var _this = this;

			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis;
			if ((xAxis && xAxis.shouldUpdate) || (yAxis && yAxis.shouldUpdate)) instance.markShouldUpdate(context);

			_BoundedObject.prototype.prepare.call(this, context, instance);

			if (data.name && data.legend && context.addLegendEntry)
				context.addLegendEntry(data.legend, {
					name: data.name,
					active: data.active,
					colorIndex: data.colorIndex,
					style: data.style,
					shape: "line",
					onClick: function onClick(e) {
						_this.onLegendClick(e, instance);
					}
				});
		};

		_proto.calculateBounds = function calculateBounds(context, instance) {
			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis;

			var bounds = _BoundedObject.prototype.calculateBounds.call(this, context, instance);

			var x1 = bounds.l,
				x2 = bounds.r,
				y1 = bounds.t,
				y2 = bounds.b;
			if (data.x1 != null) x1 = xAxis.map(data.x1);
			if (data.x2 != null) x2 = xAxis.map(data.x2);
			if (data.y1 != null) y1 = yAxis.map(data.y1);
			if (data.y2 != null) y2 = yAxis.map(data.y2);
			bounds.l = Math.min(x1, x2);
			bounds.t = Math.min(y1, y2);
			bounds.r = Math.max(x1, x2);
			bounds.b = Math.max(y1, y2);
			instance.x1 = x1;
			instance.x2 = x2;
			instance.y1 = y1;
			instance.y2 = y2;
			return bounds;
		};

		_proto.render = function render(context, instance, key) {
			var _stateMods;

			var data = instance.data,
				x1 = instance.x1,
				x2 = instance.x2,
				y1 = instance.y1,
				y2 = instance.y2;
			if (!data.active || data.x1 === null || data.x2 === null || data.y1 === null || data.y2 === null) return null;
			var stateMods = ((_stateMods = {}),
			(_stateMods["color-" + data.colorIndex] = data.colorIndex != null),
			_stateMods);
			return VDOM$2.createElement(
				"g",
				{
					key: key,
					className: data.classNames
				},
				VDOM$2.createElement("line", {
					className: this.CSS.element(this.baseClass, "line", stateMods),
					style: data.style,
					x1: x1,
					y1: y1,
					x2: x2,
					y2: y2
				}),
				this.renderChildren(context, instance)
			);
		};

		return MarkerLine;
	})(BoundedObject);
MarkerLine.prototype.xAxis = "x";
MarkerLine.prototype.yAxis = "y";
MarkerLine.prototype.anchors = "0 1 1 0";
MarkerLine.prototype.baseClass = "markerline";
MarkerLine.prototype.legend = "legend";
MarkerLine.prototype.legendAction = "auto";
BoundedObject.alias("marker-line", MarkerLine);

var Range =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(Range, _BoundedObject);

		function Range() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = Range.prototype;

		_proto.declareData = function declareData() {
			var _BoundedObject$protot;

			(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
				_BoundedObject$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						x1: undefined,
						y1: undefined,
						x2: undefined,
						y2: undefined,
						colorIndex: undefined,
						active: true,
						name: undefined,
						legend: undefined
					}
				])
			);
		};

		_proto.explore = function explore(context, instance) {
			var data = instance.data;
			var xAxis = (instance.xAxis = context.axes[this.xAxis]);
			var yAxis = (instance.yAxis = context.axes[this.yAxis]);

			if (data.active) {
				if (xAxis) {
					if (data.x1 != null) instance.xAxis.acknowledge(data.x1, this.xSize, this.xOffset);
					if (data.x2 != null) instance.xAxis.acknowledge(data.x2, this.xSize, this.xOffset);
				}

				if (yAxis) {
					if (data.y1 != null) instance.yAxis.acknowledge(data.y1, this.ySize, this.yOffset);
					if (data.y2 != null) instance.yAxis.acknowledge(data.y2, this.ySize, this.yOffset);
				}

				_BoundedObject.prototype.explore.call(this, context, instance);
			}
		};

		_proto.prepare = function prepare(context, instance) {
			var _this = this;

			_BoundedObject.prototype.prepare.call(this, context, instance);

			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis;
			if (xAxis && xAxis.shouldUpdate) instance.markShouldUpdate(context);
			if (yAxis && yAxis.shouldUpdate) instance.markShouldUpdate(context);
			if (data.name && data.legend && context.addLegendEntry)
				context.addLegendEntry(data.legend, {
					name: data.name,
					active: data.active,
					colorIndex: data.colorIndex,
					style: data.style,
					shape: "rect",
					onClick: function onClick(e) {
						_this.onLegendClick(e, instance);
					}
				});
		};

		_proto.onLegendClick = function onLegendClick(e, instance) {
			var allActions = this.legendAction == "auto";
			var data = instance.data;
			if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
		};

		_proto.calculateBounds = function calculateBounds(context, instance) {
			var bounds = _BoundedObject.prototype.calculateBounds.call(this, context, instance);

			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis;
			if (data.x1 != null) bounds.l = xAxis.map(data.x1, this.xOffset - this.xSize / 2);
			if (data.x2 != null) bounds.r = xAxis.map(data.x2, this.xOffset + this.xSize / 2);
			if (data.y1 != null) bounds.t = yAxis.map(data.y1, this.yOffset - this.ySize / 2);
			if (data.y2 != null) bounds.b = yAxis.map(data.y2, this.yOffset + this.ySize / 2);
			return bounds;
		};

		_proto.render = function render(context, instance, key) {
			var _stateMods,
				_this2 = this;

			var data = instance.data;
			if (!data.active) return null;
			var bounds = data.bounds;
			var x1 = Math.min(bounds.l, bounds.r),
				y1 = Math.min(bounds.t, bounds.b),
				x2 = Math.max(bounds.l, bounds.r),
				y2 = Math.max(bounds.t, bounds.b);
			var stateMods = ((_stateMods = {}),
			(_stateMods["color-" + data.colorIndex] = data.colorIndex != null),
			_stateMods);
			return VDOM$2.createElement(
				"g",
				{
					key: key,
					className: data.classNames
				},
				!this.hidden &&
					VDOM$2.createElement("rect", {
						className: this.CSS.element(this.baseClass, "rect", stateMods),
						style: data.style,
						x: x1,
						y: y1,
						width: x2 - x1,
						height: y2 - y1,
						onMouseDown: function onMouseDown(e) {
							return _this2.handleMouseDown(e, instance);
						},
						onTouchStart: function onTouchStart(e) {
							return _this2.handleMouseDown(e, instance);
						}
					}),
				this.renderChildren(context, instance)
			);
		};

		_proto.handleClick = function handleClick(e, instance) {
			if (this.onClick) instance.invoke("onClick", e, instance);
		};

		_proto.handleMouseDown = function handleMouseDown(e, instance) {
			var _this3 = this;

			if (this.draggableX || this.draggableY) {
				var svgEl = closest(e.target, function(el) {
					return el.tagName == "svg";
				});
				var svgBounds = getTopLevelBoundingClientRect(svgEl);
				var cursor = getCursorPos(e);
				var data = instance.data,
					xAxis = instance.xAxis,
					yAxis = instance.yAxis;
				var captureData = {
					svgBounds: svgBounds,
					start: {
						x1: data.x1,
						x2: data.x2,
						y1: data.y1,
						y2: data.y2
					}
				};
				if (this.draggableX && xAxis)
					captureData.start.x = xAxis.trackValue(cursor.clientX - svgBounds.left, this.xOffset, this.constrainX);
				if (this.draggableY && yAxis)
					captureData.start.y = yAxis.trackValue(cursor.clientY - svgBounds.top, this.yOffset, this.constrainY);
				if (svgEl)
					captureMouseOrTouch(
						e,
						function(e, captureData) {
							_this3.handleDragMove(e, instance, captureData);
						},
						null,
						captureData,
						e.target.style.cursor
					);
			}
		};

		_proto.handleDragMove = function handleDragMove(e, instance, captureData) {
			var cursor = getCursorPos(e);
			var xAxis = instance.xAxis,
				yAxis = instance.yAxis;
			var svgBounds = captureData.svgBounds,
				start = captureData.start;

			if (this.draggableX && xAxis) {
				var dist =
					xAxis.trackValue(cursor.clientX - svgBounds.left, this.xOffset, this.constrainX) - captureData.start.x;
				var x1v = xAxis.decodeValue(captureData.start.x1);
				var x2v = xAxis.decodeValue(captureData.start.x2);

				if (this.constrainX) {
					if (dist > 0) dist = Math.min(xAxis.constrainValue(x2v + dist) - x2v, dist);
					else dist = Math.max(xAxis.constrainValue(x1v + dist) - x1v, dist);
				}

				instance.set("x1", xAxis.encodeValue(x1v + dist));
				instance.set("x2", xAxis.encodeValue(x2v + dist));
			}

			if (this.draggableY && yAxis) {
				var dist =
					yAxis.trackValue(cursor.clientY - svgBounds.left, this.yOffset, this.constrainY) - captureData.start.y;
				var y1v = yAxis.decodeValue(captureData.start.y1);
				var y2v = yAxis.decodeValue(captureData.start.y2);
				if (this.constrainY)
					dist = Math.max(
						yAxis.constrainValue(y1v + dist) - y1v,
						Math.min(yAxis.constrainValue(y2v + dist) - y2v, dist)
					);
				instance.set("y1", yAxis.encodeValue(y1v + dist));
				instance.set("y2", yAxis.encodeValue(y2v + dist));
			}
		};

		return Range;
	})(BoundedObject);
Range.prototype.invisible = false;
Range.prototype.xAxis = "x";
Range.prototype.yAxis = "y";
Range.prototype.xSize = 0;
Range.prototype.ySize = 0;
Range.prototype.xOffset = 0;
Range.prototype.yOffset = 0;
Range.prototype.anchors = "0 1 1 0";
Range.prototype.baseClass = "range";
Range.prototype.legend = "legend";
Range.prototype.legendAction = "auto";
BoundedObject.alias("range", Range);

var Gridlines =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(Gridlines, _BoundedObject);

		function Gridlines() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = Gridlines.prototype;

		_proto.explore = function explore(context, instance) {
			_BoundedObject.prototype.explore.call(this, context, instance);

			instance.xAxis = context.axes[this.xAxis];
			instance.yAxis = context.axes[this.yAxis];
		};

		_proto.prepare = function prepare(context, instance) {
			_BoundedObject.prototype.prepare.call(this, context, instance);

			var xAxis = instance.xAxis,
				yAxis = instance.yAxis;
			if ((xAxis && xAxis.shouldUpdate) || (yAxis && yAxis.shouldUpdate)) instance.markShouldUpdate(context);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis;
			var bounds = data.bounds;
			var path = "",
				xTicks,
				yTicks;

			if (xAxis) {
				xTicks = xAxis.mapGridlines();
				xTicks.forEach(function(x) {
					path += "M " + x + " " + bounds.t + " L " + x + " " + bounds.b;
				});
			}

			if (yAxis) {
				yTicks = yAxis.mapGridlines();
				yTicks.forEach(function(y) {
					path += "M " + bounds.l + " " + y + " L " + bounds.r + " " + y;
				});
			}

			return VDOM$2.createElement(
				"g",
				{
					key: key,
					className: data.classNames
				},
				VDOM$2.createElement("path", {
					style: data.style,
					d: path
				})
			);
		};

		return Gridlines;
	})(BoundedObject);
Gridlines.prototype.xAxis = "x";
Gridlines.prototype.yAxis = "y";
Gridlines.prototype.anchors = "0 1 1 0";
Gridlines.prototype.baseClass = "gridlines";
BoundedObject.alias("gridlines", Gridlines);

var LineGraph =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(LineGraph, _Widget);

		function LineGraph() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = LineGraph.prototype;

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						data: undefined,
						colorIndex: undefined,
						colorMap: undefined,
						class: {
							structured: true
						},
						className: {
							structured: true
						},
						lineStyle: {
							structured: true
						},
						areaStyle: {
							structured: true
						},
						area: undefined,
						line: undefined,
						y0: undefined,
						name: undefined,
						active: true,
						stack: undefined,
						stacked: undefined
					}
				])
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			if (data.name && !data.colorName) data.colorName = data.name;

			_Widget.prototype.prepareData.call(this, context, instance);
		};

		_proto.explore = function explore(context, instance) {
			var _this = this;

			var data = instance.data;
			instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
			if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

			if (data.active) {
				instance.axes = context.axes;
				instance.xAxis = instance.axes[this.xAxis];
				instance.yAxis = instance.axes[this.yAxis];

				_Widget.prototype.explore.call(this, context, instance);

				if (isArray(data.data)) {
					data.data.forEach(function(p, index) {
						var x = p[_this.xField];
						instance.xAxis.acknowledge(x);

						if (data.stacked) {
							instance.yAxis.stacknowledge(data.stack, x, _this.y0Field ? p[_this.y0Field] : data.y0);
							instance.yAxis.stacknowledge(data.stack, x, p[_this.yField]);
						} else {
							instance.yAxis.acknowledge(p[_this.yField]);

							if (data.area) {
								if (!_this.hiddenBase) instance.yAxis.acknowledge(_this.y0Field ? p[_this.y0Field] : data.y0);
								if (context.pointReducer && _this.y0Field)
									context.pointReducer(x, p[_this.y0Field], data.name, p, data, index);
							}
						}

						if (context.pointReducer) context.pointReducer(x, p[_this.yField], data.name, p, data, index);
					});
				}
			}
		};

		_proto.prepare = function prepare(context, instance) {
			var _this2 = this;

			var data = instance.data,
				colorMap = instance.colorMap;

			if (colorMap && data.colorName) {
				data.colorIndex = colorMap.map(data.colorName);
				if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
			}

			if (data.active) {
				if (instance.axes[this.xAxis].shouldUpdate || instance.axes[this.yAxis].shouldUpdate)
					instance.markShouldUpdate(context);
			}

			if (data.name && context.addLegendEntry)
				context.addLegendEntry(this.legend, {
					name: data.name,
					active: data.active,
					colorIndex: data.colorIndex,
					disabled: data.disabled,
					//selected: this.selection.isInstanceSelected(instance),
					style: data.style,
					shape: this.legendShape,
					onClick: function onClick(e) {
						_this2.onLegendClick(e, instance);
					}
				});
		};

		_proto.onLegendClick = function onLegendClick(e, instance) {
			var allActions = this.legendAction == "auto";
			var data = instance.data;
			if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
		};

		_proto.render = function render(context, instance, key) {
			var _this3 = this,
				_stateMods;

			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis;
			if (!data.active) return null;
			var spans = [];
			var span = [];
			isArray(data.data) &&
				data.data.forEach(function(p) {
					var ax = p[_this3.xField],
						ay = p[_this3.yField],
						ay0 = _this3.y0Field ? p[_this3.y0Field] : data.y0,
						x,
						y,
						y0;

					if (ax != null && ay != null && ay0 != null) {
						x = xAxis.map(ax);
						y0 = data.stacked ? yAxis.stack(data.stack, ax, ay0) : yAxis.map(ay0);
						y = data.stacked ? yAxis.stack(data.stack, ax, ay) : yAxis.map(ay);
					}

					if (x != null && y != null && y0 != null)
						span.push({
							x: x,
							y: y,
							y0: y0
						});
					else if (span.length > 0) {
						spans.push(span);
						span = [];
					}
				});
			if (span.length > 0) spans.push(span);
			var stateMods = ((_stateMods = {}),
			(_stateMods["color-" + data.colorIndex] = data.colorIndex != null),
			_stateMods);
			var line, area;

			if (data.line) {
				var linePath = "";
				spans.forEach(function(span) {
					span.forEach(function(p, i) {
						linePath += i == 0 ? " M " : " L ";
						linePath += p.x + " " + p.y;
					});
				});
				line = VDOM$2.createElement("path", {
					className: this.CSS.element(this.baseClass, "line", stateMods),
					style: this.CSS.parseStyle(data.lineStyle),
					d: linePath
				});
			}

			if (data.area) {
				var areaPath = "";
				spans.forEach(function(span) {
					var closePath = "";
					span.forEach(function(p, i) {
						areaPath += i == 0 ? " M " : " L ";
						areaPath += p.x + " " + p.y;
						if (data.area) closePath = "L " + p.x + " " + p.y0 + " " + closePath;
					});
					areaPath += closePath;
					areaPath += "L " + span[0].x + " " + span[0].y;
				});
				area = VDOM$2.createElement("path", {
					className: this.CSS.element(this.baseClass, "area", stateMods),
					style: this.CSS.parseStyle(data.areaStyle),
					d: areaPath
				});
			}

			return VDOM$2.createElement(
				"g",
				{
					key: key,
					className: data.classNames
				},
				line,
				area
			);
		};

		return LineGraph;
	})(Widget);
LineGraph.prototype.xAxis = "x";
LineGraph.prototype.yAxis = "y";
LineGraph.prototype.area = false;
LineGraph.prototype.line = true;
LineGraph.prototype.xField = "x";
LineGraph.prototype.yField = "y";
LineGraph.prototype.baseClass = "linegraph";
LineGraph.prototype.y0 = 0;
LineGraph.prototype.y0Field = false;
LineGraph.prototype.active = true;
LineGraph.prototype.legend = "legend";
LineGraph.prototype.legendAction = "auto";
LineGraph.prototype.legendShape = "rect";
LineGraph.prototype.stack = "stack";
LineGraph.prototype.hiddenBase = false;
Widget.alias("line-graph", LineGraph);

var ColumnBarGraphBase =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(ColumnBarGraphBase, _Widget);

		function ColumnBarGraphBase() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = ColumnBarGraphBase.prototype;

		_proto.init = function init() {
			this.selection = Selection.create(this.selection, {
				records: this.data
			});

			_Widget.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			var selection = this.selection.configureWidget(this);

			(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[this, selection].concat(Array.prototype.slice.call(arguments), [
					{
						data: undefined,
						colorIndex: undefined,
						colorMap: undefined,
						colorName: undefined,
						name: undefined,
						size: undefined,
						offset: undefined,
						y0: undefined,
						x0: undefined,
						autoSize: undefined,
						active: true,
						stacked: undefined,
						stack: undefined
					}
				])
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			if (data.name && !data.colorName) data.colorName = data.name;

			_Widget.prototype.prepareData.call(this, context, instance);
		};

		_proto.explore = function explore(context, instance) {
			instance.xAxis = context.axes[this.xAxis];
			instance.yAxis = context.axes[this.yAxis];
			var data = instance.data;
			instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
			if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

			_Widget.prototype.explore.call(this, context, instance);
		};

		_proto.prepare = function prepare(context, instance) {
			var _this = this;

			var data = instance.data,
				colorMap = instance.colorMap,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis;

			if (colorMap && data.name) {
				data.colorIndex = colorMap.map(data.colorName);
				if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
			}

			if (xAxis.shouldUpdate || yAxis.shouldUpdate) instance.markShouldUpdate(context);
			if (data.name && context.addLegendEntry)
				context.addLegendEntry(this.legend, {
					name: data.name,
					active: data.active,
					colorIndex: data.colorIndex,
					disabled: data.disabled,
					selected: this.selection.isInstanceSelected(instance),
					style: data.style,
					shape: this.legendShape,
					onClick: function onClick(e) {
						_this.onLegendClick(e, instance);
					}
				});
		};

		_proto.onLegendClick = function onLegendClick(e, instance) {
			var allActions = this.legendAction == "auto";
			var data = instance.data;
			if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			return VDOM$2.createElement(
				"g",
				{
					key: key,
					className: data.classNames
				},
				data.active && this.renderGraph(context, instance)
			);
		};

		_proto.handleClick = function handleClick(e, instance, point, index) {
			if (this.onClick && instance.invoke("onClick", e, instance, point, index) === false) return;
			if (!this.selection.isDummy) this.selection.select(instance.store, point, index, e.ctrlKey);
		};

		return ColumnBarGraphBase;
	})(Widget);
ColumnBarGraphBase.prototype.xAxis = "x";
ColumnBarGraphBase.prototype.yAxis = "y";
ColumnBarGraphBase.prototype.xField = "x";
ColumnBarGraphBase.prototype.yField = "y";
ColumnBarGraphBase.prototype.colorIndexField = false;
ColumnBarGraphBase.prototype.size = 1;
ColumnBarGraphBase.prototype.legend = "legend";
ColumnBarGraphBase.prototype.legendAction = "auto";
ColumnBarGraphBase.prototype.legendShape = "rect";
ColumnBarGraphBase.prototype.stack = "stack";
ColumnBarGraphBase.prototype.stacked = false;
ColumnBarGraphBase.prototype.autoSize = 0;
ColumnBarGraphBase.prototype.offset = 0;
ColumnBarGraphBase.prototype.styled = true;

var ColumnGraph =
	/*#__PURE__*/
	(function(_ColumnBarGraphBase) {
		_inheritsLoose(ColumnGraph, _ColumnBarGraphBase);

		function ColumnGraph() {
			return _ColumnBarGraphBase.apply(this, arguments) || this;
		}

		var _proto = ColumnGraph.prototype;

		_proto.explore = function explore(context, instance) {
			var _this = this;

			_ColumnBarGraphBase.prototype.explore.call(this, context, instance);

			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis;

			if (isArray(data.data)) {
				data.data.forEach(function(p, index) {
					var y0 = _this.y0Field ? p[_this.y0Field] : data.y0;
					var x = p[_this.xField];
					var y = p[_this.yField];
					xAxis.acknowledge(x, data.size, data.offset);
					if (data.autoSize) xAxis.book(x, data.stacked ? data.stack : data.name);

					if (data.stacked) {
						yAxis.stacknowledge(data.stack, x, y0);
						yAxis.stacknowledge(data.stack, x, y);
					} else {
						if (!_this.hiddenBase) yAxis.acknowledge(y0);
						yAxis.acknowledge(y);
					}

					if (context.pointReducer) context.pointReducer(x, y, data.name, p, data, index);
				});
			}
		};

		_proto.renderGraph = function renderGraph(context, instance) {
			var _this2 = this;

			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis,
				store = instance.store;
			if (!isArray(data.data)) return false;
			var isSelected = this.selection.getIsSelectedDelegate(store);
			return data.data.map(function(p, i) {
				var _state;

				var offset = data.offset,
					size = data.size;
				var y0 = _this2.y0Field ? p[_this2.y0Field] : data.y0;
				var x = p[_this2.xField];
				var y = p[_this2.yField];

				if (data.autoSize) {
					var _instance$xAxis$locat = instance.xAxis.locate(x, data.stacked ? data.stack : data.name),
						index = _instance$xAxis$locat[0],
						count = _instance$xAxis$locat[1];

					offset = size / count * (index - count / 2 + 0.5);
					size = size / count;
				}

				var x1 = xAxis.map(x, offset - size / 2);
				var x2 = xAxis.map(x, offset + size / 2);
				var y1 = data.stacked ? yAxis.stack(data.stack, x, y0) : yAxis.map(y0);
				var y2 = data.stacked ? yAxis.stack(data.stack, x, y) : yAxis.map(y);
				var color = _this2.colorIndexField ? p[_this2.colorIndexField] : data.colorIndex;
				var state = ((_state = {
					selected: isSelected(p, i),
					selectable: !_this2.selection.isDummy
				}),
				(_state["color-" + color] = color != null),
				_state);
				var mmove, mleave;

				if (_this2.tooltip) {
					mmove = function mmove(e) {
						return tooltipMouseMove(e, instance, _this2.tooltip, {
							target: e.target.parent,
							data: {
								$record: p
							}
						});
					};

					mleave = function mleave(e) {
						return tooltipMouseLeave(e, instance, _this2.tooltip, {
							target: e.target.parent,
							data: {
								$record: p
							}
						});
					};
				}

				return VDOM$2.createElement("rect", {
					key: i,
					className: _this2.CSS.element(_this2.baseClass, "column", state),
					onClick: function onClick(e) {
						_this2.handleClick(e, instance, p, i);
					},
					x: Math.min(x1, x2),
					y: Math.min(y1, y2),
					width: Math.abs(x2 - x1),
					height: Math.abs(y2 - y1),
					style: data.style,
					onMouseMove: mmove,
					onMouseLeave: mleave
				});
			});
		};

		return ColumnGraph;
	})(ColumnBarGraphBase);
ColumnGraph.prototype.baseClass = "columngraph";
ColumnGraph.prototype.y0Field = false;
ColumnGraph.prototype.y0 = 0;
ColumnGraph.prototype.legendShape = "column";
ColumnGraph.prototype.hiddenBase = false;
Widget.alias("columngraph", ColumnGraph);

var BarGraph =
	/*#__PURE__*/
	(function(_ColumnBarGraphBase) {
		_inheritsLoose(BarGraph, _ColumnBarGraphBase);

		function BarGraph() {
			return _ColumnBarGraphBase.apply(this, arguments) || this;
		}

		var _proto = BarGraph.prototype;

		_proto.explore = function explore(context, instance) {
			var _this = this;

			_ColumnBarGraphBase.prototype.explore.call(this, context, instance);

			var data = instance.data,
				yAxis = instance.yAxis,
				xAxis = instance.xAxis;

			if (isArray(data.data)) {
				data.data.forEach(function(p) {
					var x0 = _this.x0Field ? p[_this.x0Field] : data.x0;
					var y = p[_this.yField];
					var x = p[_this.xField];
					yAxis.acknowledge(y, data.size, data.offset);
					if (data.autoSize) yAxis.book(y, data.stacked ? data.stack : data.name);

					if (data.stacked) {
						xAxis.stacknowledge(data.stack, y, x0);
						xAxis.stacknowledge(data.stack, y, x);
					} else {
						if (!_this.hiddenBase) xAxis.acknowledge(x0);
						xAxis.acknowledge(x);
					}
				});
			}
		};

		_proto.renderGraph = function renderGraph(context, instance) {
			var _this2 = this;

			var data = instance.data,
				yAxis = instance.yAxis,
				xAxis = instance.xAxis,
				store = instance.store;
			if (!isArray(data.data)) return false;
			var isSelected = this.selection.getIsSelectedDelegate(store);
			return data.data.map(function(p, i) {
				var _state;

				var offset = data.offset,
					size = data.size;
				var x0 = _this2.x0Field ? p[_this2.x0Field] : data.x0;
				var y = p[_this2.yField];
				var x = p[_this2.xField];

				if (data.autoSize) {
					var _instance$yAxis$locat = instance.yAxis.locate(y, data.stacked ? data.stack : data.name),
						index = _instance$yAxis$locat[0],
						count = _instance$yAxis$locat[1];

					offset = size / count * (index - count / 2 + 0.5);
					size = size / count;
				}

				var y1 = yAxis.map(y, offset - size / 2);
				var y2 = yAxis.map(y, offset + size / 2);
				var x1 = data.stacked ? xAxis.stack(data.stack, y, x0) : xAxis.map(x0);
				var x2 = data.stacked ? xAxis.stack(data.stack, y, x) : xAxis.map(x);
				var color = _this2.colorIndexField ? p[_this2.colorIndexField] : data.colorIndex;
				var state = ((_state = {
					selected: isSelected(p, i),
					selectable: !_this2.selection.isDummy
				}),
				(_state["color-" + color] = color != null),
				_state);
				var mmove, mleave;

				if (_this2.tooltip) {
					mmove = function mmove(e) {
						return tooltipMouseMove(e, instance, _this2.tooltip, {
							target: e.target.parent,
							data: {
								$record: p
							}
						});
					};

					mleave = function mleave(e) {
						return tooltipMouseLeave(e, instance, _this2.tooltip, {
							target: e.target.parent,
							data: {
								$record: p
							}
						});
					};
				}

				return VDOM$2.createElement("rect", {
					key: i,
					className: _this2.CSS.element(_this2.baseClass, "bar", state),
					onClick: function onClick(e) {
						_this2.handleClick(e, instance, p, i);
					},
					x: Math.min(x1, x2),
					y: Math.min(y1, y2),
					width: Math.abs(x2 - x1),
					height: Math.abs(y2 - y1),
					style: data.style,
					onMouseMove: mmove,
					onMouseLeave: mleave
				});
			});
		};

		return BarGraph;
	})(ColumnBarGraphBase);
BarGraph.prototype.baseClass = "bargraph";
BarGraph.prototype.x0Field = false;
BarGraph.prototype.x0 = 0;
BarGraph.prototype.legendShape = "bar";
BarGraph.prototype.hiddenBase = false;
Widget.alias("bargraph", BarGraph);

var ScatterGraph =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(ScatterGraph, _Widget);

		function ScatterGraph() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = ScatterGraph.prototype;

		_proto.init = function init() {
			this.selection = Selection.create(this.selection, {
				records: this.data
			});

			_Widget.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			var selection = this.selection.configureWidget(this);

			(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						data: undefined,
						size: undefined,
						shape: undefined,
						colorIndex: undefined,
						colorMap: undefined,
						colorName: undefined,
						name: undefined,
						active: true
					},
					selection
				])
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			if (data.name && !data.colorName) data.colorName = data.name;

			_Widget.prototype.prepareData.call(this, context, instance);
		};

		_proto.explore = function explore(context, instance) {
			var _this = this;

			_Widget.prototype.explore.call(this, context, instance);

			var xAxis = (instance.xAxis = context.axes[this.xAxis]);
			var yAxis = (instance.yAxis = context.axes[this.yAxis]);
			var data = instance.data;
			instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
			if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

			if (data.active && isArray(data.data)) {
				data.data.forEach(function(p) {
					xAxis.acknowledge(p[_this.xField]);
					yAxis.acknowledge(p[_this.yField]);
				});
			}
		};

		_proto.prepare = function prepare(context, instance) {
			var _this2 = this;

			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis,
				colorMap = instance.colorMap;
			if (xAxis.shouldUpdate || yAxis.shouldUpdate) instance.markShouldUpdate(context);

			if (colorMap && data.name) {
				data.colorIndex = colorMap.map(data.colorName);
				if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
			}

			if (data.name && context.addLegendEntry)
				context.addLegendEntry(this.legend, {
					name: data.name,
					active: data.active,
					colorIndex: data.colorIndex,
					disabled: data.disabled,
					style: data.style,
					shape: data.shape,
					onClick: function onClick(e) {
						_this2.onLegendClick(e, instance);
					}
				});
		};

		_proto.onLegendClick = function onLegendClick(e, instance) {
			var allActions = this.legendAction == "auto";
			var data = instance.data;
			if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			return VDOM$2.createElement(
				"g",
				{
					key: key,
					className: data.classNames
				},
				this.renderData(context, instance)
			);
		};

		_proto.renderData = function renderData(context, instance) {
			var _this3 = this;

			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis,
				store = instance.store;
			if (!data.active) return null;
			var shape = getShape(data.shape);
			var isSelected = this.selection.getIsSelectedDelegate(store);
			return (
				isArray(data.data) &&
				data.data.map(function(p, i) {
					var _CSS$element;

					var classes = CSS.element(
						_this3.baseClass,
						"shape",
						((_CSS$element = {
							selected: isSelected(p, i),
							selectable: !_this3.selection.isDummy
						}),
						(_CSS$element["color-" + data.colorIndex] = data.colorIndex != null),
						_CSS$element)
					);
					var cx = xAxis.map(p[_this3.xField]),
						cy = yAxis.map(p[_this3.yField]),
						size = _this3.sizeField ? p[_this3.sizeField] : data.size;
					return shape(cx, cy, size, {
						key: i,
						className: classes,
						style: p.style || data.style,
						onClick: function onClick(e) {
							_this3.handleItemClick(e, instance, i);
						}
					});
				})
			);
		};

		_proto.handleItemClick = function handleItemClick(e, _ref, index) {
			var data = _ref.data,
				store = _ref.store;
			var bubble = data.data[index];
			this.selection.select(store, bubble, index, {
				toggle: e.ctrlKey
			});
		};

		return ScatterGraph;
	})(Widget);
ScatterGraph.prototype.baseClass = "scattergraph";
ScatterGraph.prototype.xAxis = "x";
ScatterGraph.prototype.yAxis = "y";
ScatterGraph.prototype.xField = "x";
ScatterGraph.prototype.yField = "y";
ScatterGraph.prototype.sizeField = false;
ScatterGraph.prototype.shape = "circle";
ScatterGraph.prototype.size = 10;
ScatterGraph.prototype.legend = "legend";
ScatterGraph.prototype.legendAction = "auto";
ScatterGraph.prototype.styled = true;
Widget.alias("scatter-graph", ScatterGraph);

var BubbleGraph =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(BubbleGraph, _Widget);

		function BubbleGraph() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = BubbleGraph.prototype;

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			var selection = this.selection.configureWidget(this);

			(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						data: undefined,
						bubbleRadius: undefined,
						bubbleStyle: {
							structured: true
						}
					},
					selection
				])
			);
		};

		_proto.init = function init() {
			this.selection = Selection.create(this.selection, {
				records: this.data
			});

			_Widget.prototype.init.call(this);
		};

		_proto.explore = function explore(context, instance) {
			var _this = this;

			instance.axes = context.axes;

			_Widget.prototype.explore.call(this, context, instance);

			var data = instance.data;

			if (isArray(data.data)) {
				data.data.forEach(function(p) {
					instance.axes[_this.xAxis].acknowledge(p[_this.xField]);

					instance.axes[_this.yAxis].acknowledge(p[_this.yField]);
				});
			}
		};

		_proto.prepare = function prepare(context, instance) {
			_Widget.prototype.prepare.call(this, context, instance);

			if (instance.axes[this.xAxis].shouldUpdate || instance.axes[this.yAxis].shouldUpdate)
				instance.markShouldUpdate(context);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			return VDOM$2.createElement(
				"g",
				{
					key: key,
					className: data.classNames
				},
				this.renderData(context, instance)
			);
		};

		_proto.renderData = function renderData(context, instance) {
			var _this2 = this;

			var data = instance.data,
				axes = instance.axes,
				store = instance.store;
			var xAxis = axes[this.xAxis];
			var yAxis = axes[this.yAxis];
			return (
				isArray(data.data) &&
				data.data.map(function(p, i) {
					var selected = _this2.selection && _this2.selection.isSelected(store, p, i);

					var classes = CSS.element(_this2.baseClass, "bubble", {
						selected: selected
					});
					return VDOM$2.createElement("circle", {
						key: i,
						className: classes,
						cx: xAxis.map(p[_this2.xField]),
						cy: yAxis.map(p[_this2.yField]),
						r: p[_this2.rField] || data.bubbleRadius,
						style: p.style || data.bubbleStyle,
						onClick: function onClick(e) {
							_this2.onBubbleClick(e, instance, i);
						}
					});
				})
			);
		};

		_proto.onBubbleClick = function onBubbleClick(e, _ref, index) {
			var data = _ref.data,
				store = _ref.store;
			var bubble = data.data[index];
			this.selection.select(store, bubble, index, {
				toggle: e.ctrlKey
			});
		};

		return BubbleGraph;
	})(Widget);
BubbleGraph.prototype.baseClass = "bubblegraph";
BubbleGraph.prototype.xAxis = "x";
BubbleGraph.prototype.yAxis = "y";
BubbleGraph.prototype.xField = "x";
BubbleGraph.prototype.yField = "y";
BubbleGraph.prototype.rField = "r";
BubbleGraph.prototype.bubbleRadius = 10;
Widget.alias("bubble-graph", BubbleGraph);

var MouseTracker =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(MouseTracker, _BoundedObject);

		function MouseTracker() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = MouseTracker.prototype;

		_proto.declareData = function declareData() {
			var _BoundedObject$protot;

			return (_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
				_BoundedObject$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						x: undefined,
						y: undefined
					}
				])
			);
		};

		_proto.explore = function explore(context, instance) {
			instance.xAxis = context.axes[this.xAxis];
			instance.yAxis = context.axes[this.yAxis];

			_BoundedObject.prototype.explore.call(this, context, instance);
		};

		_proto.render = function render(context, instance, key) {
			var _this = this;

			var data = instance.data;
			var bounds = data.bounds;
			if (!bounds.valid()) return null;
			return VDOM$1.createElement(
				"g",
				{
					key: key,
					className: data.classNames,
					onMouseMove: function onMouseMove(e) {
						_this.handleMouseMove(e, instance);
					},
					onMouseLeave: function onMouseLeave(e) {
						_this.handleMouseLeave(e, instance);
					}
				},
				VDOM$1.createElement("rect", {
					x: bounds.l,
					y: bounds.t,
					width: bounds.width(),
					height: bounds.height(),
					fill: "transparent",
					strokeWidth: "0"
				}),
				this.renderChildren(context, instance)
			);
		};

		_proto.handleMouseMove = function handleMouseMove(e, instance) {
			var xAxis = instance.xAxis,
				yAxis = instance.yAxis;
			var svgEl = closest(e.target, function(el) {
				return el.tagName == "svg";
			});
			var bounds = getTopLevelBoundingClientRect(svgEl);
			if (xAxis) instance.set("x", xAxis.trackValue(e.clientX - bounds.left));
			if (yAxis) instance.set("y", yAxis.trackValue(e.clientY - bounds.top));
			tooltipMouseMove(e, instance, instance.widget.tooltip);
		};

		_proto.handleMouseLeave = function handleMouseLeave(e, instance) {
			var xAxis = instance.xAxis,
				yAxis = instance.yAxis;
			tooltipMouseLeave(e, instance, instance.widget.tooltip);
			if (xAxis) instance.set("x", null);
			if (yAxis) instance.set("y", null);
		};

		return MouseTracker;
	})(BoundedObject);
MouseTracker.prototype.xAxis = "x";
MouseTracker.prototype.yAxis = "y";
MouseTracker.prototype.anchors = "0 1 1 0";
MouseTracker.prototype.baseClass = "mousetracker";

var Stack =
	/*#__PURE__*/
	(function() {
		function Stack() {
			this.reset();
		}

		var _proto = Stack.prototype;

		_proto.reset = function reset() {
			this.totals = {};
			this.values = {};
			this.normalized = false;
			this.invalid = {};
		};

		_proto.acknowledge = function acknowledge(ordinal, value) {
			if (value != null) {
				var v = this.totals[ordinal] || 0;
				this.totals[ordinal] = v + value;
			} else {
				this.invalid[ordinal] = true;
			}
		};

		_proto.measure = function measure(normalized) {
			if (normalized) {
				this.normalized = true;
				return [0, 1];
			}

			var max = 0,
				min = 0;

			for (var key in this.totals) {
				if (this.totals[key] > max) max = this.totals[key];
				if (this.totals[key] < min) min = this.totals[key];
			}

			return [min, max];
		};

		_proto.stack = function stack(ordinal, value) {
			if (value == null || this.invalid[ordinal]) return null;
			var base = this.values[ordinal] || 0;
			var result = (this.values[ordinal] = base + value);
			if (!this.normalized) return result;
			var total = this.totals[ordinal];
			if (total > 0) return result / total;
			return null;
		};

		return Stack;
	})();

var NumericAxis =
	/*#__PURE__*/
	(function(_Axis) {
		_inheritsLoose(NumericAxis, _Axis);

		function NumericAxis() {
			return _Axis.apply(this, arguments) || this;
		}

		var _proto = NumericAxis.prototype;

		_proto.init = function init() {
			if (this.deadZone) {
				this.lowerDeadZone = this.deadZone;
				this.upperDeadZone = this.deadZone;
			}

			_Axis.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Axis$prototype$decla;

			(_Axis$prototype$decla = _Axis.prototype.declareData).call.apply(
				_Axis$prototype$decla,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						min: undefined,
						max: undefined,
						normalized: undefined,
						inverted: undefined,
						labelDivisor: undefined,
						format: undefined,
						lowerDeadZone: undefined,
						upperDeadZone: undefined
					}
				])
			);
		};

		_proto.initInstance = function initInstance(context, instance) {
			instance.calculator = new NumericScale();
		};

		_proto.explore = function explore(context, instance) {
			_Axis.prototype.explore.call(this, context, instance);

			var _instance$data = instance.data,
				min = _instance$data.min,
				max = _instance$data.max,
				normalized = _instance$data.normalized,
				inverted = _instance$data.inverted,
				lowerDeadZone = _instance$data.lowerDeadZone,
				upperDeadZone = _instance$data.upperDeadZone;
			instance.calculator.reset(
				min,
				max,
				this.snapToTicks,
				this.tickDivisions,
				this.minTickDistance,
				this.minLabelDistance,
				normalized,
				inverted,
				lowerDeadZone,
				upperDeadZone
			);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			if (!data.bounds.valid()) return null;
			var baseFormatter = Format.parse(data.format);
			var formatter =
				data.labelDivisor != 1
					? function(v) {
							return baseFormatter(v / data.labelDivisor);
						}
					: baseFormatter;
			return VDOM$2.createElement(
				"g",
				{
					key: key,
					className: data.classNames,
					style: data.style
				},
				this.renderTicksAndLabels(context, instance, formatter)
			);
		};

		NumericAxis.XY = function XY() {
			return {
				x: {
					type: NumericAxis
				},
				y: {
					type: NumericAxis,
					vertical: true
				}
			};
		};

		return NumericAxis;
	})(Axis);
NumericAxis.prototype.baseClass = "numericaxis";
NumericAxis.prototype.tickDivisions = [
	[1, 2, 10],
	[1, 5, 10],
	[2.5, 5, 10], //[2, 4, 10],
	[5, 10]
];
NumericAxis.prototype.snapToTicks = 1;
NumericAxis.prototype.normalized = false;
NumericAxis.prototype.format = "n";
NumericAxis.prototype.labelDivisor = 1;
Axis.alias("numeric", NumericAxis);

var NumericScale =
	/*#__PURE__*/
	(function() {
		function NumericScale() {}

		var _proto2 = NumericScale.prototype;

		_proto2.reset = function reset(
			min,
			max,
			snapToTicks,
			tickDivisions,
			minTickDistance,
			minLabelDistance,
			normalized,
			inverted,
			lowerDeadZone,
			upperDeadZone
		) {
			this.padding = 0;
			this.min = min;
			this.max = max;
			this.snapToTicks = snapToTicks;
			this.tickDivisions = tickDivisions;
			this.minLabelDistance = minLabelDistance;
			this.minTickDistance = minTickDistance;
			this.tickSizes = [];
			this.normalized = normalized;
			this.inverted = inverted;
			delete this.minValue;
			delete this.maxValue;
			this.stacks = {};
			this.lowerDeadZone = lowerDeadZone || 0;
			this.upperDeadZone = upperDeadZone || 0;
		};

		_proto2.map = function map(v, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			return this.origin + (v + offset - this.scale.min + this.padding) * this.scale.factor;
		};

		_proto2.decodeValue = function decodeValue(n) {
			return n;
		};

		_proto2.encodeValue = function encodeValue(v) {
			return v;
		};

		_proto2.constrainValue = function constrainValue(v) {
			return Math.max(this.scale.min, Math.min(this.scale.max, v));
		};

		_proto2.trackValue = function trackValue(v, offset, constrain) {
			if (offset === void 0) {
				offset = 0;
			}

			if (constrain === void 0) {
				constrain = false;
			}

			var value = (v - this.origin) / this.scale.factor - offset + this.scale.min - this.padding;
			if (constrain) value = this.constrainValue(v);
			return value;
		};

		_proto2.hash = function hash() {
			var _this = this;

			var r = {
				origin: this.origin,
				factor: this.scale.factor,
				min: this.scale.min,
				max: this.scale.max,
				padding: this.padding
			};
			r.stacks = Object.keys(this.stacks)
				.map(function(s) {
					return _this.stacks[s].info.join(",");
				})
				.join(":");
			return r;
		};

		_proto2.isSame = function isSame(x) {
			var hash = this.hash();
			var same =
				x &&
				!Object.keys(hash).some(function(k) {
					return x[k] !== hash[k];
				});
			this.shouldUpdate = !same;
			return same;
		};

		_proto2.measure = function measure(a, b) {
			this.a = a;
			this.b = b;

			for (var s in this.stacks) {
				var info = this.stacks[s].measure(this.normalized);
				var min = info[0],
					max = info[1],
					invalid = info[2];
				if (this.min == null || min < this.min) this.min = min;
				if (this.max == null || max > this.max) this.max = max;
				this.stacks[s].info = info;
			}

			if (this.minValue != null && this.min == null)
				// || this.minValue < this.min))
				this.min = this.minValue;
			if (this.min == null) this.min = 0;
			if (this.maxValue != null && this.max == null)
				// || this.maxValue > this.max))
				this.max = this.maxValue;
			if (this.max == null) this.max = this.normalized ? 1 : 100;

			if (this.min == this.max) {
				if (this.min == 0) {
					this.min = -1;
					this.max = 1;
				} else {
					var delta = Math.abs(this.min) * 0.1;
					this.min -= delta;
					this.max += delta;
				}
			}

			this.origin = this.inverted ? this.b : this.a;
			this.scale = this.getScale();
			this.calculateTicks();
		};

		_proto2.getScale = function getScale(tickSizes) {
			var min = this.min,
				max = this.max;
			var smin = min;
			var smax = max;
			var tickSize;

			if (tickSizes && 0 <= this.snapToTicks && tickSizes.length > 0) {
				tickSize = tickSizes[Math.min(tickSizes.length - 1, this.snapToTicks)];
				smin = Math.floor(smin / tickSize) * tickSize;
				smax = Math.ceil(smax / tickSize) * tickSize;
			}

			var sign = this.b > this.a ? 1 : -1;
			var factor =
				smin < smax
					? (Math.abs(this.b - this.a) - this.lowerDeadZone - this.upperDeadZone) / (smax - smin + 2 * this.padding)
					: 0;
			if (factor < 0) factor = 0;

			if (factor > 0 && (this.lowerDeadZone > 0 || this.upperDeadZone > 0)) {
				while (factor * (min - smin) < this.lowerDeadZone) {
					smin -= this.lowerDeadZone / factor;
				}

				while (factor * (smax - max) < this.upperDeadZone) {
					smax += this.upperDeadZone / factor;
				}

				if (tickSize > 0) {
					smin = Math.floor(smin / tickSize) * tickSize;
					smax = Math.ceil(smax / tickSize) * tickSize;
				}

				factor = smin < smax ? Math.abs(this.b - this.a) / (smax - smin + 2 * this.padding) : 0;
			}

			return {
				factor: sign * (this.inverted ? -factor : factor),
				min: smin,
				max: smax
			};
		};

		_proto2.acknowledge = function acknowledge(value, width, offset) {
			if (width === void 0) {
				width = 0;
			}

			if (offset === void 0) {
				offset = 0;
			}

			if (value == null) return;

			if (this.minValue == null || value < this.minValue) {
				this.minValue = value;
				this.padding = Math.max(this.padding, Math.abs(offset - width / 2));
			}

			if (this.maxValue == null || value > this.maxValue) {
				this.maxValue = value;
				this.padding = Math.max(this.padding, Math.abs(offset + width / 2));
			}
		};

		_proto2.getStack = function getStack(name) {
			var s = this.stacks[name];
			if (!s) s = this.stacks[name] = new Stack();
			return s;
		};

		_proto2.stacknowledge = function stacknowledge(name, ordinal, value) {
			return this.getStack(name).acknowledge(ordinal, value);
		};

		_proto2.stack = function stack(name, ordinal, value) {
			var v = this.getStack(name).stack(ordinal, value);
			return v != null ? this.map(v) : null;
		};

		_proto2.findTickSize = function findTickSize(minPxDist) {
			var _this2 = this;

			return this.tickSizes.find(function(a) {
				return a * Math.abs(_this2.scale.factor) >= minPxDist;
			});
		};

		_proto2.getTickSizes = function getTickSizes() {
			return this.tickSizes;
		};

		_proto2.calculateTicks = function calculateTicks() {
			var _this3 = this;

			var dist = this.minLabelDistance / Math.abs(this.scale.factor);
			var unit = Math.pow(10, Math.floor(Math.log10(dist)));
			var bestLevel = 100;
			var bestTicks = [];
			var bestScale = this.scale;

			var _loop = function _loop(i) {
				var divs = _this3.tickDivisions[i];
				var tickSizes = divs.map(function(s) {
					return s * unit;
				});

				var scale = _this3.getScale(tickSizes);

				tickSizes.forEach(function(size, level) {
					if (size * Math.abs(scale.factor) >= _this3.minTickDistance && level < bestLevel) {
						bestScale = scale;
						bestTicks = tickSizes;
						bestLevel = level;
					}
				});
			};

			for (var i = 0; i < this.tickDivisions.length && bestLevel > 0; i++) {
				_loop(i);
			}

			this.scale = bestScale;
			this.tickSizes = bestTicks.filter(function(ts) {
				return ts * Math.abs(bestScale.factor) >= _this3.minTickDistance;
			});

			if (this.tickSizes.length > 0) {
				var max = this.tickSizes[this.tickSizes.length - 1];
				this.tickSizes.push(2 * max);
				this.tickSizes.push(5 * max);
				this.tickSizes.push(10 * max);
			}
		};

		_proto2.getTicks = function getTicks(tickSizes) {
			var _this4 = this;

			return tickSizes.map(function(size) {
				var start = Math.ceil(_this4.scale.min / size);
				var end = Math.floor(_this4.scale.max / size);
				var result = [];

				for (var i = start; i <= end; i++) {
					result.push(i * size);
				}

				return result;
			});
		};

		_proto2.mapGridlines = function mapGridlines() {
			var size = this.tickSizes[0];
			var start = Math.ceil(this.scale.min / size);
			var end = Math.floor(this.scale.max / size);
			var result = [];

			for (var i = start; i <= end; i++) {
				result.push(this.map(i * size));
			}

			return result;
		};

		return NumericScale;
	})();

var CategoryAxis =
	/*#__PURE__*/
	(function(_Axis) {
		_inheritsLoose(CategoryAxis, _Axis);

		function CategoryAxis() {
			return _Axis.apply(this, arguments) || this;
		}

		var _proto = CategoryAxis.prototype;

		_proto.declareData = function declareData() {
			var _Axis$prototype$decla;

			(_Axis$prototype$decla = _Axis.prototype.declareData).call.apply(
				_Axis$prototype$decla,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						inverted: undefined,
						uniform: undefined,
						names: undefined,
						values: undefined,
						minSize: undefined
					}
				])
			);
		};

		_proto.initInstance = function initInstance(context, instance) {
			instance.calculator = new CategoryScale();
		};

		_proto.explore = function explore(context, instance) {
			_Axis.prototype.explore.call(this, context, instance);

			var _instance$data = instance.data,
				values = _instance$data.values,
				names = _instance$data.names,
				inverted = _instance$data.inverted,
				uniform = _instance$data.uniform,
				minSize = _instance$data.minSize;
			instance.calculator.reset(inverted, uniform, values, names, minSize);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data,
				calculator = instance.calculator;
			if (!data.bounds.valid()) return null;

			var formatter = function formatter(v) {
				return calculator.names[v] || v;
			};

			return VDOM$2.createElement(
				"g",
				{
					key: key,
					className: data.classNames,
					style: data.style
				},
				this.renderTicksAndLabels(context, instance, formatter)
			);
		};

		return CategoryAxis;
	})(Axis);
CategoryAxis.prototype.baseClass = "categoryaxis";
CategoryAxis.prototype.anchors = "0 1 1 0";
CategoryAxis.prototype.vertical = false;
CategoryAxis.prototype.inverted = false;
CategoryAxis.prototype.uniform = false;
CategoryAxis.prototype.labelOffset = 10;
CategoryAxis.prototype.labelRotation = 0;
CategoryAxis.prototype.labelAnchor = "auto";
CategoryAxis.prototype.labelDx = "auto";
CategoryAxis.prototype.labelDy = "auto";
CategoryAxis.prototype.minSize = 1;
Axis.alias("category", CategoryAxis);

var CategoryScale =
	/*#__PURE__*/
	(function() {
		function CategoryScale() {}

		var _proto2 = CategoryScale.prototype;

		_proto2.reset = function reset(inverted, uniform, values, names, minSize) {
			var _this = this;

			this.padding = 0.5;
			delete this.min;
			delete this.max;
			delete this.minValue;
			delete this.maxValue;
			this.minSize = minSize;
			this.valuesMap = {};
			this.valueList = [];
			this.inverted = inverted;
			this.uniform = uniform;
			this.valueStacks = {};
			this.names = {};

			if (values) {
				if (isArray(values))
					values.forEach(function(v) {
						return _this.acknowledge(v);
					});
				else if (typeof values == "object")
					for (var k in values) {
						this.acknowledge(k);
						this.names[k] = values[k];
					}
			}

			if (names) {
				if (isArray(names)) {
					values = values || [];
					names.forEach(function(name, index) {
						var value = values[index];
						_this.names[value != null ? value : index] = name;
					});
				} else this.names = names;
			}
		};

		_proto2.decodeValue = function decodeValue(n) {
			return n;
		};

		_proto2.encodeValue = function encodeValue(v) {
			return v;
		};

		_proto2.map = function map(v, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			var index = this.valuesMap[v] || 0;
			return this.origin + (index + offset - this.min + this.padding) * this.factor;
		};

		_proto2.measure = function measure(a, b) {
			this.a = a;
			this.b = b;
			if (this.min == null) this.min = this.minValue || 0;
			if (this.max == null) this.max = !isNaN(this.maxValue) ? this.maxValue : 100;
			var sign = this.inverted ? -1 : 1;

			if (this.max - this.min + 1 < this.minSize) {
				this.factor = sign * (this.b - this.a) / this.minSize;
				this.origin = (this.b + this.a) * 0.5 - this.factor * (this.max - this.min + 1) / 2;
			} else {
				this.factor = sign * (this.b - this.a) / (this.max - this.min + 2 * this.padding);
				this.origin = this.a * (1 + sign) / 2 + this.b * (1 - sign) / 2; //a || b
			}
		};

		_proto2.hash = function hash() {
			return {
				origin: this.origin,
				factor: this.factor,
				min: this.min,
				minSize: this.minSize,
				padding: this.padding,
				values: this.valueList.join(":"),
				names: JSON.stringify(this.names)
			};
		};

		_proto2.isSame = function isSame(x) {
			var h = this.hash();
			var same =
				x &&
				!Object.keys(h).some(function(k) {
					return x[k] !== h[k];
				});
			this.shouldUpdate = !same;
			return same;
		};

		_proto2.acknowledge = function acknowledge(value, width, offset) {
			if (width === void 0) {
				width = 0;
			}

			if (offset === void 0) {
				offset = 0;
			}

			var index = this.valuesMap[value];

			if (isUndefined(index)) {
				index = this.valueList.length;
				this.valueList.push(value);
				this.valuesMap[value] = index;
			}

			if (this.minValue == null || index < this.minValue) {
				this.minValue = index;
				this.padding = Math.max(this.padding, Math.abs(offset - width / 2));
			}

			if (this.maxValue == null || index > this.maxValue) {
				this.maxValue = index;
				this.padding = Math.max(this.padding, Math.abs(offset + width / 2));
			}
		};

		_proto2.book = function book(value, name) {
			if (this.uniform) value = 0;
			var stack = this.valueStacks[value];
			if (!stack)
				stack = this.valueStacks[value] = {
					index: {},
					count: 0
				};
			if (!stack.index.hasOwnProperty(name)) stack.index[name] = stack.count++;
		};

		_proto2.locate = function locate(value, name) {
			if (this.uniform) value = 0;
			var stack = this.valueStacks[value];
			if (!stack) return [0, 1];
			return [stack.index[name], stack.count];
		};

		_proto2.trackValue = function trackValue(v, offset, constrain) {
			if (offset === void 0) {
				offset = 0;
			}

			if (constrain === void 0) {
				constrain = false;
			}

			var index = Math.round((v - this.origin) / this.factor - offset + this.min - this.padding);
			if (index < this.min) index = this.min;
			if (index > this.max) index = this.max;
			return this.valueList[index];
		};

		_proto2.findTickSize = function findTickSize(minPxDist) {
			return 1;
		};

		_proto2.getTickSizes = function getTickSizes() {
			return [1];
		};

		_proto2.getTicks = function getTicks(tickSizes) {
			var _this2 = this;

			return tickSizes.map(function(size) {
				return _this2.valueList;
			});
		};

		_proto2.mapGridlines = function mapGridlines() {
			var _this3 = this;

			return Array.from({
				length: this.valueList.length + 1
			}).map(function(_, index) {
				return _this3.origin + (index - 0.5 - _this3.min + _this3.padding) * _this3.factor;
			});
		};

		return CategoryScale;
	})();

var contents = {};
var localizations = {};
var overrides = {};
var defaults = {};
var _trackDefaults = false;
var Localization =
	/*#__PURE__*/
	(function() {
		function Localization() {}

		Localization.register = function register(key) {
			var _this = this;

			return function(type) {
				_this.registerPrototype(key, type);

				return type;
			};
		};

		Localization.registerPrototype = function registerPrototype(key, type) {
			contents[key] = type.prototype;
			if (overrides[key]) this.override(key, overrides[key]);
		};

		Localization.trackDefaults = function trackDefaults() {
			_trackDefaults = true;
		};

		Localization.restoreDefaults = function restoreDefaults() {
			for (var type in defaults) {
				var proto = contents[type];
				if (!proto) continue;
				var d = defaults[type];

				for (var key in d) {
					proto[key] = d[key];
				}
			}

			defaults = {};
		};

		Localization.override = function override(key, values) {
			overrides[key] = values;
			var p = contents[key];

			if (p) {
				if (_trackDefaults && !defaults[key]) {
					var d = (defaults[key] = {});

					for (var _key in values) {
						d[_key] = p[_key];
					}
				}

				Object.assign(p, values);
			}
		};

		Localization.localize = function localize(culture, key, values) {
			var l = localizations[culture];
			if (!l) l = localizations[culture] = {};
			l[key] = _objectSpread({}, l[key], values);
		};

		Localization.setCulture = function setCulture(culture) {
			var l = localizations[culture];

			if (l) {
				for (var key in l) {
					var content = contents[key];
					if (content) Object.assign(content, l[key]);
				}
			}
		};

		return Localization;
	})();

var culture = "en";
var cultureCache = {};
var defaultCurrency = "USD";

var dateEncoding = function dateEncoding(date) {
	return date.toISOString();
};

var Culture =
	/*#__PURE__*/
	(function() {
		function Culture() {}

		Culture.setCulture = function setCulture(cultureCode) {
			culture = cultureCode;
			cultureCache = {};
			Localization.setCulture(cultureCode);
			this.invalidateCache();
		};

		Culture.setDefaultCurrency = function setDefaultCurrency(currencyCode) {
			defaultCurrency = currencyCode;
			this.invalidateCache();
		};

		Culture.invalidateCache = function invalidateCache() {
			GlobalCacheIdentifier.change();
			invalidateExpressionCache();
			invalidateStringTemplateCache();
		};

		Culture.getNumberCulture = function getNumberCulture() {
			if (!cultureCache.numberCulture) cultureCache.numberCulture = new NumberCulture(culture);
			return cultureCache.numberCulture;
		};

		Culture.getDateTimeCulture = function getDateTimeCulture() {
			if (!cultureCache.dateCulture) cultureCache.dateCulture = new DateTimeCulture(culture);
			return cultureCache.dateCulture;
		};

		Culture.getDefaultDateEncoding = function getDefaultDateEncoding() {
			return dateEncoding;
		};

		Culture.setDefaultDateEncoding = function setDefaultDateEncoding(encoding) {
			dateEncoding = encoding;
		};

		_createClass(Culture, null, [
			{
				key: "defaultCurrency",
				get: function get() {
					return defaultCurrency;
				}
			},
			{
				key: "culture",
				get: function get() {
					return culture;
				}
			}
		]);

		return Culture;
	})();

var Format$1 = Format;

Format$1.registerFactory("yearOrMonth", function(format) {
	var year = Format$1.parse("datetime;yyyy");
	var month = Format$1.parse("datetime;MMM");
	return function(date) {
		var d = new Date(date);
		if (d.getMonth() == 0) return year(d);
		else return month(d);
	};
});
Format$1.registerFactory("monthOrDay", function(format) {
	var month = Format$1.parse("datetime;MMM");
	var day = Format$1.parse("datetime;dd");
	return function(date) {
		var d = new Date(date);
		if (d.getDate() == 1) return month(d);
		else return day(d);
	};
});
var TimeAxis =
	/*#__PURE__*/
	(function(_Axis) {
		_inheritsLoose(TimeAxis, _Axis);

		function TimeAxis() {
			return _Axis.apply(this, arguments) || this;
		}

		var _proto = TimeAxis.prototype;

		_proto.init = function init() {
			if (this.labelAnchor == "auto") this.labelAnchor = this.vertical ? (this.secondary ? "start" : "end") : "start";
			if (this.labelDx == "auto") this.labelDx = this.vertical ? 0 : "5px";

			_Axis.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Axis$prototype$decla;

			(_Axis$prototype$decla = _Axis.prototype.declareData).call.apply(
				_Axis$prototype$decla,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						anchors: undefined,
						min: undefined,
						max: undefined,
						inverted: undefined
					}
				])
			);
		};

		_proto.initInstance = function initInstance(context, instance) {
			instance.calculator = new TimeScale();
		};

		_proto.explore = function explore(context, instance) {
			_Axis.prototype.explore.call(this, context, instance);

			var _instance$data = instance.data,
				min = _instance$data.min,
				max = _instance$data.max,
				normalized = _instance$data.normalized,
				inverted = _instance$data.inverted;
			instance.calculator.reset(
				min,
				max,
				this.snapToTicks,
				this.tickDivisions,
				this.minTickDistance,
				this.minLabelDistance,
				normalized,
				inverted,
				this.minTickUnit
			);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data,
				cached = instance.cached,
				calculator = instance.calculator;
			cached.axis = calculator.hash();
			if (!data.bounds.valid()) return null;
			var format = this.format || calculator.getFormat();
			var formatter = Format$1.parse(format);
			return VDOM$2.createElement(
				"g",
				{
					key: key,
					className: data.classNames,
					style: data.style
				},
				this.renderTicksAndLabels(context, instance, formatter)
			);
		};

		return TimeAxis;
	})(Axis);
Axis.alias("time", TimeAxis);
TimeAxis.prototype.baseClass = "timeaxis";
TimeAxis.prototype.tickDivisions = {
	second: [[1, 5, 15, 30]],
	minute: [[1, 5, 15, 30]],
	hour: [[1, 2, 4, 8], [1, 3, 6, 12]],
	day: [[1]],
	week: [[1]],
	month: [[1, 3, 6]],
	year: [[1, 2, 10], [1, 5, 10], [5, 10, 50], [10, 50, 100]]
};
TimeAxis.prototype.snapToTicks = 0;
TimeAxis.prototype.tickSize = 15;
TimeAxis.prototype.minLabelDistance = 60;
TimeAxis.prototype.minTickDistance = 60;
TimeAxis.prototype.minTickUnit = "second";

function monthNumber(date) {
	return date.getFullYear() * 12 + date.getMonth() + (date.getDate() - 1) / 31;
}

function yearNumber(date) {
	return monthNumber(date) / 12;
}

var miliSeconds = {
	second: 1000,
	minute: 60 * 1000,
	hour: 3600 * 1000,
	day: 3600 * 24 * 1000,
	week: 3600 * 24 * 7 * 1000,
	month: 3600 * 24 * 30 * 1000,
	year: 3600 * 24 * 365 * 1000
};

var TimeScale =
	/*#__PURE__*/
	(function() {
		function TimeScale() {}

		var _proto2 = TimeScale.prototype;

		_proto2.reset = function reset(
			min,
			max,
			snapToTicks,
			tickDivisions,
			minTickDistance,
			minLabelDistance,
			normalized,
			inverted,
			minTickUnit
		) {
			this.dateCache = {};
			this.min = min != null ? this.decodeValue(min) : null;
			this.max = max != null ? this.decodeValue(max) : null;
			this.snapToTicks = snapToTicks;
			this.tickDivisions = tickDivisions;
			this.minLabelDistance = minLabelDistance;
			this.minTickDistance = minTickDistance;
			this.tickSizes = [];
			this.normalized = normalized;
			this.minTickUnit = minTickUnit;
			this.inverted = inverted;
			delete this.minValue;
			delete this.maxValue;
			delete this.minValuePad;
			delete this.maxValuePad;
			this.stacks = {};
		};

		_proto2.decodeValue = function decodeValue(date) {
			if (date instanceof Date) return date.getTime();

			switch (typeof date) {
				case "string":
					var v = this.dateCache[date];
					if (!v) v = this.dateCache[date] = Date.parse(date);
					return v;

				case "number":
					return date;
			}
		};

		_proto2.encodeValue = function encodeValue(v) {
			return new Date(v).toISOString();
		};

		_proto2.getFormat = function getFormat() {
			switch (this.tickMeasure) {
				case "year":
					return "datetime;yyyy";

				case "month":
					if (new Date(this.scale.min).getFullYear() != new Date(this.scale.max).getFullYear()) return "yearOrMonth";
					return "datetime;yyyy MMM";

				case "week":
					return "datetime;MMMdd";

				case "day":
					if (
						new Date(this.scale.min).getFullYear() != new Date(this.scale.max).getFullYear() ||
						new Date(this.scale.min).getMonth() != new Date(this.scale.max).getMonth()
					)
						return "monthOrDay";
					return "datetime;yyyy MMM dd";

				case "hour":
					return "datetime;HH mm n";

				case "minute":
					return "datetime;HH mm n";

				case "second":
					return "datetime;mm ss";

				default:
					return "datetime;yyyy MMM dd HH mm ss n";
			}
		};

		_proto2.map = function map(v, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			return this.origin + (this.decodeValue(v) + offset - this.scale.minPad) * this.scale.factor;
		};

		_proto2.constrainValue = function constrainValue(v) {
			return Math.max(this.scale.min, Math.min(this.scale.max, v));
		};

		_proto2.trackValue = function trackValue(v, offset, constrain) {
			if (offset === void 0) {
				offset = 0;
			}

			if (constrain === void 0) {
				constrain = false;
			}

			var value = (this.decodeValue(v) - this.origin) / this.scale.factor - offset + this.scale.minPad;
			if (constrain) value = this.constrainValue(value);
			return value;
		};

		_proto2.hash = function hash() {
			var _this = this;

			var r = {
				origin: this.origin,
				factor: this.scale.factor,
				min: this.scale.min,
				max: this.scale.max,
				minPad: this.scale.minPad,
				maxPad: this.scale.maxPad
			};
			r.stacks = Object.keys(this.stacks)
				.map(function(s) {
					return _this.stacks[s].info.join(",");
				})
				.join(":");
			return r;
		};

		_proto2.isSame = function isSame(x) {
			var hash = this.hash();
			var same =
				x &&
				!Object.keys(hash).some(function(k) {
					return x[k] !== hash[k];
				});
			this.shouldUpdate = !same;
			return same;
		};

		_proto2.measure = function measure(a, b) {
			this.a = a;
			this.b = b;

			for (var s in this.stacks) {
				var info = this.stacks[s].measure(this.normalized);
				var min = info[0],
					max = info[1],
					invalid = info[2];
				if (this.minValue == null || min < this.minValue) this.minValue = min;
				if (this.max == null || max > this.maxValue) this.maxValue = max;
				this.stacks[s].info = info;
			}

			if (this.min == null) {
				if (this.minValue != null) this.min = this.minValue;
				else this.min = 0;
			} else this.minValuePad = this.min;

			if (this.max == null) {
				if (this.maxValue != null) this.max = this.maxValue;
				else this.max = this.normalized ? 1 : 100;
			} else this.maxValuePad = this.max;

			this.origin = this.inverted ? this.b : this.a;
			this.scale = this.getScale();
			this.calculateTicks();
		};

		_proto2.getTimezoneOffset = function getTimezoneOffset(date) {
			return date.getTimezoneOffset() * 60 * 1000;
		};

		_proto2.getScale = function getScale(tickSizes, measure) {
			var min = this.min,
				max = this.max;

			if (isNumber(this.snapToTicks) && measure && tickSizes && 0 <= this.snapToTicks && tickSizes.length > 0) {
				var size = tickSizes[Math.min(tickSizes.length - 1, this.snapToTicks)];
				var minDate = new Date(min);
				var maxDate = new Date(max);

				switch (measure) {
					case "second":
					case "minute":
					case "hours":
					case "day":
					default:
						var minOffset = this.getTimezoneOffset(minDate);
						var maxOffset = this.getTimezoneOffset(maxDate);
						min = Math.floor((min + minOffset) / size) * size - minOffset;
						max = Math.ceil((max + maxOffset) / size) * size - maxOffset;
						break;

					case "month":
						size /= miliSeconds.month;
						var minMonth = monthNumber(minDate);
						var maxMonth = monthNumber(maxDate);
						minMonth = Math.floor(minMonth / size) * size;
						maxMonth = Math.ceil(maxMonth / size) * size;
						min = new Date(Math.floor(minMonth / 12), minMonth % 12, 1).getTime();
						max = new Date(Math.floor(maxMonth / 12), maxMonth % 12 + 1, 1).getTime();
						break;

					case "year":
						size /= miliSeconds.year;
						var minYear = yearNumber(minDate);
						var maxYear = yearNumber(maxDate);
						minYear = Math.floor(minYear / size) * size;
						maxYear = Math.ceil(maxYear / size) * size;
						min = new Date(minYear, 0, 1).getTime();
						max = new Date(maxYear, 0, 1).getTime();
						break;
				}
			}

			var minPad = this.minValuePad != null ? Math.min(min, this.minValuePad) : min;
			var maxPad = this.maxValuePad != null ? Math.max(max, this.maxValuePad) : max;
			var factor = minPad < maxPad ? (this.b - this.a) / (maxPad - minPad) : 0;
			return {
				factor: this.inverted ? -factor : factor,
				min: min,
				max: max,
				minPad: minPad,
				maxPad: maxPad
			};
		};

		_proto2.acknowledge = function acknowledge(value, width, offset) {
			if (width === void 0) {
				width = 0;
			}

			if (offset === void 0) {
				offset = 0;
			}

			value = this.decodeValue(value);

			if (this.minValue == null || value < this.minValue) {
				this.minValue = value;
				this.minValuePad = value + offset - width / 2;
			}

			if (this.maxValue == null || value > this.maxValue) {
				this.maxValue = value;
				this.maxValuePad = value + offset + width / 2;
			}
		};

		_proto2.getStack = function getStack(name) {
			var s = this.stacks[name];
			if (!s) s = this.stacks[name] = new Stack();
			return s;
		};

		_proto2.stacknowledge = function stacknowledge(name, ordinal, value) {
			return this.getStack(name).acknowledge(ordinal, value);
		};

		_proto2.stack = function stack(name, ordinal, value) {
			var v = this.getStack(name).stack(ordinal, value);
			return v != null ? this.map(v) : null;
		};

		_proto2.findTickSize = function findTickSize(minPxDist) {
			var _this2 = this;

			return this.tickSizes.find(function(a) {
				return a * Math.abs(_this2.scale.factor) >= minPxDist;
			});
		};

		_proto2.getTickSizes = function getTickSizes() {
			return this.tickSizes;
		};

		_proto2.calculateTicks = function calculateTicks() {
			var _this3 = this;

			var minReached = false;

			var _loop = function _loop(unit) {
				if (!minReached) {
					if (unit == _this3.minTickUnit) minReached = true;
					else return "continue";
				}

				var unitSize = miliSeconds[unit];
				var divisions = _this3.tickDivisions[unit];

				if (_this3.tickSizes.length > 0) {
					var _this3$tickSizes;

					//add ticks from higher levels
					(_this3$tickSizes = _this3.tickSizes).push.apply(
						_this3$tickSizes,
						divisions[0].map(function(s) {
							return s * unitSize;
						})
					);

					return "continue";
				}

				var bestLevel = 100;
				var bestTicks = [];
				var bestScale = _this3.scale;
				_this3.tickMeasure = unit;

				var _loop2 = function _loop2(i) {
					var divs = divisions[i];
					var tickSizes = divs.map(function(s) {
						return s * unitSize;
					});

					var scale = _this3.getScale(tickSizes, unit);

					tickSizes.forEach(function(size, level) {
						var tickDistance = size * Math.abs(scale.factor);

						if (tickDistance >= _this3.minTickDistance && level < bestLevel) {
							bestScale = scale;
							bestTicks = tickSizes;
							bestLevel = level;
						}
					});
				};

				for (var i = 0; i < divisions.length && bestLevel > 0; i++) {
					_loop2(i);
				}

				_this3.scale = bestScale;
				_this3.tickSizes = bestTicks.filter(function(ts) {
					return ts * Math.abs(bestScale.factor) >= _this3.minTickDistance;
				});
			};

			for (var unit in miliSeconds) {
				var _ret = _loop(unit);

				if (_ret === "continue") continue;
			}
		};

		_proto2.getTicks = function getTicks(tickSizes) {
			var _this4 = this;

			return tickSizes.map(function(size) {
				var result = [],
					start,
					end,
					minDate,
					maxDate;

				if (_this4.tickMeasure == "year") {
					size /= miliSeconds.year;
					minDate = new Date(_this4.scale.min);
					maxDate = new Date(_this4.scale.max);
					start = Math.ceil(yearNumber(minDate) / size) * size;
					end = Math.floor(yearNumber(maxDate) / size) * size;

					for (var i = start; i <= end; i += size) {
						result.push(new Date(i, 0, 1).getTime());
					}
				} else if (_this4.tickMeasure == "month") {
					size /= miliSeconds.month;
					minDate = new Date(_this4.scale.min);
					maxDate = new Date(_this4.scale.max);
					start = Math.ceil(monthNumber(minDate) / size) * size;
					end = Math.floor(monthNumber(maxDate) / size) * size;

					for (var _i = start; _i <= end; _i += size) {
						result.push(new Date(Math.floor(_i / 12), _i % 12, 1).getTime());
					}
				} else {
					var minOffset = _this4.getTimezoneOffset(new Date(_this4.scale.min));

					var date = Math.ceil((_this4.scale.min - minOffset) / size) * size + minOffset;

					while (date <= _this4.scale.max) {
						result.push(date);
						date += size;
					}
				}

				return result;
			});
		};

		_proto2.mapGridlines = function mapGridlines() {
			var _this5 = this;

			if (this.tickSizes.length == 0) return [];
			return this.getTicks([this.tickSizes[0]])[0].map(function(x) {
				return _this5.map(x);
			});
		};

		return TimeScale;
	})();

var PointReducer =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(PointReducer, _PureContainer);

		function PointReducer() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = PointReducer.prototype;

		_proto.explore = function explore(context, instance) {
			var _this = this;

			var pointReducer = context.pointReducer;
			instance.parentPointTracker = pointReducer;

			if (!instance.pointReducer) {
				var onMap = this.onMap && instance.getCallback("onMap");
				var accumulator = {};

				instance.resetAccumulator = function() {
					accumulator = {};
					if (_this.onInitAccumulator) instance.invoke("onInitAccumulator", accumulator, instance);
				};

				instance.pointReducer = function(x, y, name, data, array, index) {
					onMap(accumulator, x, y, name, data, array, index);
					if (pointReducer) pointReducer(x, y, name, data, array, index);
				};

				instance.write = function() {
					if (_this.onReduce) instance.invoke("onReduce", accumulator, instance);
				};
			}

			instance.resetAccumulator();
			context.push("pointReducer", instance.pointReducer);

			_PureContainer.prototype.explore.call(this, context, instance);
		};

		_proto.exploreCleanup = function exploreCleanup(context, instance) {
			instance.write();
			context.pop("pointReducer");
		};

		return PointReducer;
	})(PureContainer);

var MinMaxFinder =
	/*#__PURE__*/
	(function(_PointReducer) {
		_inheritsLoose(MinMaxFinder, _PointReducer);

		function MinMaxFinder() {
			return _PointReducer.apply(this, arguments) || this;
		}

		var _proto = MinMaxFinder.prototype;

		_proto.declareData = function declareData() {
			var _PointReducer$prototy;

			return (_PointReducer$prototy = _PointReducer.prototype.declareData).call.apply(
				_PointReducer$prototy,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						minX: undefined,
						minY: undefined,
						maxX: undefined,
						maxY: undefined,
						params: {
							structured: true
						}
					}
				])
			);
		};

		_proto.onInitAccumulator = function onInitAccumulator(acc, _ref) {
			var data = _ref.data;
			acc.params = data.params;
			acc.min = {
				x: null,
				y: null
			};
			acc.max = {
				x: null,
				y: null
			};
		};

		_proto.onMap = function onMap(acc, x, y, name, p) {
			if (y != null && (acc.max.y == null || acc.max.y < y))
				acc.max = {
					x: x,
					y: y,
					p: p
				};
			if (y != null && (acc.min.y == null || acc.min.y > y))
				acc.min = {
					x: x,
					y: y,
					p: p
				};
		};

		_proto.onReduce = function onReduce(acc, instance) {
			instance.set("minX", acc.min.x);
			instance.set("minY", acc.min.y);
			instance.set("minRecord", acc.min.p);
			instance.set("maxX", acc.max.x);
			instance.set("maxY", acc.max.y);
			instance.set("maxRecord", acc.max.p);
		};

		return MinMaxFinder;
	})(PointReducer);

var SnapPointFinder =
	/*#__PURE__*/
	(function(_PointReducer) {
		_inheritsLoose(SnapPointFinder, _PointReducer);

		function SnapPointFinder() {
			return _PointReducer.apply(this, arguments) || this;
		}

		var _proto = SnapPointFinder.prototype;

		_proto.declareData = function declareData() {
			var _PointReducer$prototy;

			return (_PointReducer$prototy = _PointReducer.prototype.declareData).call.apply(
				_PointReducer$prototy,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						cursorX: undefined,
						cursorY: undefined,
						snapX: undefined,
						snapY: undefined,
						snapRecord: undefined,
						maxDistance: undefined
					}
				])
			);
		};

		_proto.onInitAccumulator = function onInitAccumulator(acc, _ref) {
			var data = _ref.data;
			acc.cursorX = data.cursorX;
			acc.cursorY = data.cursorY;
			acc.dist = data.maxDistance > 0 ? Math.pow(data.maxDistance, 2) : Number.POSITIVE_INFINITY;
			acc.snapX = null;
			acc.snapY = null;
		};

		_proto.onMap = function onMap(acc, x, y, name, p) {
			var d = null;
			if (acc.cursorX != null && x != null) d = (d || 0) + Math.pow(Math.abs(x - acc.cursorX), 2);
			if (acc.cursorY != null && y != null) d = (d || 0) + Math.pow(Math.abs(y - acc.cursorY), 2);

			if (d != null && d < acc.dist) {
				acc.dist = d;
				acc.snapX = x;
				acc.snapY = y;
				acc.snapRecord = p;
			}
		};

		_proto.onReduce = function onReduce(acc, instance) {
			instance.set("snapX", acc.snapX);
			instance.set("snapY", acc.snapY);
			instance.set("snapRecord", acc.snapRecord);
		};

		return SnapPointFinder;
	})(PointReducer);
SnapPointFinder.prototype.maxDistance = 50;

var ValueAtFinder =
	/*#__PURE__*/
	(function(_PointReducer) {
		_inheritsLoose(ValueAtFinder, _PointReducer);

		function ValueAtFinder() {
			return _PointReducer.apply(this, arguments) || this;
		}

		var _proto = ValueAtFinder.prototype;

		_proto.declareData = function declareData() {
			var _PointReducer$prototy;

			return (_PointReducer$prototy = _PointReducer.prototype.declareData).call.apply(
				_PointReducer$prototy,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						at: undefined,
						value: undefined
					}
				])
			);
		};

		_proto.onInitAccumulator = function onInitAccumulator(acc, _ref) {
			var data = _ref.data;
			acc.at = this.convert(data.at);
		};

		_proto.onMap = function onMap(acc, x, y, name) {
			var d = this.convert(x) - acc.at;

			if (d <= 0 && (!acc.left || acc.left.d < d)) {
				acc.left = {
					x: x,
					y: y,
					d: d
				};
			}

			if (d >= 0 && (!acc.right || acc.right.d > d)) {
				acc.right = {
					x: x,
					y: y,
					d: d
				};
			}
		};

		_proto.onReduce = function onReduce(acc, instance) {
			var y = null;

			if (acc.left && acc.right) {
				if (acc.left.x == acc.right.x) y = acc.left.y;
				else if (acc.left.y != null && acc.right.y != null) {
					y = acc.left.y + (acc.right.y - acc.left.y) * (acc.at - acc.left.x) / (acc.right.x - acc.left.x);
				}
			}

			instance.set("value", y);
		};

		return ValueAtFinder;
	})(PointReducer);

ValueAtFinder.prototype.convert = function(x) {
	return x;
};

export {
	Chart,
	PieChart,
	PieSlice,
	Pie,
	Column,
	Bar,
	Legend,
	LegendEntry,
	ColorMap,
	ColorMapScope,
	ColorIndex,
	Marker,
	MarkerLine,
	Range,
	Gridlines,
	LineGraph,
	ColumnGraph,
	BarGraph,
	ScatterGraph,
	BubbleGraph,
	MouseTracker,
	registerShape,
	getShape,
	getAvailableShapes,
	circle,
	square,
	bar,
	column,
	line,
	vline,
	triangle,
	Axis,
	NumericAxis,
	CategoryAxis,
	TimeAxis,
	PointReducer,
	MinMaxFinder,
	SnapPointFinder,
	ValueAtFinder
};
