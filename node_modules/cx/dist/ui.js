import { VDOM } from "cx-react";
import { NumberCulture, DateTimeCulture } from "intl-io";

function _defineProperties(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, descriptor.key, descriptor);
	}
}

function _createClass(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties(Constructor, staticProps);
	return Constructor;
}

function _defineProperty(obj, key, value) {
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value: value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}

	return obj;
}

function _objectSpread(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? arguments[i] : {};
		var ownKeys = Object.keys(source);

		if (typeof Object.getOwnPropertySymbols === "function") {
			ownKeys = ownKeys.concat(
				Object.getOwnPropertySymbols(source).filter(function(sym) {
					return Object.getOwnPropertyDescriptor(source, sym).enumerable;
				})
			);
		}

		ownKeys.forEach(function(key) {
			_defineProperty(target, key, source[key]);
		});
	}

	return target;
}

function _inheritsLoose(subClass, superClass) {
	subClass.prototype = Object.create(superClass.prototype);
	subClass.prototype.constructor = subClass;
	subClass.__proto__ = superClass;
}

function _setPrototypeOf(o, p) {
	_setPrototypeOf =
		Object.setPrototypeOf ||
		function _setPrototypeOf(o, p) {
			o.__proto__ = p;
			return o;
		};

	return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
	if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	if (Reflect.construct.sham) return false;
	if (typeof Proxy === "function") return true;

	try {
		Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
		return true;
	} catch (e) {
		return false;
	}
}

function _construct(Parent, args, Class) {
	if (isNativeReflectConstruct()) {
		_construct = Reflect.construct;
	} else {
		_construct = function _construct(Parent, args, Class) {
			var a = [null];
			a.push.apply(a, args);
			var Constructor = Function.bind.apply(Parent, a);
			var instance = new Constructor();
			if (Class) _setPrototypeOf(instance, Class.prototype);
			return instance;
		};
	}

	return _construct.apply(null, arguments);
}

function _assertThisInitialized(self) {
	if (self === void 0) {
		throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	}

	return self;
}

function isString(s) {
	return typeof s === "string";
}

function isObject(o) {
	return o !== null && typeof o === "object";
}

var bindingCache = {};
var Binding =
	/*#__PURE__*/
	(function() {
		function Binding(path) {
			this.path = path;
			this.parts = path.split(".");
			var fstr = "return (x";
			var cpath = "x";

			for (var i = 0; i < this.parts.length; i++) {
				if (this.parts[i][0] >= "0" && this.parts[i][0] <= "9") cpath += "[" + this.parts[i] + "]";
				else cpath += "." + this.parts[i];
				if (i + 1 < this.parts.length) fstr += " && " + cpath;
				else fstr += " ? " + cpath + " : undefined";
			}

			fstr += ")";
			this.value = new Function("x", fstr);
		}

		var _proto = Binding.prototype;

		_proto.set = function set(state, value) {
			var cv = this.value(state);
			if (cv === value) return state;
			var ns = Object.assign({}, state);
			var o = ns;

			for (var i = 0; i < this.parts.length; i++) {
				var part = this.parts[i];
				var no = i == this.parts.length - 1 ? value : Object.assign({}, o[part]);
				o[part] = no;
				o = no;
			}

			return ns;
		};

		_proto.delete = function _delete(state) {
			var ns = Object.assign({}, state);
			var o = ns;
			var part;

			for (var i = 0; i < this.parts.length - 1; i++) {
				part = this.parts[i];
				var no = Object.assign({}, o[part]);
				o[part] = no;
				o = no;
			}

			part = this.parts[this.parts.length - 1];
			if (!o.hasOwnProperty(part)) return state;
			delete o[part];
			return ns;
		};

		Binding.get = function get(path) {
			if (isString(path)) {
				var b = bindingCache[path];
				if (b) return b;
				b = new Binding(path);
				bindingCache[path] = b;
				return b;
			}

			if (isObject(path) && isString(path.bind)) return this.get(path.bind);
			if (path instanceof Binding) return path;
			throw new Error("Invalid binding definition provided.");
		};

		return Binding;
	})();
function isBinding(value) {
	if (isObject(value) && isString(value.bind)) return true;
	return value instanceof Binding;
}

function isFunction(f) {
	return typeof f === "function";
}

function computable() {
	var _ref;

	if (arguments.length == 0)
		throw new Error("computable requires at least a compute function to be passed in arguments.");
	var compute = ((_ref = arguments.length - 1), _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref]);
	if (typeof compute != "function") throw new Error("Last argument to the computable function should be a function.");
	var inputs = [],
		a;

	for (var i = 0; i + 1 < arguments.length; i++) {
		a = i < 0 || arguments.length <= i ? undefined : arguments[i];
		if (isString(a)) inputs.push(Binding.get(a).value);
		else if (a.memoize) inputs.push(a.memoize());
		else if (isFunction(a)) inputs.push(a);
		else throw new Error("Invalid selector type '" + typeof a + "' received.");
	}

	function memoize(amnesia, warmupData) {
		var lastValue,
			lastArgs =
				warmupData &&
				inputs.map(function(s, i) {
					return s(warmupData);
				});
		return function(data) {
			var dirty = amnesia;

			if (!lastArgs) {
				lastArgs = Array.from({
					length: inputs.length
				});
				dirty = true;
			}

			for (var _i = 0; _i < inputs.length; _i++) {
				var v = inputs[_i](data);

				if (v !== lastArgs[_i]) dirty = true;
				lastArgs[_i] = v;
			}

			if (dirty) lastValue = compute.apply(null, lastArgs);
			return lastValue;
		};
	}

	var selector = memoize(true);
	selector.memoize = memoize;
	return selector;
}

function isArray(a) {
	return Array.isArray(a);
}

var componentAlias = {};
var Component =
	/*#__PURE__*/
	(function() {
		function Component(config) {
			if (config && config.$props) {
				Object.assign(config, config.$props);
				delete config.$props;
			}

			Object.assign(this, config);
		}

		Component.alias = function alias(_alias, type) {
			var _this = this;

			if (type) {
				type.prototype.componentAlias = _alias;
				componentAlias[this.namespace + _alias] = type;
			} else //decorator usage
				return function(t) {
					_this.alias(_alias, t);

					return t;
				};
		};

		Component.create = function create(typeAlias, config, more) {
			var _this2 = this;

			if (!typeAlias) return this.factory(typeAlias, config, more);
			if (typeAlias.isComponent) return typeAlias;
			if (isComponentFactory(typeAlias)) return this.create(typeAlias.create(config));
			if (isArray(typeAlias))
				return typeAlias.map(function(c) {
					return _this2.create(c, config, more);
				});
			if (typeAlias.$type) return this.create(typeAlias.$type, typeAlias, config);
			if (typeAlias.type) return this.create(typeAlias.type, typeAlias, config);
			var cmpType, alias;
			if (typeAlias.isComponentType) cmpType = typeAlias;
			else if (isFunction(typeAlias)) {
				if (this.factory) return this.factory(typeAlias, config, more);
				throw new Error("Unsupported component type " + typeAlias + ".");
			} else if (isString(typeAlias)) {
				alias = this.namespace + typeAlias;
				cmpType = componentAlias[alias];

				if (!cmpType) {
					if (typeAlias && this.factory) return this.factory(typeAlias, config, more);
					throw new Error("Unknown component alias " + alias + ".");
				}
			} else if (typeof typeAlias == "object") {
				cmpType = typeAlias.type || typeAlias.$type;

				if (!cmpType) {
					cmpType = this;
					more = more ? Object.assign({}, config, more) : config;
					config = typeAlias;
				}
			}
			if (isArray(config))
				return config.map(function(cfg) {
					return _this2.create(cmpType, cfg, more);
				});
			var cfg = config;
			if (more) cfg = Object.assign({}, config, more);
			var cmp = new cmpType(cfg);
			if (cmpType.autoInit && cmp.init) cmp.init();
			return cmp;
		};

		return Component;
	})();
Component.prototype.isComponent = true;
Component.isComponentType = true;
Component.namespace = "";
Component.autoInit = false;

Component.factory = function(alias, config, more) {
	throw new Error("Unknown component alias " + alias + ".");
};

function createComponentFactory(factory, jsxDriver, meta) {
	factory.$isComponentFactory = true;
	factory.$meta = meta;
	factory.create = jsxDriver;
	return factory;
}
function isComponentFactory(factory) {
	return factory && factory.$isComponentFactory;
}

function isDefined(v) {
	return v !== undefined;
}

var Ref =
	/*#__PURE__*/
	(function(_Component) {
		_inheritsLoose(Ref, _Component);

		function Ref(config) {
			var _context;

			var _this;

			_this = _Component.call(this, config) || this;
			_this.get = (_context = _this).get.bind(_context);
			_this.set = (_context = _this).set.bind(_context);
			return _this;
		}

		var _proto = Ref.prototype;

		_proto.get = function get() {
			return this.store.get(this.path);
		};

		_proto.set = function set(value) {
			return this.store.set(this.path, value);
		};

		_proto.init = function init(value) {
			return this.store.init(this.path, value);
		};

		_proto.toggle = function toggle() {
			return this.store.toggle(this.path);
		};

		_proto.delete = function _delete() {
			return this.store.delete(this.path);
		};

		_proto.update = function update() {
			var _this$store;

			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return (_this$store = this.store).update.apply(_this$store, [this.path].concat(args));
		};

		_proto.as = function as(config) {
			return Ref.create(config, {
				store: this.store,
				path: this.path
			});
		}; //allows the function to be passed as a selector, e.g. to computable or addTrigger

		_proto.memoize = function memoize() {
			return this.get;
		};

		return Ref;
	})(Component);

Ref.factory = function(alias, config, more) {
	if (isFunction(alias)) {
		var cfg = _objectSpread({}, config, more);

		if (cfg.store) Object.assign(cfg, cfg.store.getMethods());
		var result = alias(cfg);
		if (result instanceof Ref) return result;
		return Ref.create(_objectSpread({}, config, more, result));
	}

	return Ref.create(_objectSpread({}, config, more));
};

var View =
	/*#__PURE__*/
	(function() {
		function View(config) {
			Object.assign(this, config);
			this.cache = {
				version: -1
			};
			if (this.store) this.setStore(this.store);
		}

		var _proto = View.prototype;

		_proto.getData = function getData() {
			throw new Error("abstract method");
		};

		_proto.init = function init(path, value) {
			if (path instanceof Binding) path = path.path;
			else if (typeof path == "object" && path != null) {
				var changed = false;

				for (var key in path) {
					if (path.hasOwnProperty(key) && this.get(key) === undefined && this.setItem(key, path[key])) changed = true;
				}

				return changed;
			}
			if (this.get(path) === undefined) return this.setItem(path, value);
			return false;
		};

		_proto.set = function set(path, value) {
			if (path instanceof Binding) path = path.path;
			else if (typeof path == "object" && path != null) {
				var changed = false;

				for (var key in path) {
					if (path.hasOwnProperty(key) && this.setItem(key, path[key])) changed = true;
				}

				return changed;
			}
			return this.setItem(path, value);
		};

		_proto.copy = function copy(from, to) {
			var value = this.get(from);
			this.set(to, value);
		};

		_proto.move = function move(from, to) {
			var _this = this;

			this.batch(function() {
				_this.copy(from, to);

				_this.delete(from);
			});
		}; //protected

		_proto.setItem = function setItem(path, value) {
			if (this.store) return this.store.setItem(path, value);
			throw new Error("abstract method");
		};

		_proto.delete = function _delete(path) {
			var _this2 = this;

			if (path instanceof Binding) path = path.path;
			else if (arguments.length > 1) path = Array.from(arguments);
			if (isArray(path))
				return path
					.map(function(arg) {
						return _this2.deleteItem(arg);
					})
					.some(Boolean);
			return this.deleteItem(path);
		}; //protected

		_proto.deleteItem = function deleteItem(path) {
			if (this.store) return this.store.deleteItem(path);
			throw new Error("abstract method");
		};

		_proto.clear = function clear() {
			if (this.store) return this.store.clear();
			throw new Error("abstract method");
		};

		_proto.get = function get(path) {
			var storeData = this.getData();
			if (arguments.length > 1) path = Array.from(arguments);
			if (isArray(path))
				return path.map(function(arg) {
					return Binding.get(arg).value(storeData);
				});
			return Binding.get(path).value(storeData);
		};

		_proto.toggle = function toggle(path) {
			return this.set(path, !this.get(path));
		};

		_proto.update = function update(path, updateFn) {
			for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
				args[_key - 2] = arguments[_key];
			}

			return this.set(path, updateFn.apply(null, [this.get(path)].concat(args)));
		};

		_proto.batch = function batch(callback) {
			var dirty = this.silently(callback);
			if (dirty) this.notify();
			return dirty;
		};

		_proto.silently = function silently(callback) {
			if (this.store) return this.store.silently(callback);
			throw new Error("abstract method");
		};

		_proto.notify = function notify(path) {
			if (this.notificationsSuspended) this.dirty = true;
			else this.doNotify(path);
		};

		_proto.doNotify = function doNotify(path) {
			if (this.store) return this.store.notify(path);
			throw new Error("abstract method");
		};

		_proto.subscribe = function subscribe(callback) {
			if (this.store) return this.store.subscribe(callback);
			throw new Error("abstract method");
		};

		_proto.load = function load(data) {
			return this.batch(function(store) {
				for (var key in data) {
					store.set(key, data[key]);
				}
			});
		};

		_proto.dispatch = function dispatch(action) {
			if (this.store) return this.store.dispatch(action);
			throw new Error("The underlying store doesn't support dispatch.");
		};

		_proto.getMeta = function getMeta() {
			return this.meta;
		};

		_proto.setStore = function setStore(store) {
			this.store = store;
			this.meta = store.getMeta();
		};

		_proto.ref = function ref(path, defaultValue) {
			if (isDefined(defaultValue)) this.init(path, defaultValue);
			return Ref.create({
				store: this,
				path: path
			});
		};

		_proto.getMethods = function getMethods() {
			return {
				getData: this.getData.bind(this),
				set: this.set.bind(this),
				get: this.get.bind(this),
				update: this.update.bind(this),
				delete: this.delete.bind(this),
				toggle: this.toggle.bind(this),
				init: this.init.bind(this),
				ref: this.ref.bind(this)
			};
		};

		return View;
	})();
View.prototype.sealed = false; //indicate that data should be copied before virtual items are added

var StoreProxy =
	/*#__PURE__*/
	(function(_View) {
		_inheritsLoose(StoreProxy, _View);

		function StoreProxy(getStore) {
			var _this;

			_this =
				_View.call(this, {
					store: getStore()
				}) || this;
			Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "store", {
				get: getStore
			});
			return _this;
		}

		var _proto = StoreProxy.prototype;

		_proto.getData = function getData() {
			return this.store.getData();
		};

		return StoreProxy;
	})(View);

var computablePrefix = "computable-";
var triggerPrefix = "trigger-";
var Controller =
	/*#__PURE__*/
	(function(_Component) {
		_inheritsLoose(Controller, _Component);

		function Controller() {
			return _Component.apply(this, arguments) || this;
		}

		var _proto = Controller.prototype;

		_proto.init = function init(context) {
			if (!this.initialized) {
				this.initialized = true;
				if (this.onInit) this.onInit(context);
			}
		};

		_proto.explore = function explore(context) {
			var store = this.instance.store;
			this.store = store; //in rare cases instance may change its store

			if (!this.initialized) {
				this.init(context); //forgive if the developer forgets to call super.init()

				this.initialized = true;
			}

			if (this.computables) {
				for (var key in this.computables) {
					var x = this.computables[key];
					var v = x.selector(store.getData());
					if (x.type == "computable") store.set(x.name, v);
				}
			}

			if (this.onExplore) {
				this.onExplore(context);
			}
		};

		_proto.prepare = function prepare(context) {
			if (this.onPrepare) {
				this.onPrepare(context);
			}
		};

		_proto.cleanup = function cleanup(context) {
			if (this.onCleanup) {
				this.onCleanup(context);
			}
		};

		_proto.addComputable = function addComputable(name, args, callback) {
			if (!isArray(args)) throw new Error("Second argument to the addComputable method should be an array.");
			var selector = computable.apply(void 0, args.concat([callback])).memoize();
			if (!this.computables) this.computables = {};
			this.computables[computablePrefix + name] = {
				name: name,
				selector: selector,
				type: "computable"
			};
		};

		_proto.addTrigger = function addTrigger(name, args, callback, autoRun) {
			if (!isArray(args)) throw new Error("Second argument to the addTrigger method should be an array.");
			var selector = computable.apply(void 0, args.concat([callback])).memoize(false, !autoRun && this.store.getData());
			if (!this.computables) this.computables = {};
			this.computables[triggerPrefix + name] = {
				name: name,
				selector: selector,
				type: "trigger"
			};
		};

		_proto.removeTrigger = function removeTrigger(name) {
			if (this.computables) delete this.computables[triggerPrefix + name];
		};

		_proto.removeComputable = function removeComputable(name) {
			if (this.computables) delete this.computables[computablePrefix + name];
		};

		_proto.invokeParentMethod = function invokeParentMethod(methodName) {
			var _this$instance;

			for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}

			return (_this$instance = this.instance).invokeControllerMethod.apply(_this$instance, [methodName].concat(args));
		};

		return Controller;
	})(Component);
Controller.namespace = "ui.controller.";

Controller.factory = function(alias, config, more) {
	if (isFunction(alias)) {
		var cfg = _objectSpread({}, config, more);

		if (cfg.instance) {
			//in rare cases instance.store may change, so we cannot rely on the store passed through configuration
			cfg.store = new StoreProxy(function() {
				return cfg.instance.store;
			});
			Object.assign(cfg, cfg.store.getMethods());
		}

		var result = alias(cfg);
		if (result instanceof Controller) return result;
		return Controller.create(_objectSpread({}, config, more, result));
	}

	return Controller.create(_objectSpread({}, config, more));
};

var cssHelperCache = {};
var CSSHelper =
	/*#__PURE__*/
	(function() {
		function CSSHelper() {}

		CSSHelper.get = function get(code) {
			var helper = cssHelperCache[code];
			if (!helper) throw new Error("Unknown CSS helper '" + code + "'.");
			return helper;
		};

		CSSHelper.register = function register(code, helper) {
			cssHelperCache[code] = helper;
		};

		CSSHelper.alias = function alias(code, helper) {
			cssHelperCache[code] = helper;
		};

		return CSSHelper;
	})();

function parseStyle(str) {
	if (typeof str != "string") return str;
	var style = {},
		parts = str.split(";");

	for (var i = 0; i < parts.length; i++) {
		var part = parts[i];
		var colonIndex = part.indexOf(":");
		if (colonIndex == -1) continue;
		var name = part.substring(0, colonIndex).trim();
		var value = part.substring(colonIndex + 1).trim();
		name = name
			.split("-")
			.map(function(p, i) {
				return i == 0 ? p : p[0].toUpperCase() + p.substring(1);
			})
			.join("");
		style[name] = value;
	}

	return style;
}

function push(list, item) {
	if (!item) return list;
	if (!list) list = [];
	list.push(item);
	return list;
}

function pushMore(list, itemArray) {
	if (!itemArray || itemArray.length == 0) return list;
	if (!list) list = [];
	list.push.apply(list, itemArray);
	return list;
}

function pushMap(list, itemArray, mapF) {
	return itemArray ? pushMore(list, itemArray.map(mapF)) : list;
}

function join(list) {
	return list ? list.join(" ") : null;
}

var CSS =
	/*#__PURE__*/
	(function() {
		function CSS() {}

		CSS.resolve = function resolve() {
			var list, type, arg, i, key;

			for (i = 0; i < arguments.length; i++) {
				arg = arguments[i];

				if (arg) {
					type = typeof arg;
					if (type == "string") list = push(list, arg);
					else if (type == "object") {
						if (isArray(arg)) list = pushMore(list, this.resolve.apply(this, arg));
						else
							for (key in arg) {
								if (arg[key]) list = push(list, key);
							}
					}
				}
			}

			return list;
		};

		CSS.block = function block(baseClass, styleModifiers, stateModifiers) {
			var _this = this;

			var list;
			if (baseClass) list = push(list, this.classPrefix + "b-" + baseClass);
			list = pushMap(list, this.resolve(styleModifiers), function(m) {
				return _this.classPrefix + "m-" + m;
			});
			list = pushMap(list, this.resolve(stateModifiers), function(m) {
				return _this.classPrefix + "s-" + m;
			});
			return join(list);
		};

		CSS.element = function element(baseClass, elementClass, stateModifiers) {
			var _this2 = this;

			var list;
			if (baseClass && elementClass) list = push(list, this.classPrefix + "e-" + baseClass + "-" + elementClass);
			list = pushMap(list, this.resolve(stateModifiers), function(m) {
				return _this2.classPrefix + "s-" + m;
			});
			return join(list);
		};

		CSS.state = function state(stateModifiers) {
			var _this3 = this;

			return join(
				pushMap(null, this.resolve(stateModifiers), function(m) {
					return _this3.classPrefix + "s-" + m;
				})
			);
		};

		CSS.expand = function expand() {
			return join(this.resolve.apply(this, arguments));
		};

		CSS.parseStyle = function parseStyle$$1(str) {
			return parseStyle(str);
		};

		return CSS;
	})();
CSS.classPrefix = "cx";
CSSHelper.alias("cx", CSS);

var Console = {
	log: function log() {
		var _console;

		if (typeof window != "undefined" && window.console) (_console = console).log.apply(_console, arguments);
	},
	warn: function warn() {
		var _console2;

		if (typeof window != "undefined" && window.console) (_console2 = console).warn.apply(_console2, arguments);
	}
};

var activeFlags = {
	deprecated: true
};
function debug(flag) {
	if (process.env.NODE_ENV !== "production") {
		if (!activeFlags[flag]) return;
		Console.log.apply(Console, arguments);
	}
}
var renderFlag = "render";
var processDataFlag = "process-data";
var appDataFlag = "app-data";
var destroyFlag = "destroy";

var globalCacheIdentifier = 1;
var GlobalCacheIdentifier =
	/*#__PURE__*/
	(function() {
		function GlobalCacheIdentifier() {}

		GlobalCacheIdentifier.get = function get() {
			return globalCacheIdentifier;
		};

		GlobalCacheIdentifier.change = function change() {
			globalCacheIdentifier++;
		};

		return GlobalCacheIdentifier;
	})();

function isNumber(n) {
	return typeof n === "number";
}

function isUndefined(v) {
	return v === undefined;
}

var defaultFormatter = function defaultFormatter(v) {
	return v.toString();
};

var formatFactory = {
	string: function string() {
		return defaultFormatter;
	},
	wrap: function wrap(part0, prefix, suffix) {
		if (!prefix) prefix = "";
		if (!suffix) suffix = "";
		return function(value) {
			return prefix + value.toString() + suffix;
		};
	},
	fixed: function fixed(part0, digits) {
		return function(value) {
			return value.toFixed(digits);
		};
	},
	prefix: function prefix(part0, _prefix) {
		if (!_prefix) _prefix = "";
		return function(value) {
			return _prefix + value.toString();
		};
	},
	suffix: function suffix(part0, _suffix) {
		if (!_suffix) _suffix = "";
		return function(value) {
			return value.toString() + _suffix;
		};
	},
	uppercase: function uppercase() {
		return function(value) {
			return value.toString().toUpperCase();
		};
	},
	lowercase: function lowercase() {
		return function(value) {
			return value.toString().toLowerCase();
		};
	},
	urlencode: function urlencode() {
		return function(value) {
			return encodeURIComponent(value);
		};
	},
	number: function number(part0, minFractionDigits, maxFractionDigits) {
		var _resolveMinMaxFractio = resolveMinMaxFractionDigits(minFractionDigits, maxFractionDigits),
			minimumFractionDigits = _resolveMinMaxFractio.minimumFractionDigits,
			maximumFractionDigits = _resolveMinMaxFractio.maximumFractionDigits;

		var trimmable = maximumFractionDigits - minimumFractionDigits;

		if (trimmable > 0) {
			if (minimumFractionDigits == 0) ++trimmable;
			return function(value) {
				return trimFractionZeros(value.toFixed(maximumFractionDigits), trimmable);
			};
		}

		return function(value) {
			return value.toFixed(maximumFractionDigits);
		};
	},
	percentage: function percentage(part0, minFractionDigits, maxFractionDigits) {
		var numberFormatter = formatFactory.number(part0, minFractionDigits, maxFractionDigits);
		return function(value) {
			return numberFormatter(value * 100) + "%";
		};
	},
	percentageSign: function percentageSign(part0, minFractionDigits, maxFractionDigits) {
		var numberFormatter = formatFactory.number(part0, minFractionDigits, maxFractionDigits);
		return function(value) {
			return numberFormatter(value) + "%";
		};
	},
	date: function date() {
		return function(value) {
			var date = new Date(value);
			return date.getMonth() + 1 + "/" + date.getDate() + "/" + date.getFullYear();
		};
	},
	time: function time() {
		return function(value) {
			var date = new Date(value);
			var h = date.getHours() >= 10 ? date.getHours() : "0" + date.getHours();
			var m = date.getMinutes() >= 10 ? date.getMinutes() : "0" + date.getMinutes();
			return h + ":" + m;
		};
	},
	datetime: function datetime() {
		var date = formatFactory.date();
		var time = formatFactory.time();
		return function(value) {
			return date(value) + " " + time(value);
		};
	},
	ellipsis: function ellipsis(part0, length, where) {
		length = Number(length);
		if (!(length > 3)) length = 10;

		switch (where) {
			default:
			case "end":
				return function(value) {
					var s = String(value);
					if (s.length > length) return s.substring(0, length - 3) + "...";
					return s;
				};

			case "start":
				return function(value) {
					var s = String(value);
					if (s.length > length) return "..." + s.substring(s.length - length + 3);
					return s;
				};

			case "middle":
				return function(value) {
					var s = String(value);

					if (s.length > length) {
						var x = Math.floor(length - 2) / 2;
						return s.substring(0, x) + "..." + s.substring(s.length - (length - 3 - x));
					}

					return s;
				};
		}
	}
};
formatFactory.s = formatFactory.str = formatFactory.string;
formatFactory.f = formatFactory.fixed;
formatFactory.n = formatFactory.number;
formatFactory.p = formatFactory.percentage;
formatFactory.ps = formatFactory.percentageSign;
formatFactory.d = formatFactory.date;
formatFactory.t = formatFactory.time;
formatFactory.dt = formatFactory.datetime;

function buildFormatter(format) {
	var formatter = defaultFormatter,
		nullText = "";

	if (format) {
		var pipeParts = format.split("|");
		nullText = pipeParts[1] || "";
		var colonSepParts = pipeParts[0].split(":");

		for (var i = 0; i < colonSepParts.length; i++) {
			var parts = colonSepParts[i].split(";");
			var factory = formatFactory[parts[0]];
			if (!factory) debug("Unknown string format: " + format);
			else if (i == 0) formatter = factory.apply(void 0, parts);
			else {
				(function() {
					var outerFmt = factory.apply(void 0, parts);
					var innerFmt = formatter;

					formatter = function formatter(v) {
						return outerFmt(innerFmt(v));
					};
				})();
			}
		}
	}

	return function(v) {
		return v == null || v === "" ? nullText : formatter(v);
	};
}

var format = {
	cache: {}
};

function getFormatCache() {
	if (format.cacheIdentifier != GlobalCacheIdentifier.get()) {
		format = {
			cache: {},
			cacheIdentifier: GlobalCacheIdentifier.get()
		};
	}

	return format.cache;
}

function getFormatter(format) {
	if (!format) format = "";
	var formatCache = getFormatCache();
	var formatter = formatCache[format];
	if (!formatter) formatter = formatCache[format] = buildFormatter(format);
	return formatter;
}

var Format =
	/*#__PURE__*/
	(function() {
		function Format() {}

		Format.value = function value(v, format) {
			var formatter = getFormatter(format);
			return formatter(v);
		};

		Format.parse = function parse(format) {
			return getFormatter(format);
		};

		Format.register = function register(format, formatter) {
			this.registerFactory(format, function() {
				return formatter;
			});
		};

		Format.registerFactory = function registerFactory(format, factory) {
			var _this = this;

			if (isArray(format))
				format.forEach(function(f) {
					return _this.registerFactory(f, factory);
				});
			else formatFactory[format] = factory;
		};

		return Format;
	})();
function resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits) {
	minimumFractionDigits = minimumFractionDigits != null ? Number(minimumFractionDigits) : minimumFractionDigits;
	maximumFractionDigits = maximumFractionDigits != null ? Number(maximumFractionDigits) : maximumFractionDigits;

	if (isNumber(minimumFractionDigits)) {
		if (isUndefined(maximumFractionDigits)) maximumFractionDigits = minimumFractionDigits;
		else if (isNumber(maximumFractionDigits) && maximumFractionDigits < minimumFractionDigits)
			maximumFractionDigits = minimumFractionDigits;
	} else if (minimumFractionDigits == null && maximumFractionDigits == null) {
		minimumFractionDigits = 0;
		maximumFractionDigits = 18;
	}

	return {
		minimumFractionDigits: minimumFractionDigits,
		maximumFractionDigits: maximumFractionDigits
	};
}
function trimFractionZeros(str, max) {
	var cnt = 0,
		l = str.length;

	while (cnt < max && (str[l - 1 - cnt] === "0" || str[l - 1 - cnt] === ".")) {
		cnt++;
	}

	return cnt > 0 ? str.substring(0, l - cnt) : str;
}

function quoteStr(str) {
	if (str == null) return str;
	return "'" + str.replace(/'/g, "\\i") + "'";
}

function isDigit(x) {
	return x >= "0" && x <= "9";
}

/*
   Helper usage example

   Expression.registerHelper('_', _);
   let e = Expression.compile('_.min({data})');
 */

var expCache = {},
	helpers = {},
	helperNames = [],
	helperValues = [],
	expFatArrows = null;

function getExpr(expr) {
	if (expr.memoize) return expr;

	function memoize() {
		var lastValue,
			lastRunBindings = {},
			lastRunResults = {},
			getters = {},
			currentData,
			len = -1;

		var get = function get(bindingWithFormat) {
			var getter = getters[bindingWithFormat];

			if (!getter) {
				var binding = bindingWithFormat,
					format;
				var colonIndex = bindingWithFormat.indexOf(":");

				if (colonIndex != -1) {
					format = Format.parse(bindingWithFormat.substring(colonIndex + 1));
					binding = bindingWithFormat.substring(0, colonIndex);
				} else {
					var nullSeparatorIndex = bindingWithFormat.indexOf(":");

					if (nullSeparatorIndex != -1) {
						format = Format.parse(bindingWithFormat.substring(nullSeparatorIndex));
						binding = bindingWithFormat.substring(0, nullSeparatorIndex - 1);
					}
				}

				var b = Binding.get(binding);

				getter = function getter(data) {
					var value = b.value(data);
					lastRunBindings[len] = b.value;
					lastRunResults[len] = value;
					len++;
					return value;
				};

				if (format) {
					var valueGetter = getter;

					getter = function getter(data) {
						return format(valueGetter(data));
					};
				}

				getters[bindingWithFormat] = getter;
			}

			return getter(currentData);
		};

		return function(data) {
			var i = 0;

			for (; i < len; i++) {
				if (lastRunBindings[i](data) !== lastRunResults[i]) break;
			}

			if (i !== len) {
				len = 0;
				currentData = data;
				lastValue = expr(get);
			}

			return lastValue;
		};
	}

	var result = memoize();
	result.memoize = memoize;
	return result;
}

function expression(str) {
	var _ref;

	if (isFunction(str)) return getExpr(str);
	var r = expCache[str];
	if (r) return r;
	var quote = false;
	var termStart = -1,
		curlyBrackets = 0,
		percentExpression;
	var fb = ["return ("];
	var args = {};
	var formats = [];
	var subExpr = 0;

	for (var i = 0; i < str.length; i++) {
		var c = str[i];

		switch (c) {
			case "{":
				if (curlyBrackets > 0) curlyBrackets++;
				else {
					if (!quote && termStart < 0 && (str[i + 1] != "{" || str[i - 1] == "%")) {
						termStart = i + 1;
						curlyBrackets = 1;
						percentExpression = str[i - 1] == "%";
						if (percentExpression) fb.pop(); //%
					} else if (str[i - 1] != "{") fb.push(c);
				}
				break;

			case "}":
				if (termStart >= 0) {
					if (--curlyBrackets == 0) {
						var term = str.substring(termStart, i);
						var formatStart = 0;
						if (term[0] == "[") formatStart = term.indexOf("]");
						var colon = term.indexOf(":", formatStart > 0 ? formatStart : 0);
						var binding = colon == -1 ? term : term.substring(0, colon);
						var format = colon == -1 ? null : term.substring(colon + 1);

						if (colon == -1) {
							var nullSepIndex = binding.indexOf("|");

							if (nullSepIndex != -1) {
								format = binding.substring(nullSepIndex);
								binding = binding.substring(0, nullSepIndex);
							}
						}

						var argName = binding.replace(/\./g, "_");
						if (isDigit(argName[0])) argName = "$" + argName;

						if (percentExpression || (binding[0] == "[" && binding[binding.length - 1] == "]")) {
							argName = "expr" + ++subExpr;
							args[argName] = expression(percentExpression ? binding : binding.substring(1, binding.length - 1));
						} else args[argName] = binding;

						if (format) {
							var formatter = "fmt" + formats.length;
							fb.push(formatter, "(", argName, ", ", quoteStr(format), ")");
							formats.push(Format.parse(format));
						} else fb.push(argName);

						termStart = -1;
					}
				} else fb.push(c);

				break;

			case '"':
			case "'":
				if (curlyBrackets == 0) {
					if (!quote) quote = c;
					else if (str[i - 1] != "\\" && quote == c) quote = false;
					fb.push(c);
				}

				break;

			default:
				if (termStart < 0) fb.push(c);
				break;
		}
	}

	fb.push(")");
	var body = fb.join("");
	if (expFatArrows) body = expFatArrows(body); //console.log(body);

	var keys = Object.keys(args);

	var compute = (_ref = _construct(
		Function,
		formats
			.map(function(f, i) {
				return "fmt" + i;
			})
			.concat(keys, helperNames, [body])
	)).bind.apply(_ref, [Format].concat(formats, helperValues));

	var selector = computable.apply(
		void 0,
		keys
			.map(function(k) {
				return args[k];
			})
			.concat([compute])
	);
	expCache[str] = selector;
	return selector;
}
var Expression = {
	get: function get(str) {
		return expression(str);
	},
	compile: function compile(str) {
		return this.get(str).memoize();
	},
	registerHelper: function registerHelper(name, helper) {
		helpers[name] = helper;
		helperNames = Object.keys(helpers);
		helperValues = helperNames.map(function(n) {
			return helpers[n];
		});
	}
};
function invalidateExpressionCache() {
	expCache = {};
}

function plus(str) {
	return str.length ? str + " + " : str;
}

var tplCache = {};
function stringTemplate(str) {
	var expr = tplCache[str];
	if (expr) return expr;
	expr = "";
	var termStart = -1,
		quoteStart = 0,
		term,
		bracketsOpen = 0,
		percentSign;

	for (var i = 0; i < str.length; i++) {
		var c = str[i];

		switch (c) {
			case "{":
				if (termStart < 0) {
					if (str[i + 1] == "{" && str[i - 1] != "%") {
						expr = plus(expr) + quoteStr(str.substring(quoteStart, i) + "{");
						i++;
						quoteStart = i + 1;
					} else {
						termStart = i + 1;
						percentSign = str[i - 1] == "%";
						if (i > quoteStart) expr = plus(expr) + quoteStr(str.substring(quoteStart, percentSign ? i - 1 : i));
						bracketsOpen = 1;
					}
				} else bracketsOpen++;

				break;

			case "}":
				if (termStart >= 0) {
					if (--bracketsOpen == 0) {
						term = str.substring(termStart, i);

						if (term.indexOf(":") == -1) {
							var nullSepIndex = term.indexOf("|");
							if (nullSepIndex == -1) term += ":s";
							else term = term.substring(0, nullSepIndex) + ":s" + term.substring(nullSepIndex);
						}

						expr = plus(expr) + (percentSign ? "%{" : "{") + term + "}";
						termStart = -1;
						quoteStart = i + 1;
						bracketsOpen = 0;
					}
				} else if (str[i + 1] == "}") {
					expr = plus(expr) + quoteStr(str.substring(quoteStart, i) + "}");
					i++;
					quoteStart = i + 1;
				}

				break;
		}
	}

	if (quoteStart < str.length) expr = plus(expr) + quoteStr(str.substring(quoteStart)); //console.log(expr);

	return (tplCache[str] = expression(expr));
}
var StringTemplate = {
	get: function get(str) {
		return stringTemplate(str);
	},
	compile: function compile(str) {
		return stringTemplate(str).memoize();
	},
	format: function format(_format) {
		for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		return stringTemplate(_format)(args);
	}
};
function invalidateStringTemplateCache() {
	tplCache = {};
}

function createStructuredSelector(selector, constants) {
	var keys = Object.keys(selector);
	if (keys.length == 0)
		return function() {
			return constants;
		};

	function memoize() {
		var lastResult = Object.assign({}, constants);
		var memoizedSelectors = {};
		keys.forEach(function(key) {
			memoizedSelectors[key] = selector[key].memoize ? selector[key].memoize() : selector[key];
		});
		return function(data) {
			var result = lastResult,
				k,
				v,
				i;

			for (i = 0; i < keys.length; i++) {
				k = keys[i];
				v = memoizedSelectors[k](data);

				if (result === lastResult) {
					if (v === lastResult[k]) continue;
					result = Object.assign({}, lastResult);
				}

				result[k] = v;
			}

			return (lastResult = result);
		};
	}

	function evaluate(data) {
		var result = Object.assign({}, constants);

		for (var i = 0; i < keys.length; i++) {
			result[keys[i]] = selector[keys[i]](data);
		}

		return result;
	}

	evaluate.memoize = memoize;
	return evaluate;
}

function isSelector(config) {
	if (config == null) return true;

	switch (typeof config) {
		case "object":
			if (config.type || config.$type) return false;
			return !!(config.bind || config.tpl || config.expr || config.get);

		case "function":
			return true;

		case "string":
			return true;

		case "number":
			return true;

		case "boolean":
			return true;
	}

	return false;
}

var nullF = function nullF() {
	return null;
};

function getSelector(config) {
	if (config == null) return nullF;

	switch (typeof config) {
		case "object":
			if (isArray(config)) {
				var _selectors = config.map(function(x) {
					return getSelector(x);
				});

				return function(data) {
					return _selectors.map(function(elementSelector) {
						return elementSelector(data);
					});
				};
			}

			if (config.bind) return Binding.get(config.bind).value;
			if (config.tpl) return StringTemplate.get(config.tpl);
			if (config.expr) return Expression.get(config.expr);
			if (config.get) return config.get;
			var selectors = {};
			var constants = {};

			for (var key in config) {
				if (isSelector(config[key])) selectors[key] = getSelector(config[key]);
				else constants[key] = config[key];
			}

			return createStructuredSelector(selectors, constants);

		case "function":
			return config;

		default:
			return function() {
				return config;
			};
	}
}

function defaultValue(pv) {
	if (typeof pv == "object" && pv && pv.structured) return pv.defaultValue;
	return pv;
}

function getSelectorConfig(props, values, nameMap) {
	var functions = {},
		structures = {},
		defaultValues = {},
		constants,
		p,
		v,
		pv,
		constant = true;

	for (p in props) {
		v = values[p];
		pv = props[p];
		if (isUndefined(v) && pv && (pv.bind || pv.tpl || pv.expr)) v = pv;

		if (v === null) {
			if (!constants) constants = {};
			constants[p] = null;
		} else if (typeof v == "object") {
			if (v.bind) {
				if (isUndefined(v.defaultValue) && v != pv) v.defaultValue = defaultValue(pv);
				if (isDefined(v.defaultValue)) defaultValues[v.bind] = v.defaultValue;
				nameMap[p] = v.bind;
				functions[p] = Binding.get(v.bind).value;
				constant = false;
			} else if (v.expr) {
				functions[p] = Expression.get(v.expr);
				constant = false;
			} else if (v.get) {
				functions[p] = v.get;
				constant = false;
			} else if (v.tpl) {
				functions[p] = StringTemplate.get(v.tpl);
				constant = false;
			} else if (pv && typeof pv == "object" && pv.structured) {
				if (isArray(v)) functions[p] = getSelector(v);
				else {
					var s = getSelectorConfig(v, v, {});
					structures[p] = s;
					Object.assign(defaultValues, s.defaultValues);
				}
				constant = false;
			} else {
				if (!constants) constants = {};
				constants[p] = v;
			}
		} else if (isFunction(v)) {
			functions[p] = v;
			constant = false;
		} else {
			if (isUndefined(v)) {
				if (isUndefined(pv)) continue;
				v = defaultValue(pv);
			}

			if (isUndefined(v)) continue;
			if (!constants) constants = {};
			constants[p] = v;
		}
	}

	return {
		functions: functions,
		structures: structures,
		defaultValues: defaultValues,
		constants: constants,
		constant: constant
	};
}

function createSelector(_ref) {
	var functions = _ref.functions,
		structures = _ref.structures,
		constants = _ref.constants,
		defaultValues = _ref.defaultValues;
	var selector = {};

	for (var n in functions) {
		selector[n] = functions[n];
	}

	for (var _n in structures) {
		selector[_n] = createSelector(structures[_n]);
	}

	return createStructuredSelector(selector, constants);
}

var StructuredSelector =
	/*#__PURE__*/
	(function() {
		function StructuredSelector(_ref2) {
			var props = _ref2.props,
				values = _ref2.values;
			this.nameMap = {};
			this.config = getSelectorConfig(props, values, this.nameMap);
		}

		var _proto = StructuredSelector.prototype;

		_proto.init = function init(store) {
			store.init(this.config.defaultValues);
		};

		_proto.create = function create() {
			var selector = createSelector(this.config);
			if (selector.memoize) return selector.memoize();
			return selector;
		};

		_proto.createStoreSelector = function createStoreSelector() {
			if (this.config.constant) {
				var result = _objectSpread({}, this.config.constants);

				return function() {
					return result;
				};
			}

			var selector = this.create();
			return function(store) {
				return selector(store.getData());
			};
		};

		return StructuredSelector;
	})();

var VDOM$1 = VDOM;

var VDOM$2 = VDOM$1;
var widgetId = 100;
var Widget =
	/*#__PURE__*/
	(function(_Component) {
		_inheritsLoose(Widget, _Component);

		function Widget(config) {
			var _this;

			_this = _Component.call(this, config) || this;
			_this.widgetId = widgetId++;

			if (isArray(_this.jsxSpread)) {
				if (!_this.jsxAttributes) _this.jsxAttributes = [];

				_this.jsxSpread.forEach(function(spread) {
					for (var key in spread) {
						_this[key] = spread[key];

						_this.jsxAttributes.push(key);
					}
				});
			}

			return _this;
		}

		var _proto = Widget.prototype;

		_proto.init = function init() {
			if (this.styles) this.style = this.styles;
			if (this.styled) this.style = parseStyle(this.style);
			else if (this.style) {
				Console.warn(
					"Components that allow use of the style attribute should set styled = true on their prototype. This will be an error in future versions."
				);
				this.style = parseStyle(this.style);
				this.styled = true;
			}
			if (typeof this.if !== "undefined") this.visible = this.if;
			this.declareData();

			if (this.outerLayout) {
				if (isArray(this.outerLayout)) throw new Error("Only single element outer layout is supported."); //TODO: better handle the case when outer layout is an array. How to get around circular dependency to PureContainer

				this.outerLayout = Widget.create(this.outerLayout);
			}

			if (this.contentFor) this.putInto = this.contentFor;
			if (this.putInto) this.isContent = true;
			if (isString(this.CSS)) this.CSS = CSSHelper.get(this.CSS);
			this.initHelpers();
			this.initComponents();
			this.initialized = true;
		};

		_proto.initComponents = function initComponents() {
			if (arguments.length > 0) {
				this.components = Object.assign.apply(Object, arguments);

				for (var k in this.components) {
					if (!this.components[k]) delete this.components[k];
				}
			}
		};

		_proto.initHelpers = function initHelpers() {
			if (arguments.length > 0) {
				this.helpers = Object.assign.apply(Object, arguments);
			}
		};

		_proto.declareData = function declareData() {
			var options = {};
			if (this.styled)
				options.class = options.className = options.style = {
					structured: true
				};

			var props = _objectSpread(
				{
					visible: undefined,
					mod: {
						structured: true
					}
				},
				options
			);

			Object.assign.apply(Object, [props].concat(Array.prototype.slice.call(arguments)));
			this.selector = new StructuredSelector({
				props: props,
				values: this
			});
			this.nameMap = this.selector.nameMap;
		};

		_proto.prepareCSS = function prepareCSS(context, _ref) {
			var data = _ref.data;
			data.classNames = this.CSS.expand(
				this.CSS.block(this.baseClass, data.mod, data.stateMods),
				data.class,
				data.className
			);
			data.style = parseStyle(data.style);
		};

		_proto.prepareData = function prepareData(context, instance) {
			if (this.styled) this.prepareCSS(context, instance);
		};

		_proto.initInstance = function initInstance(context, instance) {
			if (this.onInit) this.onInit(context, instance);
		};

		_proto.initState = function initState(context, instance) {};

		_proto.checkVisible = function checkVisible(context, instance, data) {
			return data.visible;
		};

		_proto.explore = function explore(context, instance) {
			if (this.components) instance.components = {};

			for (var cmp in this.components) {
				var ins = instance.getChild(context, this.components[cmp], "cmp-" + cmp, instance.store);
				if (ins.scheduleExploreIfVisible(context)) instance.components[cmp] = ins;
			}
		};

		_proto.render = function render(context, instance, key) {
			throw new Error(
				"Widget's render method should be overridden. This error can happen if you forgot to import the component before using it."
			);
		};

		_proto.update = function update() {
			this.version = (this.version || 0) + 1;
		};

		Widget.resetCounter = function resetCounter() {
			widgetId = 100;
		};

		return Widget;
	})(Component);
Widget.prototype.visible = true;
Widget.prototype.memoize = true; //cache rendered content and use it if possible

Widget.prototype.CSS = "cx";
Widget.prototype.styled = false;
Widget.namespace = "ui.";
Widget.optimizePrepare = true;

Widget.factory = function(type, config, more) {
	throw new Error("Invalid widget type: " + type + ".");
};

function contentAppend(result, w, prependSpace) {
	if (w == null || w === false) return false;
	if (isArray(w))
		w.forEach(function(c) {
			return contentAppend(result, c);
		});
	else if (isDefined(w.content) && !w.atomic) return contentAppend(result, w.content);
	else {
		if (prependSpace) result.push(" ");
		result.push(w);
	}
	return true;
}
function getContentArray(x) {
	var result = [];
	contentAppend(result, x);
	return result;
}
function getContent(x) {
	var result = getContentArray(x);
	if (result.length == 0) return null;
	if (result.length == 1) return result[0];
	return result;
}

var StaticText =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(StaticText, _Widget);

		function StaticText() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = StaticText.prototype;

		_proto.render = function render() {
			return this.text;
		};

		return StaticText;
	})(Widget);
Widget.alias("static-text", StaticText);

var Text =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(Text, _Widget);

		function Text() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = Text.prototype;

		_proto.init = function init() {
			if (!this.value && (this.tpl || this.expr || this.bind))
				this.value = {
					tpl: this.tpl,
					expr: this.expr,
					bind: this.bind
				};

			_Widget.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[
					this,
					{
						value: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.render = function render(context, _ref, key) {
			var data = _ref.data;
			return data.value != null ? data.value : "";
		};

		return Text;
	})(Widget);
Widget.alias("text", Text);

function innerTextTrim(str) {
	str = str.replace(/\t/g, "");
	str = str.replace(/(\s*[\r\n]\s*)/g, "");
	return str;
}

function reverseSlice(array, start) {
	var last = array.length - 1;

	while (start < last) {
		var x = array[start];
		array[start] = array[last];
		array[last] = x;
		start++;
		last--;
	}
}

function exploreChildren(context, instance, children, previousResult, key, store, beforeCallback, afterCallback) {
	var newChildren = previousResult || [];
	var oldChildren = previousResult || newChildren;
	var identical = previousResult ? 0 : -1; // if (children.length)
	//    context.exploreStack.hop();

	for (var c = 0; c < children.length; c++) {
		var cell = instance.getChild(context, children[c], key, store); // if (beforeCallback)
		//    beforeCallback(cell);

		if (cell.checkVisible(context)) {
			if (identical >= 0) {
				if (cell == oldChildren[identical]) identical++;
				else {
					newChildren = newChildren.slice(0, identical);
					identical = -1;
					newChildren.push(cell);
				}
			} else newChildren.push(cell);

			context.exploreStack.push(cell);
			if (cell.needsExploreCleanup) context.exploreStack.push(cell);
		}
	}

	if (identical >= 0 && identical != newChildren.length) newChildren = newChildren.slice(0, identical);
	return newChildren;
}

var Container =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(Container, _Widget);

		function Container() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = Container.prototype;

		_proto.init = function init(context) {
			if (typeof this.ws !== "undefined") this.preserveWhitespace = this.ws;
			if (this.preserveWhitespace) this.trimWhitespace = false;
			var items = this.items || this.children || [];
			delete this.children;
			this.items = [];

			if (this.layout) {
				var layout = Widget.create({
					type: this.layout,
					items: items
				});
				layout.init(context);
				this.layout = null;

				if (layout.noLayout) {
					this.useParentLayout = true;
					this.add(items);
				} else {
					this.add(layout);
					this.layout = layout;
				}
			} else {
				this.add(items);
			}

			_Widget.prototype.init.call(this, context);
		};

		_proto.exploreItems = function exploreItems(context, instance, items) {
			instance.children = exploreChildren(context, instance, items, instance.cached.children);
			if (instance.cache("children", instance.children)) instance.markShouldUpdate(context);
		};

		_proto.explore = function explore(context, instance) {
			_Widget.prototype.explore.call(this, context, instance);

			this.exploreItems(context, instance, this.items);
		};

		_proto.render = function render(context, instance) {
			return this.renderChildren(context, instance);
		};

		_proto.renderChildren = function renderChildren(context, instance) {
			var preserveComplexContent = this.useParentLayout;

			function append(result, r) {
				if (r == null) return; //react element

				if (!r.hasOwnProperty("content")) {
					contentAppend(result, r);
					return;
				}

				if (r.useParentLayout)
					return r.content.forEach(function(x) {
						return append(result, x);
					});

				if (r.atomic || preserveComplexContent) {
					result.push(r);
				} else {
					var first = true;

					for (var k in r) {
						if (contentAppend(result, r[k], !first)) first = false;
					}
				}
			}

			var result = [];

			for (var i = 0; i < instance.children.length; i++) {
				append(result, instance.children[i].vdom);
			}

			if (this.useParentLayout)
				return {
					useParentLayout: true,
					content: result
				};
			return result;
		};

		_proto.clear = function clear() {
			if (this.layout) this.layout.clear();
			else this.items = [];
		};

		_proto.add = function add() {
			var _this$layout,
				_this = this;

			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			if (this.layout) return (_this$layout = this.layout).add.apply(_this$layout, args);
			args.forEach(function(a) {
				if (!a) return;
				if (isArray(a))
					a.forEach(function(c) {
						return _this.add(c);
					});
				else if (isString(a)) {
					if (_this.trimWhitespace) a = innerTextTrim(a);
					if (a) _this.addText(a);
				} else if (a.isComponent) _this.items.push(_this.wrapItem(a));
				else {
					_this.add(Widget.create(a, _this.itemDefaults));
				}
			});
		};

		_proto.wrapItem = function wrapItem(item) {
			return item;
		};

		_proto.addText = function addText(text) {
			if (this.plainText || text.indexOf("{") == -1 || text.indexOf("}") == -1)
				this.add(
					Widget.create(StaticText, {
						text: text
					})
				);
			else
				this.add(
					Widget.create(Text, {
						text: {
							tpl: text
						}
					})
				);
		};

		_proto.find = function find(filter, options) {
			if (!options) options = {};
			if (!filter || !this.items) return [];
			var alias = filter;
			if (isString(filter))
				filter = function filter(w) {
					return w.componentAlias == alias;
				};
			if (filter.isComponentType)
				filter = function filter(w) {
					return w instanceof alias;
				};
			var results = [];

			for (var i = 0; i < this.items.length; i++) {
				var w = this.items[i];
				if (!w.initialized) w.init();

				if (filter(w)) {
					results.push(w);
					if (options.first) break;
				}

				if (w.find) results.push.apply(results, w.find(filter, options));
			}

			return results;
		};

		_proto.findFirst = function findFirst(filter, options) {
			return this.find(
				filter,
				_objectSpread({}, options, {
					first: true
				})
			)[0];
		};

		return Container;
	})(Widget);
Container.prototype.trimWhitespace = true;
Container.prototype.plainText = true;
Container.prototype.styled = false;

var PureContainer =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(PureContainer, _Container);

		function PureContainer() {
			return _Container.apply(this, arguments) || this;
		}

		return PureContainer;
	})(Container);
PureContainer.prototype.isPureContainer = true;
PureContainer.alias("pure-container", PureContainer);

var DataAdapter =
	/*#__PURE__*/
	(function(_Component) {
		_inheritsLoose(DataAdapter, _Component);

		function DataAdapter() {
			return _Component.apply(this, arguments) || this;
		}

		var _proto = DataAdapter.prototype;

		_proto.getRecords = function getRecords() {
			throw new Error("Abstract method");
		};

		_proto.setFilter = function setFilter() {};

		_proto.sort = function sort() {};

		return DataAdapter;
	})(Component);
DataAdapter.prototype.recordName = "$record";
DataAdapter.prototype.indexName = "$index";
DataAdapter.prototype.immutable = false;

var ExposedRecordView =
	/*#__PURE__*/
	(function(_View) {
		_inheritsLoose(ExposedRecordView, _View);

		function ExposedRecordView() {
			return _View.apply(this, arguments) || this;
		}

		var _proto = ExposedRecordView.prototype;

		_proto.getData = function getData() {
			if (this.sealed && this.meta.version === this.cache.version && this.cache.itemIndex === this.itemIndex)
				return this.cache.result;
			this.cache.result = this.embed(this.store.getData());
			this.cache.version = this.meta.version;
			this.cache.itemIndex = this.itemIndex;
			return this.cache.result;
		};

		_proto.embed = function embed(data) {
			var collection = this.collectionBinding.value(data);
			var record = collection[this.itemIndex];
			var copy = this.sealed || this.immutable || this.store.sealed ? _objectSpread({}, data) : data;
			copy[this.recordName] = record;
			if (this.indexName) copy[this.indexName] = this.itemIndex;
			return copy;
		};

		_proto.setIndex = function setIndex(index) {
			this.itemIndex = index;
		};

		_proto.setItem = function setItem(path, value) {
			if (path == this.recordName || path.indexOf(this.recordName + ".") == 0) {
				var storeData = this.store.getData();
				var collection = this.collectionBinding.value(storeData);
				var data = this.embed(storeData);
				var d = Binding.get(path).set(data, value);
				if (d === data) return false;
				var record = d[this.recordName];
				var newCollection = [].concat(
					collection.slice(0, this.itemIndex),
					[record],
					collection.slice(this.itemIndex + 1)
				);
				return this.store.setItem(this.collectionBinding.path, newCollection);
			}

			return this.store.setItem(path, value);
		};

		_proto.deleteItem = function deleteItem(path) {
			var storeData, collection, newCollection;

			if (path == this.recordName) {
				storeData = this.store.getData();
				collection = this.collectionBinding.value(storeData);
				newCollection = [].concat(collection.slice(0, this.itemIndex), collection.slice(this.itemIndex + 1));
				return this.store.setItem(this.collectionBinding.path, newCollection);
			} else if (path.indexOf(this.recordName + ".") == 0) {
				storeData = this.store.getData();
				collection = this.collectionBinding.value(storeData);
				var data = this.embed(storeData);
				var d = Binding.get(path).delete(data);
				if (d === data) return false;
				var record = d[this.recordName];
				newCollection = [].concat(collection.slice(0, this.itemIndex), [record], collection.slice(this.itemIndex + 1));
				return this.store.setItem(this.collectionBinding.path, newCollection);
			}

			return this.store.deleteItem(path);
		};

		return ExposedRecordView;
	})(View);
ExposedRecordView.prototype.immutable = false;

var ReadOnlyDataView =
	/*#__PURE__*/
	(function(_View) {
		_inheritsLoose(ReadOnlyDataView, _View);

		function ReadOnlyDataView() {
			return _View.apply(this, arguments) || this;
		}

		var _proto = ReadOnlyDataView.prototype;

		_proto.getData = function getData() {
			if (this.sealed && this.meta.version === this.cache.version && this.cache.data === this.data)
				return this.cache.result;
			var data = this.store.getData();
			this.cache.result =
				this.sealed || this.immutable || this.store.sealed
					? Object.assign({}, data, this.getAdditionalData(data))
					: Object.assign(data, this.getAdditionalData(data));
			this.cache.version = this.meta.version;
			this.cache.data = this.data;
			return this.cache.result;
		};

		_proto.getAdditionalData = function getAdditionalData() {
			return this.data;
		};

		_proto.setData = function setData(data) {
			this.data = data;
		};

		return ReadOnlyDataView;
	})(View);
ReadOnlyDataView.prototype.immutable = false;

function getComparer(sorters, dataAccessor) {
	var data = (sorters || []).map(function(s) {
		var selector = isDefined(s.value)
			? getSelector(s.value)
			: s.field
				? function(x) {
						return x[s.field];
					}
				: function() {
						return null;
					};
		return {
			getter: dataAccessor
				? function(x) {
						return selector(dataAccessor(x));
					}
				: selector,
			factor: s.direction && s.direction[0].toLowerCase() == "d" ? -1 : 1
		};
	});
	return function(a, b) {
		var d, av, bv;

		for (var i = 0; i < data.length; i++) {
			d = data[i];
			av = d.getter(a);
			bv = d.getter(b);

			if (av == null) {
				if (bv == null) return 0;
				return -d.factor;
			} else {
				if (bv == null) return d.factor;
				if (av < bv) return -d.factor;
				if (av > bv) return d.factor;
			}
		}

		return 0;
	};
}
function sorter(sorters, dataAccessor) {
	var cmp = getComparer(sorters, dataAccessor);
	return function(data) {
		var result = [].concat(data);
		result.sort(cmp);
		return result;
	};
}

var ArrayAdapter =
	/*#__PURE__*/
	(function(_DataAdapter) {
		_inheritsLoose(ArrayAdapter, _DataAdapter);

		function ArrayAdapter() {
			return _DataAdapter.apply(this, arguments) || this;
		}

		var _proto = ArrayAdapter.prototype;

		_proto.initInstance = function initInstance(context, instance) {
			if (!instance.recordStoreCache) instance.recordStoreCache = new WeakMap();
		};

		_proto.getRecords = function getRecords(context, instance, records, parentStore) {
			return this.mapRecords(context, instance, records, parentStore, this.recordsBinding);
		};

		_proto.mapRecords = function mapRecords(context, instance, records, parentStore, recordsBinding) {
			var _this = this;

			var result = [];
			if (!instance.recordStoreCache) this.initInstance(context, instance);
			if (isArray(records))
				records.forEach(function(data, index) {
					if (_this.filterFn && !_this.filterFn(data)) return;

					var record = _this.mapRecord(context, instance, data, parentStore, recordsBinding, index);

					result.push(record);
				});
			if (this.sorter) result = this.sorter(result);
			return result;
		};

		_proto.mapRecord = function mapRecord(context, instance, data, parentStore, recordsBinding, index) {
			var recordStore = instance.recordStoreCache.get(data);
			var writable = parentStore && recordsBinding;

			if (writable) {
				if (!recordStore)
					recordStore = new ExposedRecordView({
						store: parentStore,
						collectionBinding: recordsBinding,
						itemIndex: index,
						recordName: this.recordName,
						indexName: this.indexName,
						immutable: this.immutable,
						sealed: this.sealed
					});
				else {
					recordStore.setStore(parentStore);
					recordStore.setIndex(index);
				}
			} else {
				var _data;

				if (!recordStore)
					recordStore = new ReadOnlyDataView({
						store: parentStore,
						data: ((_data = {}), (_data[this.recordName] = data), (_data[this.indexName] = index), _data),
						immutable: this.immutable,
						sealed: this.sealed
					});
				else {
					recordStore.setStore(parentStore);
				}
			}

			if (typeof data == "object") instance.recordStoreCache.set(data, recordStore);
			return {
				store: recordStore,
				index: index,
				data: data,
				type: "data",
				key: this.keyField ? data[this.keyField] : index
			};
		};

		_proto.setFilter = function setFilter(filterFn) {
			this.filterFn = filterFn;
		};

		_proto.buildSorter = function buildSorter(sorters) {
			var _this2 = this;

			if (isArray(sorters) && sorters.length > 0) {
				if (
					sorters.every(function(x) {
						return x.field && x.value == null;
					})
				) {
					//if all sorters are based on record fields access data directly (faster)
					this.sorter = sorter(
						sorters.map(function(x) {
							if (x.field)
								return {
									value: {
										bind: x.field
									},
									direction: x.direction
								};
							return x;
						}),
						function(x) {
							return x.data;
						}
					);
				} else {
					//if some sorters use computed values, use store data object
					this.sorter = sorter(
						sorters.map(function(x) {
							if (x.field && x.value == null)
								return {
									value: {
										bind: _this2.recordName + "." + x.field
									},
									direction: x.direction
								};
							return x;
						}),
						function(x) {
							return x.store.getData();
						}
					);
				}
			} else {
				this.sorter = null;
			}
		};

		_proto.sort = function sort(sorters) {
			this.buildSorter(sorters);
		};

		return ArrayAdapter;
	})(DataAdapter);
ArrayAdapter.prototype.immutable = false;
ArrayAdapter.prototype.sealed = false;

var UseParentLayout =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(UseParentLayout, _PureContainer);

		function UseParentLayout() {
			return _PureContainer.apply(this, arguments) || this;
		}

		return UseParentLayout;
	})(PureContainer);
UseParentLayout.prototype.noLayout = true;
UseParentLayout.prototype.useParentLayout = true;

var Repeater =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(Repeater, _Container);

		function Repeater() {
			return _Container.apply(this, arguments) || this;
		}

		var _proto = Repeater.prototype;

		_proto.declareData = function declareData() {
			var _Container$prototype$;

			(_Container$prototype$ = _Container.prototype.declareData).call.apply(
				_Container$prototype$,
				[
					this,
					{
						records: undefined,
						sorters: undefined,
						sortField: undefined,
						sortDirection: undefined,
						filterParams: {
							structured: true
						}
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.init = function init() {
			if (isBinding(this.records)) this.recordsBinding = Binding.get(this.records.bind);
			if (this.recordAlias) this.recordName = this.recordAlias;
			if (this.indexAlias) this.indexName = this.indexAlias;
			this.dataAdapter = ArrayAdapter.create(
				_objectSpread({}, this.dataAdapter, {
					recordName: this.recordName,
					indexName: this.indexName,
					keyField: this.keyField,
					immutable: this.immutable,
					sealed: this.sealed
				})
			);
			this.item = PureContainer.create({
				children: this.items || this.children,
				layout: UseParentLayout
			});
			delete this.children;
			delete this.items;

			_Container.prototype.init.call(this);
		};

		_proto.initInstance = function initInstance(context, instance) {
			this.dataAdapter.initInstance(context, instance);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var _this = this;

			var data = instance.data;
			if (data.sortField)
				data.sorters = [
					{
						field: data.sortField,
						direction: data.sortDirection || "ASC"
					}
				];
			this.dataAdapter.sort(data.sorters);
			var filter = null;
			if (this.onCreateFilter) filter = instance.invoke("onCreateFilter", data.filterParams, instance);
			else if (this.filter)
				filter = function filter(item) {
					return _this.filter(item, data.filterParams);
				};
			this.dataAdapter.setFilter(filter);
			instance.mappedRecords = this.dataAdapter.mapRecords(
				context,
				instance,
				data.records,
				instance.store,
				this.recordsBinding
			);

			_Container.prototype.prepareData.call(this, context, instance);
		};

		_proto.explore = function explore(context, instance, data) {
			var _this2 = this;

			var instances = [];
			instance.mappedRecords.forEach(function(record) {
				var subInstance = instance.getChild(context, _this2.item, record.key, record.store);
				var changed = subInstance.cache("recordData", record.data) || subInstance.cache("key", record.key);
				subInstance.record = record;

				if (_this2.cached && !changed && subInstance.visible && !subInstance.childStateDirty) {
					instances.push(subInstance);
					subInstance.shouldUpdate = false;
				} else if (subInstance.scheduleExploreIfVisible(context)) instances.push(subInstance);
			});
			instance.children = instances;
		};

		return Repeater;
	})(Container);
Repeater.prototype.recordName = "$record";
Repeater.prototype.indexName = "$index";
Repeater.prototype.cached = false;
Repeater.prototype.immutable = false;
Repeater.prototype.sealed = false;
Repeater.prototype.isPureContainer = true;
Widget.alias("repeater", Repeater);

var ZoomIntoPropertyView =
	/*#__PURE__*/
	(function(_View) {
		_inheritsLoose(ZoomIntoPropertyView, _View);

		function ZoomIntoPropertyView() {
			return _View.apply(this, arguments) || this;
		}

		var _proto = ZoomIntoPropertyView.prototype;

		_proto.getData = function getData() {
			if (this.cache.version != this.meta.version) {
				var _objectSpread2;

				var data = this.store.getData();
				var x = this.binding.value(data);
				if (x != null && typeof x != "object") throw new Error("Zoomed value must be an object.");
				this.cache.result = _objectSpread(
					{},
					x,
					((_objectSpread2 = {}),
					(_objectSpread2[this.rootName] = !this.store.sealed ? _objectSpread({}, data) : data),
					_objectSpread2)
				);
				this.cache.version = this.meta.version;
			}

			return this.cache.result;
		};

		_proto.setItem = function setItem(path, value) {
			if (path.indexOf(this.rootName + ".") == 0) this.store.setItem(path.substring(this.rootName.length + 1), value);
			else this.store.setItem(this.binding.path + "." + path, value);
		};

		_proto.deleteItem = function deleteItem(path) {
			if (path instanceof Binding) path = path.path;
			if (path.indexOf(this.rootName + ".") == 0) this.store.deleteItem(path.substring(this.rootName.length + 1));
			else this.store.deleteItem(this.binding.path + "." + path);
		};

		return ZoomIntoPropertyView;
	})(View);
ZoomIntoPropertyView.prototype.rootName = "$root";

var Rescope =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(Rescope, _PureContainer);

		function Rescope() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = Rescope.prototype;

		_proto.init = function init() {
			this.binding = Binding.get(this.bind);
			if (this.rootAlias) this.rootName = this.rootAlias;

			_PureContainer.prototype.init.call(this);
		};

		_proto.initInstance = function initInstance(context, instance) {
			instance.store = new ZoomIntoPropertyView({
				store: instance.store,
				binding: this.binding,
				rootName: this.rootName
			});

			instance.setStore = function(store) {
				instance.store.setStore(store);
			};
		};

		return Rescope;
	})(PureContainer);
Rescope.prototype.bind = "$page";
Rescope.prototype.rootName = "$root";
Widget.alias("rescope", Rescope);

function findFirst(el, condition) {
	if (condition(el)) return el;
	var children = el.childNodes;
	if (children)
		for (var i = 0; i < children.length; i++) {
			var child = findFirst(children[i], condition);
			if (child) return child;
		}
	return null;
}
function findFirstChild(el, condition) {
	var children = el.childNodes;
	if (children)
		for (var i = 0; i < children.length; i++) {
			var child = findFirst(children[i], condition);
			if (child) return child;
		}
	return null;
}
function closest(el, condition) {
	while (el) {
		if (condition(el)) return el;
		el = el.parentNode;
	}

	return null;
}
function closestParent(el, condition) {
	return el && closest(el.parentNode, condition);
}
var focusableWithoutTabIndex = ["INPUT", "SELECT", "TEXTAREA", "A", "BUTTON"];
function isFocusable(el) {
	var firstPass = el && isNumber(el.tabIndex) && el.tabIndex >= 0;
	if (!firstPass) return false;
	if (focusableWithoutTabIndex.indexOf(el.tagName) != -1 && !el.hasAttribute("disabled")) return true;
	return el.hasAttribute("tabindex");
}
function isSelfOrDescendant(el, descEl) {
	return el == descEl || el.contains(descEl);
}

var SubscriberList =
	/*#__PURE__*/
	(function() {
		function SubscriberList() {
			this.clear();
		}

		var _proto = SubscriberList.prototype;

		_proto.getSlot = function getSlot() {
			if (this.freeSlots.length) return this.freeSlots.pop();
			var slot = String(this.nextSlot++);
			return slot;
		};

		_proto.recycle = function recycle(slot, callback) {
			if (this.subscriptions[slot] === callback) {
				this.freeSlots.push(slot);
				delete this.subscriptions[slot];
				this.subscriptionCount--;
			}
		};

		_proto.subscribe = function subscribe(callback) {
			var _this = this;

			var slot = this.getSlot();
			this.subscriptions[slot] = callback;
			this.subscriptionCount++;
			return function() {
				_this.recycle(slot, callback);
			};
		};

		_proto.clear = function clear() {
			this.subscriptions = {};
			this.freeSlots = [];
			this.nextSlot = 1;
			this.subscriptionCount = 0;
		};

		_proto.isEmpty = function isEmpty() {
			return this.subscriptionCount == 0;
		};

		_proto.getSubscribers = function getSubscribers() {
			var result = [];

			for (var key in this.subscriptions) {
				result.push(this.subscriptions[key]);
			}

			return result;
		};

		_proto.notify = function notify() {
			for (var key in this.subscriptions) {
				var _this$subscriptions;

				(_this$subscriptions = this.subscriptions)[key].apply(_this$subscriptions, arguments);
			}
		};

		_proto.execute = function execute(callback) {
			for (var key in this.subscriptions) {
				callback(this.subscriptions[key]);
			}
		};

		return SubscriberList;
	})();

var isBatching = 0;
var promiseSubscribers = new SubscriberList();
function batchUpdates(callback) {
	if (VDOM$2.DOM.unstable_batchedUpdates)
		VDOM$2.DOM.unstable_batchedUpdates(function() {
			isBatching++;

			try {
				callback();
			} finally {
				isBatching--;
			}
		});
	else callback();
}
function isBatchingUpdates() {
	return isBatching > 0;
}
function notifyBatchedUpdateStarting() {
	promiseSubscribers.execute(function(x) {
		x.pending++;
	});
}
function notifyBatchedUpdateCompleted() {
	promiseSubscribers.execute(function(x) {
		x.finished++;
		if (x.finished >= x.pending) x.complete(true);
	});
}
var updateId = 0;
function batchUpdatesAndNotify(callback, notifyCallback, timeout) {
	if (timeout === void 0) {
		timeout = 1000;
	}

	var update = {
		id: ++updateId,
		pending: 0,
		finished: 0,
		done: false
	};
	update.unsubscribe = promiseSubscribers.subscribe(update);

	update.complete = function(success) {
		if (!update.done) {
			update.done = true;
			if (update.timer) clearInterval(update.timer);
			update.unsubscribe();
			notifyCallback(!!success);
		}
	};

	batchUpdates(callback);
	if (update.pending <= update.finished) update.complete(true);
	else update.timer = setTimeout(update.complete, timeout);
}

var passiveEventsSupported = null;
function browserSupportsPassiveEventHandlers() {
	if (passiveEventsSupported == null) {
		try {
			passiveEventsSupported = false;
			var options = Object.defineProperty({}, "passive", {
				get: function get() {
					passiveEventsSupported = true;
				}
			});
			window.addEventListener("test", null, options);
		} catch (e) {}
	}

	return passiveEventsSupported;
}

var isTouch = null;
function isTouchDevice() {
	if (isTouch == null) isTouch = typeof window != "undefined" && "ontouchstart" in window;
	return isTouch;
}

var lastTouchEvent = 0;
var isTouchDetectionEnabled = false;
function enableTouchEventDetection() {
	if (isTouchDevice() && !isTouchDetectionEnabled) {
		var options;
		if (browserSupportsPassiveEventHandlers())
			options = {
				passive: true
			};
		document.addEventListener(
			"touchstart",
			function() {
				lastTouchEvent = new Date().getTime();
			},
			options
		);
		document.addEventListener(
			"touchmove",
			function() {
				//console.log('TOUCHMOVE');
				lastTouchEvent = new Date().getTime();
			},
			options
		);
		document.addEventListener(
			"touchend",
			function() {
				lastTouchEvent = new Date().getTime(); //console.log('TOUCHEND');
			},
			options
		);
		isTouchDetectionEnabled = true;
	}
}
function isTouchEvent() {
	return isTouchDevice() && (!isTouchDetectionEnabled || new Date().getTime() - lastTouchEvent < 1000);
} //enable touch event detection if there is no performance penalty on scrolling

if (isTouchDevice() && browserSupportsPassiveEventHandlers()) enableTouchEventDetection();

//IE sometimes returns null while other browsers always return document.body.
function getActiveElement() {
	return document.activeElement || document.body;
}

/*
*  Purpose of FocusManager is to provide focusout notifications.
*  IE and Firefox do not provide relatedTarget info in blur events which makes it impossible
*  to determine if focus went outside or stayed inside the component.
*/

var subscribers = new SubscriberList(),
	timerInterval = 300,
	timerId = null;
var lastActiveElement = null;
var pending = false;
var FocusManager =
	/*#__PURE__*/
	(function() {
		function FocusManager() {}

		FocusManager.subscribe = function subscribe(callback) {
			var unsubscribe = subscribers.subscribe(callback);
			checkTimer();
			return unsubscribe;
		};

		FocusManager.onFocusOut = function onFocusOut(el, callback) {
			var active = isSelfOrDescendant(el, getActiveElement());
			return this.subscribe(function(focusedEl) {
				if (!active) active = isSelfOrDescendant(el, getActiveElement());
				else if (!isSelfOrDescendant(el, focusedEl)) {
					active = false;
					callback(focusedEl);
				}
			});
		};

		FocusManager.oneFocusOut = function oneFocusOut(el, callback) {
			this.nudge();
			var off = this.subscribe(function(focusedEl) {
				if (!isSelfOrDescendant(el, focusedEl)) {
					callback(focusedEl);
					off();
				}
			});
			return off;
		};

		FocusManager.nudge = function nudge() {
			if (typeof document !== "undefined" && getActiveElement() !== lastActiveElement) {
				if (!pending) {
					pending = true;
					setTimeout(function() {
						pending = false;

						if (getActiveElement() !== lastActiveElement) {
							lastActiveElement = getActiveElement();
							batchUpdates(function() {
								subscribers.notify(lastActiveElement);
							});
							checkTimer();
						}
					}, 0);
				}
			}
		};

		FocusManager.focus = function focus(el) {
			el.focus();
			this.nudge();
		};

		FocusManager.focusFirst = function focusFirst(el) {
			var focusable = findFirst(el, isFocusable);
			if (focusable) this.focus(focusable);
			return focusable;
		};

		FocusManager.focusFirstChild = function focusFirstChild(el) {
			var focusable = findFirstChild(el, isFocusable);
			if (focusable) this.focus(focusable);
			return focusable;
		};

		FocusManager.focusNext = function focusNext(el) {
			var next = el,
				skip = true;

			do {
				if (!skip) {
					var focusable = this.focusFirst(next);
					if (focusable) return focusable;
				}

				if (next.nextSibling) {
					next = next.nextSibling;
					skip = false;
				} else {
					next = next.parentNode;
					skip = true;
				}
			} while (next);
		};

		FocusManager.setInterval = function setInterval(interval) {
			timerInterval = interval;
			checkTimer();
		};

		return FocusManager;
	})();
function oneFocusOut(component, el, callback) {
	if (!component.oneFocusOut)
		component.oneFocusOut = FocusManager.oneFocusOut(el, function(focus) {
			delete component.oneFocusOut;
			callback(focus);
		});
}
function offFocusOut(component) {
	if (component.oneFocusOut) {
		component.oneFocusOut();
		delete component.oneFocusOut;
	}
}
function preventFocus(e) {
	//Focus can be prevented only on mousedown event. On touchstart should not call
	//preventDefault as it prevents scrolling
	if (e.type !== "mousedown") return;
	e.preventDefault(); //unfocus activeElement

	var activeElement = getActiveElement();

	if (e.currentTarget !== activeElement && !activeElement.contains(e.currentTarget)) {
		//force field validation on outside click, however, preserve active window or dropdown menu
		var focusableParent = closestParent(activeElement, isFocusable) || document.body;
		if (focusableParent === document.body) activeElement.blur();
		else focusableParent.focus();
		FocusManager.nudge();
	}
}

function checkTimer() {
	var shouldRun = !subscribers.isEmpty();
	if (shouldRun && !timerId)
		timerId = setInterval(function() {
			FocusManager.nudge();
		}, timerInterval);

	if (!shouldRun && timerId) {
		clearInterval(timerId);
		timerId = null;
	}
}

function preventFocusOnTouch(e, force) {
	if (force === void 0) {
		force = false;
	}

	if (force || isTouchEvent()) preventFocus(e);
}

var subscribers$1 = new SubscriberList();
var ResizeManager =
	/*#__PURE__*/
	(function() {
		function ResizeManager() {}

		ResizeManager.subscribe = function subscribe(callback) {
			return subscribers$1.subscribe(callback);
		};

		ResizeManager.notify = function notify() {
			batchUpdates(function() {
				subscribers$1.notify();
			});
		};

		ResizeManager.trackElement = function trackElement(el, callback) {
			if (typeof ResizeObserver !== "function") return this.subscribe(callback);
			var obs = new ResizeObserver(callback);
			obs.observe(el);
			return function() {
				obs.disconnect();
			};
		};

		return ResizeManager;
	})();
if (typeof window != "undefined")
	window.addEventListener("resize", function() {
		return ResizeManager.notify();
	});

var lastZIndex = 10000;
var ZIndexManager =
	/*#__PURE__*/
	(function() {
		function ZIndexManager() {}

		ZIndexManager.next = function next() {
			return ++lastZIndex;
		};

		ZIndexManager.reset = function reset(zIndex) {
			lastZIndex = zIndex;
		};

		return ZIndexManager;
	})();

var contents = {};
var localizations = {};
var overrides = {};
var defaults = {};
var _trackDefaults = false;
var Localization =
	/*#__PURE__*/
	(function() {
		function Localization() {}

		Localization.register = function register(key) {
			var _this = this;

			return function(type) {
				_this.registerPrototype(key, type);

				return type;
			};
		};

		Localization.registerPrototype = function registerPrototype(key, type) {
			contents[key] = type.prototype;
			if (overrides[key]) this.override(key, overrides[key]);
		};

		Localization.trackDefaults = function trackDefaults() {
			_trackDefaults = true;
		};

		Localization.restoreDefaults = function restoreDefaults() {
			for (var type in defaults) {
				var proto = contents[type];
				if (!proto) continue;
				var d = defaults[type];

				for (var key in d) {
					proto[key] = d[key];
				}
			}

			defaults = {};
		};

		Localization.override = function override(key, values) {
			overrides[key] = values;
			var p = contents[key];

			if (p) {
				if (_trackDefaults && !defaults[key]) {
					var d = (defaults[key] = {});

					for (var _key in values) {
						d[_key] = p[_key];
					}
				}

				Object.assign(p, values);
			}
		};

		Localization.localize = function localize(culture, key, values) {
			var l = localizations[culture];
			if (!l) l = localizations[culture] = {};
			l[key] = _objectSpread({}, l[key], values);
		};

		Localization.setCulture = function setCulture(culture) {
			var l = localizations[culture];

			if (l) {
				for (var key in l) {
					var content = contents[key];
					if (content) Object.assign(content, l[key]);
				}
			}
		};

		return Localization;
	})();

var culture = "en";
var cultureCache = {};
var defaultCurrency = "USD";

var dateEncoding = function dateEncoding(date) {
	return date.toISOString();
};

var Culture =
	/*#__PURE__*/
	(function() {
		function Culture() {}

		Culture.setCulture = function setCulture(cultureCode) {
			culture = cultureCode;
			cultureCache = {};
			Localization.setCulture(cultureCode);
			this.invalidateCache();
		};

		Culture.setDefaultCurrency = function setDefaultCurrency(currencyCode) {
			defaultCurrency = currencyCode;
			this.invalidateCache();
		};

		Culture.invalidateCache = function invalidateCache() {
			GlobalCacheIdentifier.change();
			invalidateExpressionCache();
			invalidateStringTemplateCache();
		};

		Culture.getNumberCulture = function getNumberCulture() {
			if (!cultureCache.numberCulture) cultureCache.numberCulture = new NumberCulture(culture);
			return cultureCache.numberCulture;
		};

		Culture.getDateTimeCulture = function getDateTimeCulture() {
			if (!cultureCache.dateCulture) cultureCache.dateCulture = new DateTimeCulture(culture);
			return cultureCache.dateCulture;
		};

		Culture.getDefaultDateEncoding = function getDefaultDateEncoding() {
			return dateEncoding;
		};

		Culture.setDefaultDateEncoding = function setDefaultDateEncoding(encoding) {
			dateEncoding = encoding;
		};

		_createClass(Culture, null, [
			{
				key: "defaultCurrency",
				get: function get() {
					return defaultCurrency;
				}
			},
			{
				key: "culture",
				get: function get() {
					return culture;
				}
			}
		]);

		return Culture;
	})();

var Format$1 = Format;
var cultureSensitiveFormatsRegistered = false;
function enableCultureSensitiveFormatting() {
	if (cultureSensitiveFormatsRegistered) return;
	cultureSensitiveFormatsRegistered = true;
	Format.registerFactory(["number", "n"], function(format, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();
		var formatter = culture.getFormatter(resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits));
		return function(value) {
			return formatter.format(value);
		};
	});
	Format.registerFactory("currency", function(format, currency, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();
		currency = currency || Culture.defaultCurrency;
		var formatter = culture.getFormatter(
			_objectSpread(
				{
					style: "currency",
					currency: currency
				},
				resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits)
			)
		);
		return function(value) {
			return formatter.format(value);
		};
	});
	Format.registerFactory(["percentage", "p", "%"], function(format, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();
		var formatter = culture.getFormatter(
			_objectSpread(
				{
					style: "percent"
				},
				resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits)
			)
		);
		return function(value) {
			return formatter.format(value);
		};
	});
	Format.registerFactory(["percentSign", "ps"], function(format, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();
		var formatter = culture.getFormatter(
			_objectSpread(
				{
					style: "percent"
				},
				resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits)
			)
		);
		return function(value) {
			return formatter.format(value / 100);
		};
	});
	Format.registerFactory(["date", "d"], function() {
		var culture = Culture.getDateTimeCulture();
		var formatter = culture.getFormatter();
		return function(value) {
			return formatter.format(new Date(value));
		};
	});
	Format.registerFactory(["time", "t"], function() {
		var culture = Culture.getDateTimeCulture();
		var formatter = culture.getFormatter({
			hour: "numeric",
			minute: "numeric",
			second: "numeric"
		});
		return function(value) {
			return formatter.format(new Date(value));
		};
	});
	Format.registerFactory(["datetime", "dt"], function(fmt, format) {
		if (format === void 0) {
			format = "yyyyMd hhmm";
		}

		var culture = Culture.getDateTimeCulture();
		var formatter = culture.getFormatter(format);
		return function(value) {
			return formatter.format(new Date(value));
		};
	});
	GlobalCacheIdentifier.change();
}

function throttle(callback, delay) {
	var timer, context, args;
	return function() {
		context = this;
		args = arguments;
		if (!timer)
			timer = setTimeout(function() {
				callback.apply(context, args);
				timer = null;
			}, delay);
	};
}

function debounce(callback, delay) {
	var timer;
	return function() {
		var context = this,
			args = arguments;
		clearTimeout(timer);
		timer = setTimeout(function() {
			callback.apply(context, args);
		}, delay);
	};
}

function isNonEmptyArray(x) {
	return Array.isArray(x) && x.length > 0;
}

var instanceId = 1000;
var Instance =
	/*#__PURE__*/
	(function() {
		function Instance(widget, key, parent, store) {
			this.widget = widget;
			this.key = key;
			this.id = String(++instanceId);
			this.cached = {};
			this.parent = parent;
			this.store = store;
		}

		var _proto = Instance.prototype;

		_proto.setStore = function setStore(store) {
			this.store = store;
		};

		_proto.init = function init(context) {
			//widget is initialized when first instance is initialized
			if (!this.widget.initialized) {
				this.widget.init(context);
				this.widget.initialized = true;
			}

			if (!this.dataSelector) {
				this.widget.selector.init(this.store);
				this.dataSelector = this.widget.selector.createStoreSelector();
			} //init instance might change the store, so it must go before the controller

			this.widget.initInstance(context, this);
			this.widget.initState(context, this);
			if (this.widget.controller)
				this.controller = Controller.create(this.widget.controller, {
					widget: this.widget,
					instance: this,
					store: this.store
				});
			if (
				this.widget.exploreCleanup ||
				this.widget.outerLayout ||
				this.widget.isContent ||
				this.widget.controller ||
				this.widget.prepareCleanup
			)
				this.needsExploreCleanup = true;
			if (this.widget.prepare || this.widget.controller) this.needsPrepare = true;
			if (this.widget.cleanup || this.widget.controller) this.needsCleanup = true;
			this.initialized = true;
		};

		_proto.checkVisible = function checkVisible(context) {
			if (!this.initialized) this.init(context);
			var wasVisible = this.visible;
			this.rawData = this.dataSelector(this.store);
			this.visible = this.widget.checkVisible(context, this, this.rawData);
			this.explored = false;
			this.prepared = false;
			if (!this.visible && wasVisible) this.destroy();
			return this.visible;
		};

		_proto.scheduleExploreIfVisible = function scheduleExploreIfVisible(context) {
			if (this.checkVisible(context)) {
				context.exploreStack.push(this);
				if (this.needsExploreCleanup) context.exploreStack.push(this);
				return true;
			}

			return false;
		};

		_proto.cache = function cache(key, value) {
			var oldValue = this.cached[key];
			if (oldValue === value) return false;
			if (!this.cacheList) this.cacheList = {};
			this.cacheList[key] = value;
			return true;
		};

		_proto.markShouldUpdate = function markShouldUpdate(context) {
			var ins = this;
			var renderList = this.renderList;
			renderList.markReverseIndex(); //notify all parents that child state changed to bust up caching

			while (ins && !ins.shouldUpdate && ins.explored) {
				if (ins.renderList !== renderList) {
					renderList.reverse();
					renderList = ins.renderList;
					renderList.markReverseIndex();
				}

				ins.shouldUpdate = true;
				renderList.data.push(ins);
				ins = ins.widget.isContent
					? ins.contentPlaceholder
					: ins.parent.outerLayout === ins ? ins.parent.parent : ins.parent;
			}

			renderList.reverse();
		};

		_proto.explore = function explore(context) {
			if (!this.visible) throw new Error("Explore invisible!");

			if (this.explored) {
				if (this.widget.prepareCleanup) context.prepareList.push(this);
				if (this.widget.exploreCleanup) this.widget.exploreCleanup(context, this);
				if (this.parent.outerLayout === this) context.popNamedValue("content", "body");
				if (this.widget.controller) context.pop("controller");
				return;
			}

			this.explored = true;
			if (this.needsPrepare) context.prepareList.push(this);
			else this.prepared = true;
			if (this.needsCleanup) context.cleanupList.push(this);
			if (this.instanceCache) this.instanceCache.mark(); //controller may reconfigure the widget and need to go before shouldUpdate calculation

			this.parentOptions = context.parentOptions;

			if (!this.controller) {
				if (context.controller) this.controller = context.controller;
				else if (this.parent.controller) this.controller = this.parent.controller;
			}

			this.destroyTracked = false;

			if (this.controller) {
				if (this.widget.controller) {
					if (!this.controller.initialized) {
						this.controller.init(context);
						this.controller.initialized = true;
					}

					context.push("controller", this.controller);
					this.controller.explore(context);
					if (this.controller.onDestroy && this.controller.widget == this.widget) this.trackDestroy();
				}
			}

			if (this.widget.onDestroy || isNonEmptyArray(this.destroySubscriptions)) this.trackDestroy();
			this.renderList = this.assignedRenderList || this.parent.renderList || context.getRootRenderList();
			var shouldUpdate =
				this.rawData !== this.cached.rawData ||
				this.state !== this.cached.state ||
				this.widget.version !== this.cached.widgetVersion ||
				this.cached.globalCacheIdentifier !== GlobalCacheIdentifier.get();

			if (shouldUpdate) {
				this.data = _objectSpread({}, this.rawData);
				this.widget.prepareData(context, this);
				debug(processDataFlag, this.widget);
			} //onExplore might set the outer layout

			if (this.widget.onExplore) this.widget.onExplore(context, this);

			if (this.parent.outerLayout === this) {
				this.renderList = this.renderList.insertRight();
				context.pushNamedValue("content", "body", this.parent);
			}

			if (this.widget.outerLayout) {
				this.outerLayout = this.getChild(context, this.widget.outerLayout, null, this.store);
				this.outerLayout.scheduleExploreIfVisible(context);
				this.renderList = this.renderList.insertLeft();
			}

			if (this.widget.isContent) {
				this.contentPlaceholder = context.contentPlaceholder && context.contentPlaceholder[this.widget.putInto];
				if (this.contentPlaceholder) context.contentPlaceholder[this.widget.putInto](this);
				else {
					context.pushNamedValue("content", this.widget.putInto, this);
				}
			}

			this.shouldUpdate = false;
			if (shouldUpdate || this.childStateDirty || !this.widget.memoize) this.markShouldUpdate(context);
			context.exploreStack.hop();

			if (this.widget.helpers) {
				this.helpers = {};

				for (var cmp in this.widget.helpers) {
					var helper = this.widget.helpers[cmp];

					if (helper) {
						var ins = this.getChild(context, helper);
						if (ins.scheduleExploreIfVisible(context)) this.helpers[cmp] = ins;
					}
				}
			}

			this.widget.explore(context, this, this.data);
		};

		_proto.prepare = function prepare(context) {
			if (!this.visible) throw new Error("Prepare invisible!");

			if (this.prepared) {
				if (this.widget.prepareCleanup) this.widget.prepareCleanup(context, this);
				return;
			}

			this.prepared = true;
			if (this.widget.prepare) this.widget.prepare(context, this);
			if (this.widget.controller && this.controller.prepare) this.controller.prepare(context);
		};

		_proto.render = function render(context) {
			if (!this.visible) throw new Error("Render invisible!");

			if (this.shouldUpdate) {
				debug(renderFlag, this.widget, this.key);
				var vdom = renderResultFix(this.widget.render(context, this, this.key));
				if (this.widget.isContent || this.outerLayout) this.contentVDOM = vdom;
				else this.vdom = vdom;
			}

			if (this.cacheList)
				for (var key in this.cacheList) {
					this.cached[key] = this.cacheList[key];
				}
			this.cacheList = null;
			this.cached.rawData = this.rawData;
			this.cached.data = this.data;
			this.cached.state = this.state;
			this.cached.widgetVersion = this.widget.version;
			this.cached.globalCacheIdentifier = GlobalCacheIdentifier.get();
			this.childStateDirty = false;
			if (this.instanceCache) this.instanceCache.sweep();

			if (this.parent.outerLayout === this) {
				//if outer layouts are chained we need to find the originating element (last element with OL set)
				var parent = this.parent;

				while (parent.parent.outerLayout == parent) {
					parent = parent.parent;
				}

				parent.vdom = this.vdom;
			}

			return this.vdom;
		};

		_proto.cleanup = function cleanup(context) {
			if (this.widget.controller && this.controller.cleanup) this.controller.cleanup(context);
			if (this.widget.cleanup) this.widget.cleanup(context, this);
		};

		_proto.trackDestroy = function trackDestroy() {
			if (!this.destroyTracked) {
				this.destroyTracked = true;
				if (this.parent && !this.detached) this.parent.trackDestroyableChild(this);
			}
		};

		_proto.trackDestroyableChild = function trackDestroyableChild(child) {
			this.instanceCache.trackDestroy(child);
			this.trackDestroy();
		};

		_proto.subscribeOnDestroy = function subscribeOnDestroy(callback) {
			var _this = this;

			if (!this.destroySubscriptions) this.destroySubscriptions = [];
			this.destroySubscriptions.push(callback);
			this.trackDestroy();
			return function() {
				_this.destroySubscriptions &&
					_this.destroySubscriptions.filter(function(cb) {
						return cb != callback;
					});
			};
		};

		_proto.destroy = function destroy() {
			if (this.instanceCache) {
				this.instanceCache.destroy();
				delete this.instanceCache;
			}

			if (this.destroySubscriptions) {
				this.destroySubscriptions.forEach(function(cb) {
					return cb();
				});
				this.destroySubscriptions = null;
			}

			if (this.destroyTracked) {
				debug(destroyFlag, this);
				if (this.widget.onDestroy) this.widget.onDestroy(this);
				if (
					this.widget.controller &&
					this.controller &&
					this.controller.onDestroy &&
					this.controller.widget == this.widget
				)
					this.controller.onDestroy();
				this.destroyTracked = false;
			}
		};

		_proto.setState = function setState(state) {
			var _this2 = this;

			var skip = !!this.state;
			if (this.state)
				for (var k in state) {
					if (this.state[k] !== state[k]) {
						skip = false;
						break;
					}
				}
			if (skip) return;
			this.state = Object.assign({}, this.state, state);
			var parent = this.parent; //notify all parents that child state change to bust up caching

			while (parent) {
				parent.childStateDirty = true;
				parent = parent.parent;
			}

			batchUpdates(function() {
				_this2.store.notify();
			});
		};

		_proto.set = function set(prop, value) {
			var _this3 = this;

			var setter = this.setters && this.setters[prop];

			if (setter) {
				setter(value);
				return true;
			}

			var p = this.widget[prop];

			if (p && typeof p == "object") {
				if (p.debounce) {
					this.definePropertySetter(
						prop,
						debounce(function(value) {
							return _this3.doSet(prop, value);
						}, p.debounce)
					);
					this.set(prop, value);
					return true;
				}

				if (p.throttle) {
					this.definePropertySetter(
						prop,
						throttle(function(value) {
							return _this3.doSet(prop, value);
						}, p.throttle)
					);
					this.set(prop, value);
					return true;
				}
			}

			return this.doSet(prop, value);
		};

		_proto.definePropertySetter = function definePropertySetter(prop, setter) {
			if (!this.setters) this.setters = {};
			this.setters[prop] = setter;
		};

		_proto.doSet = function doSet(prop, value) {
			var _this4 = this;

			var changed = false;
			batchUpdates(function() {
				var p = _this4.widget[prop];

				if (isObject(p)) {
					if (p.set) {
						if (isFunction(p.set)) {
							p.set(value, _this4);
							changed = true;
						} else if (isString(p.set)) {
							_this4.controller[p.set](value, _this4);

							changed = true;
						}
					} else if (p.action) {
						var action = p.action(value, _this4);

						_this4.store.dispatch(action);

						changed = true;
					} else if (isString(p.bind)) {
						changed = _this4.store.set(p.bind, value);
					}
				}
			});
			return changed;
		};

		_proto.replaceState = function replaceState(state) {
			this.cached.state = this.state;
			this.state = state;
			this.store.notify();
		};

		_proto.getInstanceCache = function getInstanceCache() {
			if (!this.instanceCache)
				this.instanceCache = new InstanceCache(this, this.widget.isPureContainer ? this.key : null);
			return this.instanceCache;
		};

		_proto.clearChildrenCache = function clearChildrenCache() {
			if (this.instanceCache) this.instanceCache.destroy();
		};

		_proto.getChild = function getChild(context, widget, key, store) {
			return this.getInstanceCache().getChild(widget, store || this.store, key);
		};

		_proto.getDetachedChild = function getDetachedChild(widget, key, store) {
			var child = new Instance(widget, key, this, store || this.store);
			child.detached = true;
			return child;
		};

		_proto.prepareRenderCleanupChild = function prepareRenderCleanupChild(widget, store, keyPrefix, options) {
			return widget.prepareRenderCleanup(store || this.store, options, keyPrefix, this);
		};

		_proto.getJsxEventProps = function getJsxEventProps() {
			var _this5 = this;

			var widget = this.widget;
			if (!isArray(widget.jsxAttributes)) return null;
			var props = {};
			widget.jsxAttributes.forEach(function(attr) {
				if (attr.indexOf("on") == 0 && attr.length > 2)
					props[attr] = function(e) {
						return _this5.invoke(attr, e, _this5);
					};
			});
			return props;
		};

		_proto.getCallback = function getCallback(methodName) {
			var scope = this.widget;
			var callback = scope[methodName];
			if (typeof callback === "string") return this.getControllerMethod(callback);
			if (typeof callback !== "function")
				throw new Error("Cannot invoke callback method " + methodName + " as assigned value is not a function.");
			return callback.bind(scope);
		};

		_proto.getControllerMethod = function getControllerMethod(methodName) {
			if (!this.controller)
				throw new Error(
					'Cannot invoke controller method "' + methodName + '" as controller is not assigned to the widget.'
				);
			var at = this;

			while (at != null && at.controller && !at.controller[methodName]) {
				at = at.parent;
			}

			if (!at || !at.controller || !at.controller[methodName])
				throw new Error(
					'Cannot invoke controller method "' +
						methodName +
						'". The method cannot be found in any of the assigned controllers.'
				);
			return at.controller[methodName].bind(at.controller);
		};

		_proto.invoke = function invoke(methodName) {
			for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}

			return this.getCallback(methodName).apply(null, args);
		};

		_proto.invokeControllerMethod = function invokeControllerMethod(methodName) {
			for (
				var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;
				_key2 < _len2;
				_key2++
			) {
				args[_key2 - 1] = arguments[_key2];
			}

			return this.getControllerMethod(methodName).apply(null, args);
		};

		return Instance;
	})();

function renderResultFix(res) {
	return res != null && isDefined(res.content)
		? res
		: {
				content: res
			};
}

var InstanceCache =
	/*#__PURE__*/
	(function() {
		function InstanceCache(parent, keyPrefix) {
			this.children = {};
			this.parent = parent;
			this.marked = {};
			this.monitored = null;
			this.keyPrefix = keyPrefix != null ? keyPrefix + "-" : "";
		}

		var _proto2 = InstanceCache.prototype;

		_proto2.getChild = function getChild(widget, store, key) {
			var k = this.keyPrefix + (key != null ? key : widget.widgetId);
			var instance = this.children[k];

			if (!instance || (!instance.visible && (instance.widget.controller || instance.widget.onInit))) {
				instance = new Instance(widget, k, this.parent);
				this.children[k] = instance;
			}

			if (instance.store !== store) instance.setStore(store);
			this.marked[k] = instance;
			return instance;
		};

		_proto2.mark = function mark() {
			this.marked = {};
		};

		_proto2.trackDestroy = function trackDestroy(instance) {
			if (!this.monitored) this.monitored = {};
			this.monitored[instance.key] = instance;
		};

		_proto2.destroy = function destroy() {
			this.children = {};
			this.marked = {};
			if (!this.monitored) return;

			for (var key in this.monitored) {
				this.monitored[key].destroy();
			}

			this.monitored = null;
		};

		_proto2.sweep = function sweep() {
			this.children = this.marked;
			if (!this.monitored) return;
			var activeCount = 0;

			for (var key in this.monitored) {
				var monitoredChild = this.monitored[key];
				var child = this.children[key];

				if (child !== monitoredChild || !monitoredChild.visible) {
					monitoredChild.destroy();
					delete this.monitored[key];
					if (child === monitoredChild) delete this.children[key];
				} else activeCount++;
			}

			if (activeCount === 0) this.monitored = null;
		};

		return InstanceCache;
	})();

var TraversalStack =
	/*#__PURE__*/
	(function() {
		function TraversalStack() {
			this.data = [];
		}

		var _proto = TraversalStack.prototype;

		_proto.push = function push(node) {
			if (this.data.length == 0) this.hop();
			this.data[this.data.length - 1].elements.push(node);
		};

		_proto.hop = function hop() {
			this.data.push({
				elements: [],
				index: 0
			});
		};

		_proto.pop = function pop() {
			while (this.data.length > 0) {
				var line = this.data[this.data.length - 1];

				if (line.index < line.elements.length) {
					line.index++;
					return line.elements[line.index - 1];
				}

				this.data.pop();
			}

			return null;
		};

		_proto.empty = function empty() {
			while (this.data.length > 0) {
				var line = this.data[this.data.length - 1];
				if (line.index < line.elements.length) return false;
				this.data.pop();
			}

			return true;
		};

		return TraversalStack;
	})();

var RenderingContext =
	/*#__PURE__*/
	(function() {
		function RenderingContext(options) {
			this.options = options || {};
			this.exploreStack = new TraversalStack();
			this.prepareList = [];
			this.cleanupList = [];
			this.stacks = {};
			this.renderList = new LinkedListsNode();
		}

		var _proto = RenderingContext.prototype;

		_proto.getStack = function getStack(key) {
			var stack = this.stacks[key];
			if (!stack) stack = this.stacks[key] = [];
			return stack;
		};

		_proto.push = function push(key, value) {
			var stack = this.getStack(key);
			stack.push(this[key]);
			return (this[key] = value);
		};

		_proto.pop = function pop(key) {
			var stack = this.getStack(key);
			return (this[key] = stack.pop());
		};

		_proto.pushNamedValue = function pushNamedValue(key, name, value) {
			var stack = this.getStack(key + ":" + name);
			if (!this[key]) this[key] = {};
			stack.push(this[key][name]);
			return (this[key][name] = value);
		};

		_proto.popNamedValue = function popNamedValue(key, name) {
			var stack = this.getStack(key + ":" + name);
			return (this[key][name] = stack.pop());
		};

		_proto.get = function get(key) {
			return this[key];
		};

		_proto.getRootRenderList = function getRootRenderList() {
			var rl = this.renderList;

			while (rl.left) {
				rl = rl.left;
			}

			return rl;
		};

		return RenderingContext;
	})();

var LinkedListsNode =
	/*#__PURE__*/
	(function() {
		function LinkedListsNode(left, right) {
			this.left = left;
			this.right = right;
			this.data = [];
		}

		var _proto2 = LinkedListsNode.prototype;

		_proto2.insertLeft = function insertLeft() {
			var node = new LinkedListsNode(this.left, this);
			if (this.left) this.left.right = node;
			this.left = node;
			return node;
		};

		_proto2.insertRight = function insertRight() {
			var node = new LinkedListsNode(this, this.right);
			if (this.right) this.right.left = node;
			this.right = node;
			return node;
		};

		_proto2.markReverseIndex = function markReverseIndex() {
			this.reverseIndex = this.data.length;
		};

		_proto2.reverse = function reverse() {
			reverseSlice(this.data, this.reverseIndex);
		};

		return LinkedListsNode;
	})();

var appLoopFlag = "app-loop";
var vdomRenderFlag = "vdom-render";
var counter = {};
var activeFlags$1 = {};

var nowImpl = function nowImpl() {
	return Date.now();
};

function now() {
	if (process.env.NODE_ENV !== "production") {
		return nowImpl();
	} else {
		return 0;
	}
}

function enable(flag) {
	if (process.env.NODE_ENV !== "production") {
		activeFlags$1[flag] = true;
	}
}

function disable(flag) {
	if (process.env.NODE_ENV !== "production") {
		activeFlags$1[flag] = false;
	}
}

function count(flag) {
	if (process.env.NODE_ENV !== "production") {
		if (!activeFlags$1[flag]) return;
		return (counter[flag] = (counter[flag] || 0) + 1);
	}
}

function log(flag) {
	if (process.env.NODE_ENV !== "production") {
		if (!activeFlags$1[flag]) return;
		Console.log.apply(Console, arguments);
	}
}

if (
	process.env.NODE_ENV !== "production" &&
	typeof window != "undefined" &&
	window.performance &&
	window.performance.now
) {
	nowImpl = function nowImpl() {
		return performance.now();
	};
}

var Timing = {
	now: now,
	enable: enable,
	disable: disable,
	count: count,
	log: log
};

function shallowEquals(v1, v2) {
	if (v1 === v2) return true;
	var t1 = typeof v1,
		t2 = typeof v2,
		k,
		i;
	if (t1 != t2) return false;
	if (v1 == null || v2 == null)
		//this captures undefined too
		return false;

	if (t1 == "object") {
		if (isArray(v1)) {
			if (!isArray(v2) || v1.length != v2.length) return false;

			for (i = 0; i < v1.length; i++) {
				if (!shallowEquals(v1[i], v2[i])) return false;
			}

			return true;
		} else {
			for (k in v1) {
				if (v1.hasOwnProperty(k) && (!v2.hasOwnProperty(k) || v1[k] !== v2[k])) return false;
			}

			for (k in v2) {
				if (v2.hasOwnProperty(k) && (!v1.hasOwnProperty(k) || v1[k] !== v2[k])) return false;
			}

			return true;
		}
	}

	return v1 === v2;
}

function onIdleCallback(callback, options) {
	var token = null;
	if (typeof requestIdleCallback == "function") token = requestIdleCallback(callback, options);
	else token = setTimeout(callback, 1);
	return function() {
		if (typeof cancelIdleCallback == "function") cancelIdleCallback(token);
		else clearTimeout(token);
	};
}

var Cx =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(Cx, _VDOM$Component);

		function Cx(props) {
			var _context2;

			var _this;

			_this = _VDOM$Component.call(this, props) || this;

			if (props.instance) {
				_this.widget = props.instance.widget;
				_this.store = props.instance.store;
			} else {
				_this.widget = PureContainer.create({
					items: props.widget || props.items
				});

				if (props.parentInstance) {
					_this.parentInstance = props.parentInstance;
					_this.store = props.store || _this.parentInstance.store;
				} else {
					_this.parentInstance = new Instance(_this.widget, 0);
					_this.store = props.store;
				}

				if (!_this.store) throw new Error("Cx component requires store.");
			}

			_this.state = {
				deferToken: 0
			};

			if (props.subscribe) {
				var _context;

				_this.unsubscribe = _this.store.subscribe((_context = _this).update.bind(_context));
				_this.state.data = _this.store.getData();
			}

			_this.flags = {};
			_this.renderCount = 0;
			if (props.onError) _this.componentDidCatch = (_context2 = _this).componentDidCatchHandler.bind(_context2);
			_this.deferCounter = 0;

			_this.waitForIdle();

			return _this;
		}

		var _proto = Cx.prototype;

		_proto.componentWillReceiveProps = function componentWillReceiveProps(props) {
			//TODO: Switch to new props
			if (props.subscribe) {
				var data = this.store.getData();

				if (data !== this.state.data) {
					this.waitForIdle();
					this.setState({
						data: this.store.getData()
					});
				}
			}
		};

		_proto.getInstance = function getInstance() {
			if (this.props.instance) return this.props.instance;
			if (this.instance) return this.instance;
			if (this.widget && this.parentInstance)
				return (this.instance = this.parentInstance.getDetachedChild(this.widget, 0, this.store));
			throw new Error("Could not resolve a widget instance in the Cx component.");
		};

		_proto.render = function render() {
			if (!this.widget || (this.props.deferredUntilIdle && this.state.deferToken < this.deferCounter)) return null;
			return VDOM$2.createElement(CxContext, {
				instance: this.getInstance(),
				flags: this.flags,
				options: this.props.options,
				buster: ++this.renderCount,
				contentFactory: this.props.contentFactory
			});
		};

		_proto.componentDidMount = function componentDidMount() {
			this.componentDidUpdate();
			if (this.props.options && this.props.options.onPipeUpdate)
				this.props.options.onPipeUpdate(this.update.bind(this));
		};

		_proto.componentDidUpdate = function componentDidUpdate() {
			if (this.flags.dirty) {
				this.update();
			}
		};

		_proto.update = function update() {
			var _this2 = this;

			var data = this.store.getData();
			debug(appDataFlag, data);
			if (this.flags.preparing) this.flags.dirty = true;
			else if (isBatchingUpdates() || this.props.immediate) {
				notifyBatchedUpdateStarting();
				this.setState(
					{
						data: data
					},
					notifyBatchedUpdateCompleted
				);
			} else {
				//in standard mode sequential store commands are batched
				if (!this.pendingUpdateTimer) {
					notifyBatchedUpdateStarting();
					this.pendingUpdateTimer = setTimeout(function() {
						delete _this2.pendingUpdateTimer;

						_this2.setState(
							{
								data: data
							},
							notifyBatchedUpdateCompleted
						);
					}, 0);
				}
			}
		};

		_proto.waitForIdle = function waitForIdle() {
			var _this3 = this;

			if (!this.props.deferredUntilIdle) return;
			if (this.unsubscribeIdleRequest) this.unsubscribeIdleRequest();
			var token = ++this.deferCounter;
			this.unsubscribeIdleRequest = onIdleCallback(
				function() {
					_this3.setState({
						deferToken: token
					});
				},
				{
					timeout: this.props.idleTimeout || 30000
				}
			);
		};

		_proto.componentWillUnmount = function componentWillUnmount() {
			if (this.pendingUpdateTimer) clearTimeout(this.pendingUpdateTimer);
			if (this.unsubscribeIdleRequest) this.unsubscribeIdleRequest();
			if (this.unsubscribe) this.unsubscribe();
			if (this.props.options && this.props.options.onPipeUpdate) this.props.options.onPipeUpdate(null);
		};

		_proto.shouldComponentUpdate = function shouldComponentUpdate(props, state) {
			if (props.deferredUntilIdle && state.deferToken != this.deferCounter) return false;
			return (
				state !== this.state ||
				!props.params ||
				!shallowEquals(props.params, this.props.params) ||
				props.instance !== this.props.instance ||
				props.widget !== this.props.widget ||
				props.store !== this.props.store ||
				props.parentInstance !== this.props.parentInstance
			);
		};

		_proto.componentDidCatchHandler = function componentDidCatchHandler(error, info) {
			this.flags.preparing = false;
			this.props.onError(error, this.getInstance(), info);
		};

		return Cx;
	})(VDOM$2.Component);

var CxContext =
	/*#__PURE__*/
	(function(_VDOM$Component2) {
		_inheritsLoose(CxContext, _VDOM$Component2);

		function CxContext(props) {
			var _this4;

			_this4 = _VDOM$Component2.call(this, props) || this;
			_this4.renderCount = 0;

			_this4.componentWillReceiveProps(props);

			return _this4;
		}

		var _proto2 = CxContext.prototype;

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			this.timings = {
				start: now()
			};
			var instance = props.instance,
				options = props.options,
				contentFactory = props.contentFactory;
			var count = 0,
				visible,
				context; //should not be tracked by parents for destroy

			if (!instance.detached)
				throw new Error("The instance passed to a Cx component should be detached from its parent.");
			if (this.props.instance !== instance && this.props.instance.destroyTracked) this.props.instance.destroy();
			this.props.flags.preparing = true;

			do {
				context = new RenderingContext(options);
				this.props.flags.dirty = false;
				instance.assignedRenderList = context.getRootRenderList();
				visible = instance.scheduleExploreIfVisible(context);

				if (visible) {
					while (!context.exploreStack.empty()) {
						var inst = context.exploreStack.pop(); //console.log("EXPLORE", inst.widget.constructor.name, inst.widget.tag, inst.widget.widgetId);

						inst.explore(context);
					}
				} else if (instance.destroyTracked) {
					instance.destroy();
					break;
				}
			} while (this.props.flags.dirty && ++count <= 3 && Widget.optimizePrepare && now() - this.timings.start < 8);

			if (visible) {
				this.timings.afterExplore = now();

				for (var i = 0; i < context.prepareList.length; i++) {
					context.prepareList[i].prepare(context);
				}

				this.timings.afterPrepare = now(); //walk in reverse order so children get rendered first

				var renderList = context.getRootRenderList();

				while (renderList) {
					for (var _i = renderList.data.length - 1; _i >= 0; _i--) {
						renderList.data[_i].render(context);
					}

					renderList = renderList.right;
				}

				this.content = getContent(instance.vdom);
				if (contentFactory)
					this.content = contentFactory({
						children: this.content
					});
				this.timings.afterRender = now();

				for (var _i2 = 0; _i2 < context.cleanupList.length; _i2++) {
					context.cleanupList[_i2].cleanup(context);
				}
			} else {
				this.content = null;
				this.timings.afterExplore = this.timings.afterPrepare = this.timings.afterRender = now();
			}

			this.timings.beforeVDOMRender = now();
			this.props.flags.preparing = false;
			this.props.flags.rendering = true;
			this.renderingContext = context;
		};

		_proto2.render = function render() {
			return this.content;
		};

		_proto2.componentDidMount = function componentDidMount() {
			this.componentDidUpdate();
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			this.props.flags.rendering = false;
			this.timings.afterVDOMRender = now(); //let {instance} = this.props;
			//instance.cleanup(this.renderingContext);

			this.timings.afterCleanup = now();
			this.renderCount++;

			if (process.env.NODE_ENV !== "production") {
				var _this$timings = this.timings,
					start = _this$timings.start,
					beforeVDOMRender = _this$timings.beforeVDOMRender,
					afterVDOMRender = _this$timings.afterVDOMRender,
					afterPrepare = _this$timings.afterPrepare,
					afterExplore = _this$timings.afterExplore,
					afterRender = _this$timings.afterRender,
					afterCleanup = _this$timings.afterCleanup;
				Timing.log(
					vdomRenderFlag,
					this.renderCount,
					"cx",
					(beforeVDOMRender - start + afterCleanup - afterVDOMRender).toFixed(2) + "ms",
					"vdom",
					(afterVDOMRender - beforeVDOMRender).toFixed(2) + "ms"
				);
				Timing.log(
					appLoopFlag,
					this.renderCount,
					this.renderingContext.options.name || "main",
					"total",
					(afterCleanup - start).toFixed(1) + "ms",
					"explore",
					(afterExplore - start).toFixed(1) + "ms",
					"prepare",
					(afterPrepare - afterExplore).toFixed(1),
					"render",
					(afterRender - afterPrepare).toFixed(1),
					"vdom",
					(afterVDOMRender - beforeVDOMRender).toFixed(1),
					"cleanup",
					(afterCleanup - afterVDOMRender).toFixed(1)
				);
			}
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			var instance = this.props.instance;
			if (instance.destroyTracked) instance.destroy();
		};

		return CxContext;
	})(VDOM$2.Component);

function isPromise(x) {
	return isObject(x) && isFunction(x.then);
}

var ContentResolver =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(ContentResolver, _PureContainer);

		function ContentResolver() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = ContentResolver.prototype;

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						params: {
							structured: true
						},
						loading: undefined
					}
				])
			);
		};

		_proto.init = function init() {
			_PureContainer.prototype.init.call(this);

			this.initialItems = this.layout ? this.layout.items : this.items;
			this.clear();
		};

		_proto.initInstance = function initInstance(context, instance) {
			instance.content = this.initialItems;
			instance.cachedParams = {}; //unique value which will never pass the equality check
		};

		_proto.prepareData = function prepareData(context, instance) {
			var _this = this;

			var data = instance.data;

			if (data.params !== instance.cachedParams && this.onResolve) {
				instance.cachedParams = data.params;
				var content = instance.invoke("onResolve", data.params, instance);

				if (isPromise(content)) {
					instance.set("loading", true);
					this.setContent(instance, null);
					content.then(function(cnt) {
						_this.setContent(instance, cnt);

						instance.setState({
							cacheBuster: {}
						});
						instance.set("loading", false);
					});
				} else this.setContent(instance, content);
			}
		};

		_proto.setContent = function setContent(instance, content) {
			if (content) {
				this.clear();

				switch (this.mode) {
					case "prepend":
						this.add(content);
						this.add(this.initialItems);
						break;

					case "append":
						this.add(this.initialItems);
						this.add(content);
						break;

					case "replace":
						this.add(content);
						break;
				}

				instance.content = this.layout ? this.layout.items : this.items;
				this.clear();
			} else instance.content = this.initialItems;
		};

		_proto.explore = function explore(context, instance) {
			//a little bit hacky
			if (this.layout) this.layout.items = instance.content;
			else this.items = instance.content;

			_PureContainer.prototype.explore.call(this, context, instance);
		};

		return ContentResolver;
	})(PureContainer);
ContentResolver.prototype.mode = "replace";

var IsolatedScope =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(IsolatedScope, _PureContainer);

		function IsolatedScope() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = IsolatedScope.prototype;

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						data: {
							structured: true
						}
					}
				])
			);
		};

		_proto.init = function init() {
			var _this = this;

			if (typeof this.bind === "string")
				this.data = {
					bind: this.bind
				};
			else if (isArray(this.bind)) {
				this.data = {};
				this.bind.forEach(function(x, i) {
					_this.data[String(i)] = {
						bind: x
					};
				});
			}

			_PureContainer.prototype.init.call(this);
		};

		_proto.explore = function explore(context, instance) {
			if (instance.shouldUpdate) {
				_PureContainer.prototype.explore.call(this, context, instance);
			}
		};

		return IsolatedScope;
	})(PureContainer);

var SubscribableView =
	/*#__PURE__*/
	(function(_View) {
		_inheritsLoose(SubscribableView, _View);

		function SubscribableView(config) {
			var _this;

			_this = _View.call(this, config) || this;
			_this.subscribers = new SubscriberList();
			_this.changes = [];
			return _this;
		}

		var _proto = SubscribableView.prototype;

		_proto.subscribe = function subscribe(callback) {
			return this.subscribers.subscribe(callback);
		};

		_proto.unsubscribeAll = function unsubscribeAll() {
			this.subscribers.clear();
		};

		_proto.doNotify = function doNotify(path) {
			var _this2 = this;

			if (this.notificationsSuspended) return;

			if (!this.async) {
				this.subscribers.notify([path]);
			} else {
				this.changes.push(path || "");

				if (!this.scheduled) {
					this.scheduled = true;
					setTimeout(function() {
						_this2.scheduled = false;
						var changes = _this2.changes;
						_this2.changes = [];

						_this2.subscribers.notify(changes);
					}, 0);
				}
			}
		};

		_proto.silently = function silently(callback) {
			this.notificationsSuspended = (this.notificationsSuspended || 0) + 1;
			var wasDirty = this.dirty,
				dirty;
			this.dirty = false;

			try {
				callback(this);
			} finally {
				this.notificationsSuspended--;
				dirty = this.dirty;
				this.dirty = wasDirty;
			}

			return dirty;
		};

		return SubscribableView;
	})(View);
SubscribableView.prototype.async = false;

var DetachedScope =
	/*#__PURE__*/
	(function(_IsolatedScope) {
		_inheritsLoose(DetachedScope, _IsolatedScope);

		function DetachedScope() {
			return _IsolatedScope.apply(this, arguments) || this;
		}

		var _proto = DetachedScope.prototype;

		_proto.declareData = function declareData() {
			var _IsolatedScope$protot;

			return (_IsolatedScope$protot = _IsolatedScope.prototype.declareData).call.apply(
				_IsolatedScope$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						exclusiveData: {
							structured: true
						}
					}
				])
			);
		};

		_proto.init = function init() {
			var _this = this;

			if (typeof this.exclusive === "string")
				this.exclusiveData = {
					bind: this.exclusive
				};

			if (Array.isArray(this.exclusive)) {
				this.exclusiveData = {};
				this.exclusive.forEach(function(x, i) {
					_this.exclusiveData[String(i)] = {
						bind: x
					};
				});
			}

			this.container = PureContainer.create({
				type: PureContainer,
				items: this.children || this.items
			});
			delete this.items;
			delete this.children;
			if (this.name)
				this.options = _objectSpread({}, this.options, {
					name: this.name
				});

			_IsolatedScope.prototype.init.call(this);
		};

		_proto.initInstance = function initInstance(context, instance) {
			instance.subStore = new ContainmentStore({
				store: instance.store,
				selector: getSelector(this.exclusiveData || this.data)
			});
		};

		_proto.render = function render(context, instance, key) {
			return VDOM$2.createElement(Cx, {
				key: key,
				widget: this.container,
				store: instance.subStore,
				parentInstance: instance,
				subscribe: true,
				options: this.options,
				onError: this.onError
			});
		};

		return DetachedScope;
	})(IsolatedScope);

var ContainmentStore =
	/*#__PURE__*/
	(function(_SubscribableView) {
		_inheritsLoose(ContainmentStore, _SubscribableView);

		function ContainmentStore() {
			return _SubscribableView.apply(this, arguments) || this;
		}

		var _proto2 = ContainmentStore.prototype;

		_proto2.getData = function getData() {
			return this.store.getData();
		};

		_proto2.setItem = function setItem() {
			var _this2 = this;

			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return this.wrapper(function() {
				var _this2$store;

				(_this2$store = _this2.store).setItem.apply(_this2$store, args);
			});
		};

		_proto2.deleteItem = function deleteItem() {
			var _this3 = this;

			for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				args[_key2] = arguments[_key2];
			}

			return this.wrapper(function() {
				var _this3$store;

				(_this3$store = _this3.store).deleteItem.apply(_this3$store, args);
			});
		};

		_proto2.wrapper = function wrapper(callback) {
			if (this.store.silently(callback)) {
				var data = this.getData();
				var containedData = this.selector(data);

				if (containedData === this.cache.containedData) {
					this.store.notify();
				} else {
					this.cache.containedData = containedData;
					this.notify();
				}

				return true;
			}

			return false;
		};

		return ContainmentStore;
	})(SubscribableView);

var Store =
	/*#__PURE__*/
	(function(_SubscribableView) {
		_inheritsLoose(Store, _SubscribableView);

		function Store(config) {
			var _this;

			if (config === void 0) {
				config = {};
			}

			_this = _SubscribableView.call(this, config) || this;
			_this.data = config.data || {};
			_this.meta = {
				version: 0
			};
			return _this;
		}

		var _proto = Store.prototype;

		_proto.getData = function getData() {
			return this.data;
		};

		_proto.setItem = function setItem(path, value) {
			var next = Binding.get(path).set(this.data, value);

			if (next != this.data) {
				this.data = next;
				this.meta.version++;
				this.notify(path);
				return true;
			}

			return false;
		};

		_proto.deleteItem = function deleteItem(path) {
			var next = Binding.get(path).delete(this.data);

			if (next != this.data) {
				this.data = next;
				this.meta.version++;
				this.notify(path);
				return true;
			}

			return false;
		};

		_proto.clear = function clear() {
			this.data = {};
			this.meta.version++;
			this.notify();
		};

		return Store;
	})(SubscribableView);
Store.prototype.async = false;

var Restate =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(Restate, _PureContainer);

		function Restate() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = Restate.prototype;

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						data: {
							structured: true
						},
						deferredUntilIdle: undefined,
						idleTimeout: undefined
					}
				])
			);
		};

		_proto.init = function init() {
			this.container = PureContainer.create({
				type: PureContainer,
				items: this.children || this.items,
				layout: this.layout,
				controller: this.controller,
				outerLayout: this.outerLayout,
				useParentLayout: this.useParentLayout,
				ws: this.ws
			});
			delete this.items;
			delete this.children;
			delete this.controller;
			delete this.outerLayout;
			delete this.layout;
			this.useParentLayout = true;

			_PureContainer.prototype.init.call(this);
		};

		_proto.initInstance = function initInstance(context, instance) {
			var bindings = {};

			for (var key in this.data) {
				if (this.data[key] && isString(this.data[key].bind)) bindings[key] = this.data[key].bind;
			}

			instance.subStore = new RestateStore({
				store: instance.store,
				bindings: bindings,
				detached: this.detached
			});

			instance.setStore = function(store) {
				instance.store = store;
				instance.subStore.setStore(store);
			};
		};

		_proto.explore = function explore(context, instance) {
			if (!this.detached) {
				instance.container = instance.getChild(context, this.container, "container", instance.subStore);
				instance.container.scheduleExploreIfVisible(context);
			}

			_PureContainer.prototype.explore.call(this, context, instance);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data,
				subStore = instance.subStore;
			subStore.setParentData(data.data);

			_PureContainer.prototype.prepareData.call(this, context, instance);
		};

		_proto.render = function render(context, instance, key) {
			if (!this.detached) return instance.container.render(context);
			return VDOM$1.createElement(Cx, {
				key: key,
				widget: this.container,
				parentInstance: instance,
				store: instance.subStore,
				subscribe: true,
				options: this.options,
				onError: this.onError,
				deferredUntilIdle: instance.data.deferredUntilIdle,
				idleTimeout: instance.data.idleTimeout
			});
		};

		return Restate;
	})(PureContainer);
Restate.prototype.detached = false;
Restate.prototype.waitForIdle = false;

var RestateStore =
	/*#__PURE__*/
	(function(_Store) {
		_inheritsLoose(RestateStore, _Store);

		function RestateStore(config) {
			var _this;

			_this = _Store.call(this, config) || this;
			_this.parentData = {};
			return _this;
		}

		var _proto2 = RestateStore.prototype;

		_proto2.setParentData = function setParentData(data) {
			var _this2 = this;

			var changed = this.silently(function() {
				for (var key in data) {
					_Store.prototype.setItem.call(_this2, key, data[key]);
				}
			});
			this.parentData = data;
			if (changed && this.detached) this.notify();
		};

		_proto2.doNotify = function doNotify(path) {
			var _this3 = this;

			_Store.prototype.doNotify.call(this, path);

			var changed = this.store.batch(function() {
				var data = _this3.getData();

				for (var key in _this3.bindings) {
					var value = data[key]; //Only values that have actually changed in the RestateStore are propagated to the parent store
					// to avoid race conditions that can happen due to async functions keeping the reference of the
					// restate store of an invisible widget

					if (value !== _this3.parentData[key]) {
						if (value === undefined) _this3.store.delete(_this3.bindings[key]);
						else _this3.store.set(_this3.bindings[key], value);
					}
				}
			}); //in non-detached mode the parent store triggers a new render cycle

			if (!this.detached && !changed) this.store.notify();
		};

		return RestateStore;
	})(Store);

var DataProxy =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(DataProxy, _PureContainer);

		function DataProxy() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = DataProxy.prototype;

		_proto.init = function init() {
			if (!this.data) this.data = {};
			if (this.alias) this.data[this.alias] = this.value;
			this.container = PureContainer.create({
				type: PureContainer,
				items: this.children || this.items,
				layout: this.layout,
				controller: this.controller,
				outerLayout: this.outerLayout,
				ws: this.ws
			});
			this.children = [this.container];
			delete this.items;
			delete this.controller;
			delete this.outerLayout;
			this.layout = UseParentLayout;

			_PureContainer.prototype.init.call(this);
		};

		_proto.initInstance = function initInstance(context, instance) {
			var _this = this;

			instance.store = new DataProxyView({
				store: instance.store,
				privateData: this.data,
				onSet: function onSet(path, value) {
					var config = _this.data[path];
					if (config.bind)
						return isUndefined(value)
							? instance.store.deleteItem(config.bind)
							: instance.store.setItem(config.bind, value);
					if (!config.set)
						throw new Error("Cannot set value for " + path + " in DataProxy as the setter is not defined.");
					if (isString(config.set)) instance.getControllerMethod(config.set)(value, instance);
					else if (isFunction(config.set)) config.set(value, instance);
					else
						throw new Error(
							"Cannot set value for " +
								path +
								" in DataProxy as the setter is neither a function or a controller method."
						);
					return true;
				}
			});

			instance.setStore = function(store) {
				instance.store.setStore(store);
			};
		};

		return DataProxy;
	})(PureContainer);

var DataProxyView =
	/*#__PURE__*/
	(function(_ReadOnlyDataView) {
		_inheritsLoose(DataProxyView, _ReadOnlyDataView);

		function DataProxyView(config) {
			var _this2;

			_this2 = _ReadOnlyDataView.call(this, config) || this;
			_this2.dataSelector = getSelector(_this2.privateData);
			if (_this2.dataSelector.memoize) _this2.dataSelector = _this2.dataSelector.memoize();
			return _this2;
		}

		var _proto2 = DataProxyView.prototype;

		_proto2.getAdditionalData = function getAdditionalData(parentStoreData) {
			if (this.meta.version !== this.cache.version) this.data = this.dataSelector(parentStoreData);
			return this.data;
		};

		_proto2.setItem = function setItem(path, value) {
			var binding = Binding.get(path);
			var bindingRoot = binding.parts[0];

			if (!isObject(this.privateData) || !this.privateData.hasOwnProperty(bindingRoot)) {
				if (isUndefined(value)) return _ReadOnlyDataView.prototype.deleteItem.call(this, path);
				return _ReadOnlyDataView.prototype.setItem.call(this, path, value);
			}

			var newValue = value;
			if (binding.parts.length > 1)
				newValue = binding.set(this.getAdditionalData(this.store.getData()), value)[bindingRoot];
			return this.onSet(bindingRoot, newValue);
		};

		_proto2.deleteItem = function deleteItem(path) {
			return this.setItem(path, undefined);
		};

		return DataProxyView;
	})(ReadOnlyDataView);

var subscribers$2,
	eventBan = 0;
function executeKeyboardShortcuts(e) {
	if (Date.now() < eventBan) return; //Avoid duplicate executions as event.stopPropagation() for React events does not stop native events

	eventBan = Date.now() + 5;
	subscribers$2 && subscribers$2.notify(e);
}
function registerKeyboardShortcut(key, callback) {
	var keyCode = isObject(key) ? key.keyCode : key;
	var shiftKey = isObject(key) ? key.shiftKey : false;
	var ctrlKey = isObject(key) ? key.ctrlKey : false;
	var altKey = isObject(key) ? key.altKey : false;

	if (!subscribers$2) {
		subscribers$2 = new SubscriberList();
		document.addEventListener("keydown", function(e) {
			if (e.target == document.body) executeKeyboardShortcuts(e);
		});
	}

	return subscribers$2.subscribe(function(e) {
		if (e.keyCode == keyCode && (!shiftKey || e.shiftKey) && (!ctrlKey || e.ctrlKey) && (!altKey || e.altKey))
			callback(e);
	});
}

var flattenProps = function flattenProps(props) {
	if (!props) return {};

	if (props.jsxSpread) {
		props = _objectSpread(
			{},
			props,
			props.jsxSpread.reduce(function(acc, prop) {
				return Object.assign(acc, prop);
			}, {})
		);
	}

	if (props.$props !== undefined) {
		props = _objectSpread({}, props.$props, {
			jsxAttributes: props.jsxAttributes,
			children: props.children
		});
	}

	return _objectSpread({}, props);
};

var FunctionalComponent =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(FunctionalComponent, _PureContainer);

		function FunctionalComponent() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = FunctionalComponent.prototype;

		_proto.initInstance = function initInstance(context, instance) {
			this.clear();
			this.add(
				this.childrenFactory(
					_objectSpread({}, this.props, {
						store: new StoreProxy(function() {
							return instance.store;
						})
					})
				)
			);
			instance.content = this.layout ? this.layout.items : this.items;
			this.clear();
		};

		_proto.explore = function explore(context, instance) {
			if (this.layout) this.layout.items = instance.content;
			else this.items = instance.content;
			this.exploreItems(context, instance, instance.content);
		};

		return FunctionalComponent;
	})(PureContainer);

function createFunctionalComponent(factory) {
	if (isComponentFactory(factory)) return factory;
	return createComponentFactory(factory, function(props) {
		if (props === void 0) {
			props = {};
		}

		var innerProps = flattenProps(props);
		delete innerProps.visible;
		delete innerProps.if;
		delete innerProps.controller;
		delete innerProps.layout;
		delete innerProps.outerLayout;
		delete innerProps.putInto;
		delete innerProps.contentFor;
		return {
			type: FunctionalComponent,
			visible: isDefined(props.if) ? props.if : isDefined(props.visible) ? props.visible : true,
			layout: props.layout || UseParentLayout,
			controller: props.controller,
			outerLayout: props.outerLayout,
			putInto: props.contentFor || props.putInto,
			childrenFactory: factory,
			props: innerProps
		};
	});
}

var Selection =
	/*#__PURE__*/
	(function(_Component) {
		_inheritsLoose(Selection, _Component);

		function Selection() {
			return _Component.apply(this, arguments) || this;
		}

		var _proto = Selection.prototype;

		_proto.isSelected = function isSelected(store, record, index) {
			return this.bind && store.get(this.bind) === record;
		};

		_proto.getIsSelectedDelegate = function getIsSelectedDelegate(store) {
			var _this = this;

			return function(record, index) {
				return _this.isSelected(store, record, index);
			};
		};

		_proto.select = function select(store, record, index, options) {
			this.selectMultiple(store, [record], [index], options);
		};

		_proto.selectMultiple = function selectMultiple(store, records, indexes, options) {
			//abstract
		};

		_proto.declareData = function declareData() {
			var declaration = {
				$selection: {
					structured: true
				}
			};
			return Object.assign.apply(Object, [declaration].concat(Array.prototype.slice.call(arguments)));
		};

		_proto.configureWidget = function configureWidget(widget) {
			if (this.record || this.index) {
				widget.$selection = Object.assign(widget.$selection || {}, {
					record: this.record,
					index: this.index
				});
			}

			return this.declareData();
		};

		_proto.selectInstance = function selectInstance(instance) {
			var store = instance.store,
				data = instance.data;
			if (!data.$selection)
				throw new Error(
					"Selection model not properly configured. Using the selectInstance method without specified record and index bindings."
				);
			return this.select(store, data.$selection.record, data.$selection.index);
		};

		_proto.isInstanceSelected = function isInstanceSelected(instance) {
			var store = instance.store,
				data = instance.data;
			return data.$selection && this.isSelected(store, data.$selection.record, data.$selection.index);
		};

		return Selection;
	})(Component);
Selection.prototype.toggle = false;
Selection.namespace = "ui.selection.";

var SimpleSelection =
	/*#__PURE__*/
	(function(_Selection) {
		_inheritsLoose(SimpleSelection, _Selection);

		function SimpleSelection() {
			return _Selection.apply(this, arguments) || this;
		}

		var _proto2 = SimpleSelection.prototype;

		_proto2.isSelected = function isSelected(store, record, index) {
			return this.getIsSelectedDelegate(store)(record, index);
		};

		_proto2.getIsSelectedDelegate = function getIsSelectedDelegate(store) {
			var selection = this.bind && store.get(this.bind);
			return function(record, index) {
				return record === selection;
			};
		};

		_proto2.selectMultiple = function selectMultiple(store, records, index) {
			if (this.bind) store.set(this.bind, records[0]);
		};

		return SimpleSelection;
	})(Selection);

var DummySelection =
	/*#__PURE__*/
	(function(_Selection2) {
		_inheritsLoose(DummySelection, _Selection2);

		function DummySelection() {
			return _Selection2.apply(this, arguments) || this;
		}

		var _proto3 = DummySelection.prototype;

		_proto3.isSelected = function isSelected(store, record, index) {
			return false;
		};

		_proto3.selectMultiple = function selectMultiple() {
			//dummy
		};

		_proto3.selectInstance = function selectInstance() {
			//dummy
		};

		return DummySelection;
	})(Selection);

DummySelection.prototype.isDummy = true;

Selection.factory = function(name) {
	if (typeof name == "object") return new SimpleSelection(name);
	return new DummySelection();
};

var PropertySelection =
	/*#__PURE__*/
	(function(_Selection) {
		_inheritsLoose(PropertySelection, _Selection);

		function PropertySelection() {
			return _Selection.apply(this, arguments) || this;
		}

		var _proto = PropertySelection.prototype;

		_proto.selectMultiple = function selectMultiple(store, records, indexes, _temp) {
			var _this = this;

			var _ref = _temp === void 0 ? {} : _temp,
				toggle = _ref.toggle,
				add = _ref.add;

			if (this.toggle) toggle = true;
			if (!this.records || !this.records.bind) return false;
			var array = store.get(this.records.bind);
			var newArray = [].concat(array);
			var dirty = false;

			if (!toggle && !add) {
				newArray.forEach(function(r, i) {
					if (r[_this.selectedField]) {
						var nr = Object.assign({}, r);
						nr[_this.selectedField] = false;
						newArray[i] = nr;
						dirty = true;
					}
				});
			}

			records.forEach(function(record, i) {
				var index = indexes[i];
				var rec = newArray[index];
				if (array[index] !== record) throw new Error("Stale data.");
				var value = rec[_this.selectedField];
				var newValue = add ? true : toggle ? !value : true;
				if (value == newValue) return;
				var newRec = Object.assign({}, rec);
				newRec[_this.selectedField] = newValue;
				newArray[index] = newRec;
				dirty = true;
			});
			if (dirty) store.set(this.records.bind, newArray);
		};

		_proto.isSelected = function isSelected(store, record, index) {
			return record && record[this.selectedField];
		};

		return PropertySelection;
	})(Selection);
PropertySelection.prototype.selectedField = "selected";
PropertySelection.prototype.multiple = false;
Selection.alias("property", PropertySelection);

var KeySelection =
	/*#__PURE__*/
	(function(_Selection) {
		_inheritsLoose(KeySelection, _Selection);

		function KeySelection() {
			return _Selection.apply(this, arguments) || this;
		}

		var _proto = KeySelection.prototype;

		_proto.init = function init() {
			if (this.bind && !this.selection)
				this.selection = {
					bind: this.bind
				};
			if (!this.selection) this.selection = {};
			if (isArray(this.keyFields)) this.keyField = false;
			this.initialized = true;
		};

		_proto.getKey = function getKey(record) {
			if (this.key != null) return this.key;
			if (!record) return null;
			if (this.keyField) return record[this.keyField];
			var key = {};
			this.keyFields.forEach(function(k) {
				key[k] = record[k];
			});
			return key;
		};

		_proto.areKeysEqual = function areKeysEqual(key1, key2) {
			if (this.keyField) return key1 === key2 && key1 != null;
			if (!key1 || !key2) return false;
			return !this.keyFields.some(function(k) {
				return key1[k] !== key2[k];
			});
		};

		_proto.declareData = function declareData() {
			var _Selection$prototype$;

			return (_Selection$prototype$ = _Selection.prototype.declareData).call.apply(
				_Selection$prototype$,
				[
					this,
					{
						$selection: {
							structured: true
						}
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.configureWidget = function configureWidget(widget) {
			if (!this.initialized) this.init();
			widget.$selection = Object.assign(widget.$selection || {}, {
				keys: this.selection
			});
			return _Selection.prototype.configureWidget.call(this, widget);
		};

		_proto.selectMultiple = function selectMultiple(store, records, indexes, _temp) {
			var _this = this;

			var _ref = _temp === void 0 ? {} : _temp,
				toggle = _ref.toggle,
				add = _ref.add;

			if (!this.selection.bind) return false;
			if (this.toggle) toggle = true;

			if (!isNonEmptyArray(records)) {
				if (!toggle && !add) return store.delete(this.selection.bind);
				return false;
			}

			var keys = records.map(function(record) {
				return _this.getKey(record);
			});
			var selection = store.get(this.selection.bind);

			if (!this.multiple) {
				var key = keys[0];
				if (!toggle || !this.areKeysEqual(selection, key)) store.set(this.selection.bind, key);
				else store.delete(this.selection.bind);
			} else {
				if (this.storage == "array") {
					if (!isArray(selection) || (!toggle && !add)) store.set(this.selection.bind, keys);
					else {
						var newSelection = [].concat(selection);
						keys.forEach(function(key) {
							var exists = selection.some(function(x) {
								return _this.areKeysEqual(x, key);
							});
							if (!exists) newSelection.push(key);
							else if (toggle)
								newSelection = newSelection.filter(function(x) {
									return !_this.areKeysEqual(x, key);
								}); //TODO: optimize
						});
						store.set(this.selection.bind, newSelection);
					}
				} else if (this.storage == "hash") {
					var _newSelection = toggle ? _objectSpread({}, selection) : {};

					keys.forEach(function(key) {
						_newSelection[key] = !_newSelection[key];
					});
					store.set(this.selection.bind, _newSelection);
				}
			}
		};

		_proto.getIsSelectedDelegate = function getIsSelectedDelegate(store) {
			var _this2 = this;

			if (!this.selection.bind)
				return function() {
					return false;
				};
			var selection = store.get(this.selection.bind);

			if (this.multiple) {
				if (this.storage == "array") {
					selection = selection || [];
					return function(record, index) {
						return selection.some(function(k) {
							return _this2.areKeysEqual(_this2.getKey(record), k);
						});
					};
				} else {
					selection = selection || {};
					return function(record, index) {
						return selection[_this2.getKey(record)];
					};
				}
			} else
				return function(record, index) {
					return _this2.areKeysEqual(selection, _this2.getKey(record));
				};
		};

		_proto.isSelected = function isSelected(store, record, index) {
			return this.getIsSelectedDelegate(store)(record, index);
		};

		return KeySelection;
	})(Selection);
KeySelection.prototype.multiple = false;
KeySelection.prototype.keyField = "id";
KeySelection.prototype.storage = "array";
KeySelection.autoInit = true;
Selection.alias("key", KeySelection);

function isVisibleDeep(instance) {
	if (instance.visible && (!instance.widget.isPureContainer || !instance.widget.useParentLayout)) return true;

	if (instance.children) {
		for (var i = 0; i < instance.children.length; i++) {
			if (isVisibleDeep(instance.children[i])) return true;
		}
	}

	return false;
}

var FirstVisibleChildItem =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(FirstVisibleChildItem, _PureContainer);

		function FirstVisibleChildItem() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = FirstVisibleChildItem.prototype;

		_proto.checkVisible = function checkVisible(context, instance, data) {
			if (instance.parent.firstVisibleChild) return false;
			return _PureContainer.prototype.checkVisible.call(this, context, instance, data);
		};

		_proto.explore = function explore(context, instance) {
			if (instance.parent.firstVisibleChild) return;

			_PureContainer.prototype.explore.call(this, context, instance);
		};

		_proto.exploreCleanup = function exploreCleanup(context, instance) {
			if (instance.parent.firstVisibleChild) return;
			if (isVisibleDeep(instance)) instance.parent.firstVisibleChild = instance;
		};

		_proto.render = function render(context, instance, key) {
			if (instance.parent.firstVisibleChild != instance) return null;
			return _PureContainer.prototype.render.call(this, context, instance, key);
		};

		return FirstVisibleChildItem;
	})(PureContainer);

FirstVisibleChildItem.prototype.useParentLayout = true;
var FirstVisibleChildLayout =
	/*#__PURE__*/
	(function(_PureContainer2) {
		_inheritsLoose(FirstVisibleChildLayout, _PureContainer2);

		function FirstVisibleChildLayout() {
			return _PureContainer2.apply(this, arguments) || this;
		}

		var _proto2 = FirstVisibleChildLayout.prototype;

		_proto2.explore = function explore(context, instance) {
			instance.firstVisibleChild = null;

			_PureContainer2.prototype.explore.call(this, context, instance);
		};

		_proto2.exploreCleanup = function exploreCleanup(context, instance) {
			var children = instance.children,
				firstVisibleChild = instance.firstVisibleChild;

			if (children) {
				for (var i = 0; i < children.length; i++) {
					if (children[i] != firstVisibleChild) children[i].destroy();
				}
			}

			instance.children = [];
			if (firstVisibleChild) instance.children.push(firstVisibleChild);
		};

		_proto2.wrapItem = function wrapItem(item) {
			return item instanceof FirstVisibleChildItem
				? item
				: FirstVisibleChildItem.create({
						items: item
					});
		};

		return FirstVisibleChildLayout;
	})(PureContainer);

function validContent(r) {
	if (!r.hasOwnProperty("content")) return r;
	var content = [];

	for (var key in r) {
		if (key != "label") contentAppend(content, r[key]);
	}

	return content;
}

var LabelsLeftLayout =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(LabelsLeftLayout, _PureContainer);

		function LabelsLeftLayout() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = LabelsLeftLayout.prototype;

		_proto.render = function render(context, instance, key) {
			var result = [];
			var children = instance.children;
			var CSS = this.CSS,
				baseClass = this.baseClass;

			var addItem = function addItem(r, key) {
				if (!r) return;
				if (r.useParentLayout && isArray(r.content))
					r.content.forEach(function(x, i) {
						return addItem(x, key + "-" + i);
					});
				else {
					result.push(
						VDOM$2.createElement(
							"tr",
							{
								key: key
							},
							VDOM$2.createElement(
								"td",
								{
									className: CSS.element(baseClass, "label")
								},
								getContent(r.label)
							),
							VDOM$2.createElement(
								"td",
								{
									className: CSS.element(baseClass, "field")
								},
								validContent(r)
							)
						)
					);
				}
			};

			children.forEach(function(c, i) {
				addItem(c.vdom, i.toString());
			});
			return VDOM$2.createElement(
				"table",
				{
					key: key,
					className: CSS.block(baseClass, this.mod)
				},
				VDOM$2.createElement("tbody", null, result)
			);
		};

		return LabelsLeftLayout;
	})(PureContainer);
LabelsLeftLayout.prototype.baseClass = "labelsleftlayout";

function validContent$1(r) {
	var content = [];

	for (var key in r) {
		if (key != "label") contentAppend(content, r[key]);
	}

	return content;
}

var LabelsTopLayout =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(LabelsTopLayout, _PureContainer);

		function LabelsTopLayout() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = LabelsTopLayout.prototype;

		_proto.init = function init() {
			if (this.vertical && isUndefined(this.columns)) this.columns = 1;

			_PureContainer.prototype.init.call(this);
		};

		_proto.render = function render(context, instance, key) {
			var _this = this;

			var children = instance.children;
			var CSS = this.CSS,
				baseClass = this.baseClass;
			var state = {
				rows: []
			};

			var processContent = function processContent(r) {
				if (!r) return;
				if (isArray(r.content) && r.useParentLayout)
					r.content.forEach(function(x) {
						return processContent(x);
					});
				else _this.addItem(state, r);
			};

			children.forEach(function(item) {
				return processContent(item.vdom);
			});
			this.addRow(state);
			return VDOM$2.createElement(
				"table",
				{
					key: key,
					className: CSS.block(baseClass, this.mod)
				},
				VDOM$2.createElement("tbody", null, state.rows)
			);
		};

		_proto.addRow = function addRow(state) {
			if (state.labelCells && state.labelCells.length > 0)
				state.rows.push(
					VDOM$2.createElement(
						"tr",
						{
							key: state.rows.length
						},
						state.labelCells
					)
				);
			if (state.fieldCells && state.fieldCells.length > 0)
				state.rows.push(
					VDOM$2.createElement(
						"tr",
						{
							key: state.rows.length
						},
						state.fieldCells
					)
				);
			state.labelCells = [];
			state.fieldCells = [];
		};

		_proto.addItem = function addItem(state, item) {
			if (!state.labelCells || state.labelCells.length + 1 > this.columns) this.addRow(state);
			state.labelCells.push(
				VDOM$2.createElement(
					"td",
					{
						className: this.CSS.element(this.baseClass, "label"),
						key: state.labelCells.length
					},
					getContent(item.label)
				)
			);
			state.fieldCells.push(
				VDOM$2.createElement(
					"td",
					{
						className: this.CSS.element(this.baseClass, "field"),
						key: state.fieldCells.length
					},
					validContent$1(item)
				)
			);
		};

		return LabelsTopLayout;
	})(PureContainer);
LabelsTopLayout.prototype.baseClass = "labelstoplayout";
LabelsTopLayout.prototype.vertical = false;
LabelsTopLayout.prototype.columns = undefined;

var Content =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(Content, _PureContainer);

		function Content() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = Content.prototype;

		_proto.init = function init() {
			_PureContainer.prototype.init.call(this);

			this.putInto = this.for || this.name;
		};

		return Content;
	})(PureContainer);
Content.prototype.name = "body";
Content.prototype.isContent = true;
Widget.alias("content", Content);

var ContentPlaceholder =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(ContentPlaceholder, _PureContainer);

		function ContentPlaceholder() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = ContentPlaceholder.prototype;

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			(_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						name: undefined
					}
				])
			);
		};

		_proto.explore = function explore(context, instance) {
			var _this = this;

			instance.content = null;
			var data = instance.data;
			var content = context.content && context.content[data.name];
			if (content && !this.scoped) this.setContent(context, instance, content);
			else
				context.pushNamedValue("contentPlaceholder", data.name, function(content) {
					_this.setContent(context, instance, content);
				});
			if (this.scoped)
				instance.unregisterContentPlaceholder = function() {
					context.popNamedValue("contentPlaceholder", data.name);
				};

			_PureContainer.prototype.explore.call(this, context, instance);
		};

		_proto.prepare = function prepare(context, instance) {
			var content = instance.content;
			if (instance.cache("content", content) || (content && content.shouldUpdate)) instance.markShouldUpdate(context);
		};

		_proto.setContent = function setContent(context, instance, content) {
			instance.content = content;
			content.contentPlaceholder = instance;
		};

		_proto.render = function render(context, instance, key) {
			var content = instance.content;
			if (content) return content.contentVDOM;
			return _PureContainer.prototype.render.call(this, context, instance, key);
		};

		return ContentPlaceholder;
	})(PureContainer);
ContentPlaceholder.prototype.name = "body";
ContentPlaceholder.prototype.scoped = false;
Widget.alias("content-placeholder", ContentPlaceholder);
var ContentPlaceholderScope =
	/*#__PURE__*/
	(function(_PureContainer2) {
		_inheritsLoose(ContentPlaceholderScope, _PureContainer2);

		function ContentPlaceholderScope() {
			return _PureContainer2.apply(this, arguments) || this;
		}

		var _proto2 = ContentPlaceholderScope.prototype;

		_proto2.init = function init() {
			_PureContainer2.prototype.init.call(this);

			if (isString(this.name)) this.name = [this.name];
		};

		_proto2.explore = function explore(context, instance) {
			this.name.forEach(function(name) {
				context.pushNamedValue("contentPlaceholder", name, null);
				context.pushNamedValue("content", name, null);
			});

			_PureContainer2.prototype.explore.call(this, context, instance);
		};

		_proto2.exploreCleanup = function exploreCleanup(context, instance) {
			this.name.forEach(function(name) {
				context.popNamedValue("contentPlaceholder", name);
				context.popNamedValue("content", name);
			});
		};

		return ContentPlaceholderScope;
	})(PureContainer);

function startAppLoop(parentDOMElement, storeOrInstance, widget, options) {
	if (options === void 0) {
		options = {};
	}

	if (!parentDOMElement || parentDOMElement.nodeType !== 1)
		throw new Error("First argument to startAppLoop should be a valid DOM element.");
	var store, instance, parentInstance;
	if (!storeOrInstance) storeOrInstance = new Store();
	if (storeOrInstance.notify) store = storeOrInstance;
	else if (storeOrInstance.getChild) {
		if (storeOrInstance.widget === widget) instance = storeOrInstance;
		else parentInstance = storeOrInstance;
	} else throw new Error("Second argument to startAppLoop should be either of type Store or Instance");
	var root = VDOM$2.createElement(Cx, {
		store: store,
		widget: widget,
		instance: instance,
		parentInstance: parentInstance,
		options: options,
		subscribe: true
	});
	VDOM$2.DOM.render(root, parentDOMElement);
	var stopped = false;
	return function() {
		if (stopped) return;
		stopped = true;
		if (!options.destroyDelay) destroy(parentDOMElement, options);
		else {
			setTimeout(function() {
				destroy(parentDOMElement, options);
			}, options.destroyDelay);
		}
	};
}

function destroy(parentDOMElement, options) {
	VDOM$2.DOM.unmountComponentAtNode(parentDOMElement);
	if (options.removeParentDOMElement && parentDOMElement.parentNode)
		parentDOMElement.parentNode.removeChild(parentDOMElement);
}

var Url =
	/*#__PURE__*/
	(function() {
		function Url() {}

		Url.resolve = function resolve(path) {
			return path.replace("~/", this.base);
		};

		Url.absolute = function absolute(path) {
			return path.replace("~/", this.absoluteBase);
		};

		Url.unresolve = function unresolve(path) {
			if (path.indexOf("~/") == 0) return path;
			var absBase = this.absoluteBase || "";
			if (path.indexOf(absBase) == 0) return "~/" + path.substring(absBase.length);
			return "~/" + path.substring(this.base.length);
		};

		Url.getAbsoluteBase = function getAbsoluteBase() {
			return this.absoluteBase;
		};

		Url.isLocal = function isLocal(url) {
			var absBase = this.getAbsoluteBase();
			return url.indexOf("~/") == 0 || url.indexOf(absBase) == 0 || url.indexOf(this.base) == 0;
		};

		Url.setBase = function setBase(base) {
			if (!base || base[base.length - 1] != "/") base += "/";
			this.base = base;
			if (typeof window != "undefined")
				this.absoluteBase = window.location.protocol + "//" + window.location.host + this.base;
		};

		Url.getOrigin = function getOrigin() {
			if (typeof window == "undefined") return "";
			return (
				window.location.protocol +
				"//" +
				window.location.hostname +
				(window.location.port ? ":" + window.location.port : "")
			);
		};

		Url.getBaseFromScriptSrc = function getBaseFromScriptSrc(src, scriptPath) {
			if (!(scriptPath instanceof RegExp)) scriptPath = getBasePathRegex(scriptPath);
			var index = src.search(scriptPath);
			if (index == -1) return false;
			var origin = this.getOrigin();
			return src.substring(src.indexOf(origin) == 0 ? origin.length : 0, index);
		};

		Url.setBaseFromScript = function setBaseFromScript(scriptPath) {
			var scripts = document.getElementsByTagName("script"),
				base;
			if (!(scriptPath instanceof RegExp)) scriptPath = getBasePathRegex(scriptPath);

			for (var i = 0; i < scripts.length; i++) {
				base = this.getBaseFromScriptSrc(scripts[i].src, scriptPath);

				if (base) {
					this.setBase(base);
					return;
				}
			}

			throw new Error("Could not resolve url base from script matching '" + scriptPath + "'.");
		};

		return Url;
	})();
Url.setBase("/");

function getBasePathRegex(str) {
	var regex = "";
	var start = 0;
	if (str.indexOf("~/") == 0) start = 2;

	for (var i = start; i < str.length; i++) {
		switch (str[i]) {
			case ".":
				regex += "\\.";
				break;

			case "*":
				regex += ".*";
				break;

			default:
				regex += str[i];
		}
	}

	return new RegExp(regex + "(\\?.*)?$", "i");
}

var last = 0,
	next = 1,
	transitions = {},
	subscribers$3 = null,
	reload = false,
	navigateConfirmationCallback = null,
	permanentNavigateConfirmation = false;
var History =
	/*#__PURE__*/
	(function() {
		function History() {}

		History.connect = function connect(store, urlBinding, hashBinding) {
			var _this = this;

			this.store = store;
			this.urlBinding = urlBinding;
			this.hashBinding = hashBinding;
			this.updateStore();

			window.onpopstate = function() {
				_this.updateStore();
			};
		};

		History.pushState = function pushState(state, title, url) {
			return this.confirmAndNavigate(state, title, url);
		};

		History.replaceState = function replaceState(state, title, url) {
			return this.navigate(state, title, url, true);
		};

		History.reloadOnNextChange = function reloadOnNextChange() {
			reload = true;
		};

		History.addNavigateConfirmation = function addNavigateConfirmation(callback, permanent) {
			if (permanent === void 0) {
				permanent = false;
			}

			navigateConfirmationCallback = callback;
			permanentNavigateConfirmation = permanent;
		};

		History.confirmAndNavigate = function confirmAndNavigate(state, title, url, replace) {
			var _this2 = this;

			if (!navigateConfirmationCallback) return this.navigate(state, title, url, replace);
			var result = navigateConfirmationCallback(url);
			Promise.resolve(result).then(function(value) {
				if (value) {
					if (!permanentNavigateConfirmation) navigateConfirmationCallback = null;

					_this2.navigate(state, title, url, replace);
				}
			});
			return false;
		};

		History.navigate = function navigate(state, title, url, replace) {
			var _this3 = this;

			if (replace === void 0) {
				replace = false;
			}

			url = Url.resolve(url);

			if (!window.history.pushState || reload) {
				window.location[replace ? "replace" : "assign"](url);
				return true;
			}

			var transition,
				changed = false;
			batchUpdatesAndNotify(
				function() {
					changed = _this3.updateStore(url);
					if (changed)
						transitions[++last] = transition = {
							url: url,
							state: state,
							title: title,
							replace: replace
						};
				},
				function() {
					if (transition) transition.completed = true; //update history once the page is rendered and the title is set

					while (transitions[next] && transitions[next].completed) {
						var tr = transitions[next];
						delete transitions[next];
						next++;
						var op = tr.replace ? "replaceState" : "pushState";
						window.history[op](tr.state, tr.title, tr.url);
						if (subscribers$3) subscribers$3.notify(tr.url, op);
					}
				}
			);
			return changed;
		};

		History.updateStore = function updateStore(href) {
			var url = Url.unresolve(href || document.location.href),
				hash = null;
			var hashIndex = url.indexOf("#");

			if (hashIndex !== -1) {
				hash = url.substring(hashIndex);
				url = url.substring(0, hashIndex);
			}

			if (this.hashBinding) this.store.set(this.hashBinding, hash);
			return this.store.set(this.urlBinding, url);
		};

		History.subscribe = function subscribe(callback) {
			if (!subscribers$3) subscribers$3 = new SubscriberList();
			return subscribers$3.subscribe(callback);
		};

		return History;
	})();

function startHotAppLoop(appModule, element, store, widgets, options) {
	var stop; //webpack (HMR)

	if (appModule.hot) {
		// accept itself
		appModule.hot.accept(); // remember data on dispose

		appModule.hot.dispose(function(data) {
			data.state = store.getData();
			if (stop) stop();
		}); //apply data on hot replace

		if (appModule.hot.data) store.load(appModule.hot.data.state);
	}

	Widget.resetCounter(); //app loop

	return (stop = startAppLoop(element, store, widgets, options));
}

var AggregateFunction =
	/*#__PURE__*/
	(function() {
		function AggregateFunction() {}

		AggregateFunction.sum = function sum() {
			return new Sum();
		};

		AggregateFunction.avg = function avg() {
			return new Avg();
		};

		AggregateFunction.count = function count() {
			return new Count();
		};

		AggregateFunction.distinct = function distinct() {
			return new Distinct();
		};

		AggregateFunction.min = function min() {
			return new Min();
		};

		AggregateFunction.max = function max() {
			return new Max();
		};

		return AggregateFunction;
	})();

var Sum =
	/*#__PURE__*/
	(function() {
		function Sum() {}

		var _proto = Sum.prototype;

		_proto.process = function process(value) {
			this.empty = false;
			if (!isNaN(value)) this.result += value;
			else this.invalid = true;
		};

		_proto.getResult = function getResult() {
			if (this.invalid) return null;
			return this.result;
		};

		return Sum;
	})();

Sum.prototype.result = 0;
Sum.prototype.empty = true;

var Avg =
	/*#__PURE__*/
	(function() {
		function Avg() {}

		var _proto2 = Avg.prototype;

		_proto2.process = function process(value, count) {
			if (count === void 0) {
				count = 1;
			}

			this.empty = false;

			if (!isNaN(value) && !isNaN(count)) {
				this.result += value * count;
				this.count += count;
			} else this.invalid = true;
		};

		_proto2.getResult = function getResult() {
			if (this.empty || this.invalid || this.count == 0) return null;
			return this.result / this.count;
		};

		return Avg;
	})();

Avg.prototype.result = 0;
Avg.prototype.count = 0;
Avg.prototype.empty = true;

var Count =
	/*#__PURE__*/
	(function() {
		function Count() {}

		var _proto3 = Count.prototype;

		_proto3.process = function process(value) {
			if (value != null) this.result++;
		};

		_proto3.getResult = function getResult() {
			return this.result;
		};

		return Count;
	})();

Count.prototype.result = 0;

var Distinct =
	/*#__PURE__*/
	(function() {
		function Distinct() {
			this.values = {};
		}

		var _proto4 = Distinct.prototype;

		_proto4.process = function process(value) {
			if (value == null || this.values[value]) return;
			this.values[value] = true;
			this.empty = false;
			this.result++;
		};

		_proto4.getResult = function getResult() {
			if (this.empty || this.invalid) return null;
			return this.result;
		};

		return Distinct;
	})();

Distinct.prototype.result = 0;
Distinct.prototype.empty = true;

var Max =
	/*#__PURE__*/
	(function() {
		function Max() {}

		var _proto5 = Max.prototype;

		_proto5.process = function process(value) {
			if (!isNaN(value)) {
				if (this.empty) this.result = value;
				else if (value > this.result) this.result = value;
				this.empty = false;
			} else if (value != null) this.invalid = true;
		};

		_proto5.getResult = function getResult() {
			if (this.empty || this.invalid) return null;
			return this.result;
		};

		return Max;
	})();

Max.prototype.result = 0;
Max.prototype.empty = true;

var Min =
	/*#__PURE__*/
	(function() {
		function Min() {}

		var _proto6 = Min.prototype;

		_proto6.process = function process(value) {
			if (!isNaN(value)) {
				if (this.empty) this.result = value;
				else if (value < this.result) this.result = value;
				this.empty = false;
			} else if (value != null) this.invalid = true;
		};

		_proto6.getResult = function getResult() {
			if (this.empty || this.invalid) return null;
			return this.result;
		};

		return Min;
	})();

Min.prototype.result = 0;
Min.prototype.empty = true;

/*
 'column': {
   index: 0,
   sort: 'asc',
   group: true
   aggregate: 'count'
 }
 */

function transform(o, f) {
	var res = {};

	for (var k in o) {
		res[k] = f(o[k], k);
	}

	return res;
}

var Grouper =
	/*#__PURE__*/
	(function() {
		function Grouper(key, aggregates, dataGetter, nameGetter) {
			this.keys = Object.keys(key).map(function(k) {
				return {
					name: k,
					value: getSelector(key[k])
				};
			});
			if (nameGetter) this.nameGetter = getSelector(nameGetter);

			this.dataGetter =
				dataGetter ||
				function(x) {
					return x;
				};

			this.aggregates =
				aggregates &&
				transform(aggregates, function(prop) {
					if (!AggregateFunction[prop.type]) throw new Error("Unknown aggregate function '" + prop.type + "'.");
					return {
						value: getSelector(prop.value),
						weight: getSelector(prop.weight || 1),
						type: prop.type
					};
				});
			this.reset();
		}

		var _proto = Grouper.prototype;

		_proto.reset = function reset() {
			this.groups = this.initGroup(this.keys.length == 0);
		};

		_proto.initGroup = function initGroup(leaf) {
			if (!leaf) return {};
			return {
				records: [],
				indexes: [],
				aggregates:
					this.aggregates &&
					transform(this.aggregates, function(prop) {
						var f = AggregateFunction[prop.type];
						return {
							processor: f(),
							value: prop.value,
							weight: prop.weight
						};
					})
			};
		};

		_proto.process = function process(record, index) {
			var data = this.dataGetter(record);
			var key = this.keys.map(function(k) {
				return k.value(data);
			});
			var g = this.groups;

			for (var i = 0; i < key.length; i++) {
				var sg = g[key[i]];

				if (!sg) {
					sg = g[key[i]] = this.initGroup(i + 1 == key.length);
					if (this.nameGetter) sg.name = this.nameGetter(data);
				}

				g = sg;
			}

			g.records.push(record);
			g.indexes.push(index);

			if (g.aggregates) {
				for (var k in g.aggregates) {
					g.aggregates[k].processor.process(g.aggregates[k].value(data), g.aggregates[k].weight(data));
				}
			}
		};

		_proto.processAll = function processAll(records, indexes) {
			var _this = this;

			if (indexes) {
				for (var i = 0; i < records.length; i++) {
					this.process(records[i], indexes[i]);
				}
			} else
				records.forEach(function(r, i) {
					return _this.process(r, i);
				});
		};

		_proto.report = function report(g, path, level, results) {
			var _this2 = this;

			if (level == this.keys.length) {
				var key = {};
				this.keys.forEach(function(k, i) {
					return (key[k.name] = path[i]);
				});
				results.push({
					key: key,
					name: g.name,
					records: g.records,
					indexes: g.indexes,
					aggregates: transform(g.aggregates, function(p) {
						return p.processor.getResult();
					})
				});
			} else {
				Object.keys(g).forEach(function(k) {
					return _this2.report(g[k], [].concat(path, [k]), level + 1, results);
				});
			}
		};

		_proto.getResults = function getResults() {
			var g = this.groups;
			var results = [];
			this.report(g, [], 0, results);
			return results;
		};

		return Grouper;
	})();

var GroupAdapter =
	/*#__PURE__*/
	(function(_ArrayAdapter) {
		_inheritsLoose(GroupAdapter, _ArrayAdapter);

		function GroupAdapter() {
			return _ArrayAdapter.apply(this, arguments) || this;
		}

		var _proto = GroupAdapter.prototype;

		_proto.init = function init() {
			_ArrayAdapter.prototype.init.call(this);

			if (this.groupings) this.groupBy(this.groupings);
		};

		_proto.getRecords = function getRecords(context, instance, records, parentStore) {
			var result = _ArrayAdapter.prototype.getRecords.call(this, context, instance, records, parentStore);

			if (this.groupings) {
				var groupedResults = [];
				this.processLevel([], result, groupedResults, parentStore);
				result = groupedResults;
			}

			return result;
		};

		_proto.processLevel = function processLevel(keys, records, result, parentStore) {
			var _this = this;

			var level = keys.length;
			var inverseLevel = this.groupings.length - level;

			if (inverseLevel == 0) {
				for (var i = 0; i < records.length; i++) {
					records[i].store.setStore(parentStore);
					result.push(records[i]);
				}

				return;
			}

			var grouping = this.groupings[level];
			var grouper = grouping.grouper;
			grouper.reset();
			grouper.processAll(records);
			var results = grouper.getResults();
			if (grouping.comparer) results.sort(grouping.comparer);
			results.forEach(function(gr) {
				var _data;

				keys.push(gr.key);

				var $group = _objectSpread({}, gr.key, gr.aggregates, {
					$name: gr.name,
					$level: inverseLevel
				});

				var groupStore = new ReadOnlyDataView({
					store: parentStore,
					data: ((_data = {}), (_data[_this.groupName] = $group), _data),
					immutable: _this.immutable
				});
				var group = {
					key: keys
						.map(function(key) {
							return Object.keys(key)
								.map(function(k) {
									return key[k];
								})
								.join(":");
						})
						.join("|"),
					data: gr.records[0],
					group: $group,
					grouping: grouping,
					store: groupStore,
					level: inverseLevel
				};
				if (grouping.includeHeader !== false)
					result.push(
						_objectSpread({}, group, {
							type: "group-header",
							key: "header:" + group.key
						})
					);

				_this.processLevel(keys, gr.records, result, groupStore);

				if (grouping.includeFooter !== false)
					result.push(
						_objectSpread({}, group, {
							type: "group-footer",
							key: "footer:" + group.key
						})
					);
				keys.pop();
			});
		};

		_proto.groupBy = function groupBy(groupings) {
			var _this2 = this;

			if (!groupings) this.groupings = null;
			else if (isArray(groupings)) {
				this.groupings = groupings;
				this.groupings.forEach(function(g) {
					var groupSorters = [];
					var key = {};

					for (var name in g.key) {
						if (!g.key[name] || !isDefined(g.key[name].direction) || !isDefined(g.key[name].value))
							g.key[name] = {
								value: g.key[name],
								direction: "ASC"
							};
						key[name] = g.key[name].value;
						groupSorters.push({
							field: name,
							direction: g.key[name].direction
						});
					}

					g.grouper = new Grouper(
						key,
						_objectSpread({}, _this2.aggregates, g.aggregates),
						function(r) {
							return r.store.getData();
						},
						g.text
					);
					g.comparer = null;
					if (groupSorters.length > 0)
						g.comparer = getComparer(groupSorters, function(x) {
							return x.key;
						});
				});
			} else throw new Error("Invalid grouping provided.");
		};

		return GroupAdapter;
	})(ArrayAdapter);
GroupAdapter.prototype.groupName = "$group";

var TreeAdapter =
	/*#__PURE__*/
	(function(_ArrayAdapter) {
		_inheritsLoose(TreeAdapter, _ArrayAdapter);

		function TreeAdapter() {
			return _ArrayAdapter.apply(this, arguments) || this;
		}

		var _proto = TreeAdapter.prototype;

		_proto.mapRecords = function mapRecords(context, instance, data, parentStore, recordsBinding) {
			var nodes = _ArrayAdapter.prototype.mapRecords.call(this, context, instance, data, parentStore, recordsBinding);

			var result = [];
			this.processList(context, instance, 0, "", nodes, result);
			return result;
		};

		_proto.processList = function processList(context, instance, level, parentKey, nodes, result) {
			var _this = this;

			var nonLeafs = [],
				leafs = [];
			nodes.forEach(function(record) {
				record.key = parentKey + record.key;

				_this.processNode(context, instance, level, record.data.$leaf ? leafs : nonLeafs, record);
			});
			result.push.apply(result, nonLeafs.concat(leafs));
		};

		_proto.processNode = function processNode(context, instance, level, result, record) {
			var _this2 = this;

			result.push(record);
			var data = record.data,
				store = record.store;
			data.$level = level;

			if (!data[this.leafField]) {
				if (data[this.expandedField]) {
					if (data[this.childrenField]) {
						var childNodes = _ArrayAdapter.prototype.mapRecords.call(
							this,
							context,
							instance,
							data[this.childrenField],
							store,
							Binding.get(this.recordName + "." + this.childrenField)
						);

						this.processList(context, instance, level + 1, record.key + ":", childNodes, result);
					} else if (!data[this.loadedField]) {
						if (this.load) {
							store.set(this.recordName + "." + this.loadingField, true);
							var response = this.load(context, instance, data);
							Promise.resolve(response)
								.then(function(children) {
									store.set(_this2.recordName + "." + _this2.childrenField, children);
									store.set(_this2.recordName + "." + _this2.loadedField, true);
									store.set(_this2.recordName + "." + _this2.loadingField, false);
								})
								.catch(function(response) {
									if (_this2.onLoadError) _this2.onLoadError(response);
								});
						}
					}
				} else data[this.expandedField] = false;
			}
		};

		_proto.sort = function sort(sorters) {
			if (this.foldersFirst) {
				if (!sorters || !isArray(sorters)) sorters = [];
				sorters = [
					{
						field: this.leafField,
						direction: "ASC"
					}
				].concat(sorters);
			}

			_ArrayAdapter.prototype.sort.call(this, sorters);
		};

		return TreeAdapter;
	})(ArrayAdapter);
TreeAdapter.prototype.childrenField = "$children";
TreeAdapter.prototype.expandedField = "$expanded";
TreeAdapter.prototype.leafField = "$leaf";
TreeAdapter.prototype.loadingField = "$loading";
TreeAdapter.prototype.loadedField = "$loaded";
TreeAdapter.prototype.foldersFirst = true;
TreeAdapter.prototype.isTreeAdapter = true;

function bind(path, defaultValue) {
	return {
		bind: path,
		defaultValue: defaultValue
	};
}

function tpl(text) {
	return {
		tpl: text
	};
}

function expr(text) {
	return {
		expr: text
	};
}

export {
	computable,
	Controller,
	VDOM$2 as VDOM,
	Widget,
	contentAppend,
	getContentArray,
	getContent,
	Container,
	PureContainer,
	Repeater,
	Rescope,
	StaticText,
	Text,
	CSS,
	CSSHelper,
	FocusManager,
	oneFocusOut,
	offFocusOut,
	preventFocus,
	preventFocusOnTouch,
	ResizeManager,
	ZIndexManager,
	Format$1 as Format,
	enableCultureSensitiveFormatting,
	Culture,
	Localization,
	Cx,
	Instance,
	InstanceCache,
	RenderingContext,
	ContentResolver,
	batchUpdates,
	isBatchingUpdates,
	notifyBatchedUpdateStarting,
	notifyBatchedUpdateCompleted,
	batchUpdatesAndNotify,
	IsolatedScope,
	DetachedScope,
	Restate,
	DataProxy,
	executeKeyboardShortcuts,
	registerKeyboardShortcut,
	createFunctionalComponent,
	flattenProps,
	Selection,
	PropertySelection,
	KeySelection,
	FirstVisibleChildLayout,
	UseParentLayout,
	LabelsLeftLayout,
	LabelsTopLayout,
	Content,
	ContentPlaceholder,
	ContentPlaceholderScope,
	exploreChildren,
	startAppLoop,
	History,
	Url,
	startHotAppLoop,
	DataAdapter,
	ArrayAdapter,
	GroupAdapter,
	TreeAdapter,
	bind,
	tpl,
	expr
};
