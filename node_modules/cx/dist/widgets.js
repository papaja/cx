import { VDOM } from "cx-react";
import RouteMatcher from "route-parser";
import { NumberCulture, DateTimeCulture } from "intl-io";

function _defineProperties(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, descriptor.key, descriptor);
	}
}

function _createClass(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties(Constructor, staticProps);
	return Constructor;
}

function _defineProperty(obj, key, value) {
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value: value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}

	return obj;
}

function _extends() {
	_extends =
		Object.assign ||
		function(target) {
			for (var i = 1; i < arguments.length; i++) {
				var source = arguments[i];

				for (var key in source) {
					if (Object.prototype.hasOwnProperty.call(source, key)) {
						target[key] = source[key];
					}
				}
			}

			return target;
		};

	return _extends.apply(this, arguments);
}

function _objectSpread(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? arguments[i] : {};
		var ownKeys = Object.keys(source);

		if (typeof Object.getOwnPropertySymbols === "function") {
			ownKeys = ownKeys.concat(
				Object.getOwnPropertySymbols(source).filter(function(sym) {
					return Object.getOwnPropertyDescriptor(source, sym).enumerable;
				})
			);
		}

		ownKeys.forEach(function(key) {
			_defineProperty(target, key, source[key]);
		});
	}

	return target;
}

function _inheritsLoose(subClass, superClass) {
	subClass.prototype = Object.create(superClass.prototype);
	subClass.prototype.constructor = subClass;
	subClass.__proto__ = superClass;
}

function _setPrototypeOf(o, p) {
	_setPrototypeOf =
		Object.setPrototypeOf ||
		function _setPrototypeOf(o, p) {
			o.__proto__ = p;
			return o;
		};

	return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
	if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	if (Reflect.construct.sham) return false;
	if (typeof Proxy === "function") return true;

	try {
		Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
		return true;
	} catch (e) {
		return false;
	}
}

function _construct(Parent, args, Class) {
	if (isNativeReflectConstruct()) {
		_construct = Reflect.construct;
	} else {
		_construct = function _construct(Parent, args, Class) {
			var a = [null];
			a.push.apply(a, args);
			var Constructor = Function.bind.apply(Parent, a);
			var instance = new Constructor();
			if (Class) _setPrototypeOf(instance, Class.prototype);
			return instance;
		};
	}

	return _construct.apply(null, arguments);
}

function _assertThisInitialized(self) {
	if (self === void 0) {
		throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	}

	return self;
}

function isString(s) {
	return typeof s === "string";
}

function isFunction(f) {
	return typeof f === "function";
}

function isArray(a) {
	return Array.isArray(a);
}

var componentAlias = {};
var Component =
	/*#__PURE__*/
	(function() {
		function Component(config) {
			if (config && config.$props) {
				Object.assign(config, config.$props);
				delete config.$props;
			}

			Object.assign(this, config);
		}

		Component.alias = function alias(_alias, type) {
			var _this = this;

			if (type) {
				type.prototype.componentAlias = _alias;
				componentAlias[this.namespace + _alias] = type;
			} else //decorator usage
				return function(t) {
					_this.alias(_alias, t);

					return t;
				};
		};

		Component.create = function create(typeAlias, config, more) {
			var _this2 = this;

			if (!typeAlias) return this.factory(typeAlias, config, more);
			if (typeAlias.isComponent) return typeAlias;
			if (isComponentFactory(typeAlias)) return this.create(typeAlias.create(config));
			if (isArray(typeAlias))
				return typeAlias.map(function(c) {
					return _this2.create(c, config, more);
				});
			if (typeAlias.$type) return this.create(typeAlias.$type, typeAlias, config);
			if (typeAlias.type) return this.create(typeAlias.type, typeAlias, config);
			var cmpType, alias;
			if (typeAlias.isComponentType) cmpType = typeAlias;
			else if (isFunction(typeAlias)) {
				if (this.factory) return this.factory(typeAlias, config, more);
				throw new Error("Unsupported component type " + typeAlias + ".");
			} else if (isString(typeAlias)) {
				alias = this.namespace + typeAlias;
				cmpType = componentAlias[alias];

				if (!cmpType) {
					if (typeAlias && this.factory) return this.factory(typeAlias, config, more);
					throw new Error("Unknown component alias " + alias + ".");
				}
			} else if (typeof typeAlias == "object") {
				cmpType = typeAlias.type || typeAlias.$type;

				if (!cmpType) {
					cmpType = this;
					more = more ? Object.assign({}, config, more) : config;
					config = typeAlias;
				}
			}
			if (isArray(config))
				return config.map(function(cfg) {
					return _this2.create(cmpType, cfg, more);
				});
			var cfg = config;
			if (more) cfg = Object.assign({}, config, more);
			var cmp = new cmpType(cfg);
			if (cmpType.autoInit && cmp.init) cmp.init();
			return cmp;
		};

		return Component;
	})();
Component.prototype.isComponent = true;
Component.isComponentType = true;
Component.namespace = "";
Component.autoInit = false;

Component.factory = function(alias, config, more) {
	throw new Error("Unknown component alias " + alias + ".");
};

function createComponentFactory(factory, jsxDriver, meta) {
	factory.$isComponentFactory = true;
	factory.$meta = meta;
	factory.create = jsxDriver;
	return factory;
}
function isComponentFactory(factory) {
	return factory && factory.$isComponentFactory;
}

var cssHelperCache = {};
var CSSHelper =
	/*#__PURE__*/
	(function() {
		function CSSHelper() {}

		CSSHelper.get = function get(code) {
			var helper = cssHelperCache[code];
			if (!helper) throw new Error("Unknown CSS helper '" + code + "'.");
			return helper;
		};

		CSSHelper.register = function register(code, helper) {
			cssHelperCache[code] = helper;
		};

		CSSHelper.alias = function alias(code, helper) {
			cssHelperCache[code] = helper;
		};

		return CSSHelper;
	})();

function parseStyle(str) {
	if (typeof str != "string") return str;
	var style = {},
		parts = str.split(";");

	for (var i = 0; i < parts.length; i++) {
		var part = parts[i];
		var colonIndex = part.indexOf(":");
		if (colonIndex == -1) continue;
		var name = part.substring(0, colonIndex).trim();
		var value = part.substring(colonIndex + 1).trim();
		name = name
			.split("-")
			.map(function(p, i) {
				return i == 0 ? p : p[0].toUpperCase() + p.substring(1);
			})
			.join("");
		style[name] = value;
	}

	return style;
}

function push(list, item) {
	if (!item) return list;
	if (!list) list = [];
	list.push(item);
	return list;
}

function pushMore(list, itemArray) {
	if (!itemArray || itemArray.length == 0) return list;
	if (!list) list = [];
	list.push.apply(list, itemArray);
	return list;
}

function pushMap(list, itemArray, mapF) {
	return itemArray ? pushMore(list, itemArray.map(mapF)) : list;
}

function join(list) {
	return list ? list.join(" ") : null;
}

var CSS =
	/*#__PURE__*/
	(function() {
		function CSS() {}

		CSS.resolve = function resolve() {
			var list, type, arg, i, key;

			for (i = 0; i < arguments.length; i++) {
				arg = arguments[i];

				if (arg) {
					type = typeof arg;
					if (type == "string") list = push(list, arg);
					else if (type == "object") {
						if (isArray(arg)) list = pushMore(list, this.resolve.apply(this, arg));
						else
							for (key in arg) {
								if (arg[key]) list = push(list, key);
							}
					}
				}
			}

			return list;
		};

		CSS.block = function block(baseClass, styleModifiers, stateModifiers) {
			var _this = this;

			var list;
			if (baseClass) list = push(list, this.classPrefix + "b-" + baseClass);
			list = pushMap(list, this.resolve(styleModifiers), function(m) {
				return _this.classPrefix + "m-" + m;
			});
			list = pushMap(list, this.resolve(stateModifiers), function(m) {
				return _this.classPrefix + "s-" + m;
			});
			return join(list);
		};

		CSS.element = function element(baseClass, elementClass, stateModifiers) {
			var _this2 = this;

			var list;
			if (baseClass && elementClass) list = push(list, this.classPrefix + "e-" + baseClass + "-" + elementClass);
			list = pushMap(list, this.resolve(stateModifiers), function(m) {
				return _this2.classPrefix + "s-" + m;
			});
			return join(list);
		};

		CSS.state = function state(stateModifiers) {
			var _this3 = this;

			return join(
				pushMap(null, this.resolve(stateModifiers), function(m) {
					return _this3.classPrefix + "s-" + m;
				})
			);
		};

		CSS.expand = function expand() {
			return join(this.resolve.apply(this, arguments));
		};

		CSS.parseStyle = function parseStyle$$1(str) {
			return parseStyle(str);
		};

		return CSS;
	})();
CSS.classPrefix = "cx";
CSSHelper.alias("cx", CSS);

function isObject(o) {
	return o !== null && typeof o === "object";
}

var bindingCache = {};
var Binding =
	/*#__PURE__*/
	(function() {
		function Binding(path) {
			this.path = path;
			this.parts = path.split(".");
			var fstr = "return (x";
			var cpath = "x";

			for (var i = 0; i < this.parts.length; i++) {
				if (this.parts[i][0] >= "0" && this.parts[i][0] <= "9") cpath += "[" + this.parts[i] + "]";
				else cpath += "." + this.parts[i];
				if (i + 1 < this.parts.length) fstr += " && " + cpath;
				else fstr += " ? " + cpath + " : undefined";
			}

			fstr += ")";
			this.value = new Function("x", fstr);
		}

		var _proto = Binding.prototype;

		_proto.set = function set(state, value) {
			var cv = this.value(state);
			if (cv === value) return state;
			var ns = Object.assign({}, state);
			var o = ns;

			for (var i = 0; i < this.parts.length; i++) {
				var part = this.parts[i];
				var no = i == this.parts.length - 1 ? value : Object.assign({}, o[part]);
				o[part] = no;
				o = no;
			}

			return ns;
		};

		_proto.delete = function _delete(state) {
			var ns = Object.assign({}, state);
			var o = ns;
			var part;

			for (var i = 0; i < this.parts.length - 1; i++) {
				part = this.parts[i];
				var no = Object.assign({}, o[part]);
				o[part] = no;
				o = no;
			}

			part = this.parts[this.parts.length - 1];
			if (!o.hasOwnProperty(part)) return state;
			delete o[part];
			return ns;
		};

		Binding.get = function get(path) {
			if (isString(path)) {
				var b = bindingCache[path];
				if (b) return b;
				b = new Binding(path);
				bindingCache[path] = b;
				return b;
			}

			if (isObject(path) && isString(path.bind)) return this.get(path.bind);
			if (path instanceof Binding) return path;
			throw new Error("Invalid binding definition provided.");
		};

		return Binding;
	})();
function isBinding(value) {
	if (isObject(value) && isString(value.bind)) return true;
	return value instanceof Binding;
}

function computable() {
	var _ref;

	if (arguments.length == 0)
		throw new Error("computable requires at least a compute function to be passed in arguments.");
	var compute = ((_ref = arguments.length - 1), _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref]);
	if (typeof compute != "function") throw new Error("Last argument to the computable function should be a function.");
	var inputs = [],
		a;

	for (var i = 0; i + 1 < arguments.length; i++) {
		a = i < 0 || arguments.length <= i ? undefined : arguments[i];
		if (isString(a)) inputs.push(Binding.get(a).value);
		else if (a.memoize) inputs.push(a.memoize());
		else if (isFunction(a)) inputs.push(a);
		else throw new Error("Invalid selector type '" + typeof a + "' received.");
	}

	function memoize(amnesia, warmupData) {
		var lastValue,
			lastArgs =
				warmupData &&
				inputs.map(function(s, i) {
					return s(warmupData);
				});
		return function(data) {
			var dirty = amnesia;

			if (!lastArgs) {
				lastArgs = Array.from({
					length: inputs.length
				});
				dirty = true;
			}

			for (var _i = 0; _i < inputs.length; _i++) {
				var v = inputs[_i](data);

				if (v !== lastArgs[_i]) dirty = true;
				lastArgs[_i] = v;
			}

			if (dirty) lastValue = compute.apply(null, lastArgs);
			return lastValue;
		};
	}

	var selector = memoize(true);
	selector.memoize = memoize;
	return selector;
}

var Console = {
	log: function log() {
		var _console;

		if (typeof window != "undefined" && window.console) (_console = console).log.apply(_console, arguments);
	},
	warn: function warn() {
		var _console2;

		if (typeof window != "undefined" && window.console) (_console2 = console).warn.apply(_console2, arguments);
	}
};

var activeFlags = {
	deprecated: true
};
function debug(flag) {
	if (process.env.NODE_ENV !== "production") {
		if (!activeFlags[flag]) return;
		Console.log.apply(Console, arguments);
	}
}
var renderFlag = "render";
var processDataFlag = "process-data";
var menuFlag = "menu";
var appDataFlag = "app-data";
var tooltipsFlag = "tooltips";
var deprecatedFlag = "deprecated";
var destroyFlag = "destroy";

var globalCacheIdentifier = 1;
var GlobalCacheIdentifier =
	/*#__PURE__*/
	(function() {
		function GlobalCacheIdentifier() {}

		GlobalCacheIdentifier.get = function get() {
			return globalCacheIdentifier;
		};

		GlobalCacheIdentifier.change = function change() {
			globalCacheIdentifier++;
		};

		return GlobalCacheIdentifier;
	})();

function isNumber(n) {
	return typeof n === "number";
}

function isUndefined(v) {
	return v === undefined;
}

var defaultFormatter = function defaultFormatter(v) {
	return v.toString();
};

var formatFactory = {
	string: function string() {
		return defaultFormatter;
	},
	wrap: function wrap(part0, prefix, suffix) {
		if (!prefix) prefix = "";
		if (!suffix) suffix = "";
		return function(value) {
			return prefix + value.toString() + suffix;
		};
	},
	fixed: function fixed(part0, digits) {
		return function(value) {
			return value.toFixed(digits);
		};
	},
	prefix: function prefix(part0, _prefix) {
		if (!_prefix) _prefix = "";
		return function(value) {
			return _prefix + value.toString();
		};
	},
	suffix: function suffix(part0, _suffix) {
		if (!_suffix) _suffix = "";
		return function(value) {
			return value.toString() + _suffix;
		};
	},
	uppercase: function uppercase() {
		return function(value) {
			return value.toString().toUpperCase();
		};
	},
	lowercase: function lowercase() {
		return function(value) {
			return value.toString().toLowerCase();
		};
	},
	urlencode: function urlencode() {
		return function(value) {
			return encodeURIComponent(value);
		};
	},
	number: function number(part0, minFractionDigits, maxFractionDigits) {
		var _resolveMinMaxFractio = resolveMinMaxFractionDigits(minFractionDigits, maxFractionDigits),
			minimumFractionDigits = _resolveMinMaxFractio.minimumFractionDigits,
			maximumFractionDigits = _resolveMinMaxFractio.maximumFractionDigits;

		var trimmable = maximumFractionDigits - minimumFractionDigits;

		if (trimmable > 0) {
			if (minimumFractionDigits == 0) ++trimmable;
			return function(value) {
				return trimFractionZeros(value.toFixed(maximumFractionDigits), trimmable);
			};
		}

		return function(value) {
			return value.toFixed(maximumFractionDigits);
		};
	},
	percentage: function percentage(part0, minFractionDigits, maxFractionDigits) {
		var numberFormatter = formatFactory.number(part0, minFractionDigits, maxFractionDigits);
		return function(value) {
			return numberFormatter(value * 100) + "%";
		};
	},
	percentageSign: function percentageSign(part0, minFractionDigits, maxFractionDigits) {
		var numberFormatter = formatFactory.number(part0, minFractionDigits, maxFractionDigits);
		return function(value) {
			return numberFormatter(value) + "%";
		};
	},
	date: function date() {
		return function(value) {
			var date = new Date(value);
			return date.getMonth() + 1 + "/" + date.getDate() + "/" + date.getFullYear();
		};
	},
	time: function time() {
		return function(value) {
			var date = new Date(value);
			var h = date.getHours() >= 10 ? date.getHours() : "0" + date.getHours();
			var m = date.getMinutes() >= 10 ? date.getMinutes() : "0" + date.getMinutes();
			return h + ":" + m;
		};
	},
	datetime: function datetime() {
		var date = formatFactory.date();
		var time = formatFactory.time();
		return function(value) {
			return date(value) + " " + time(value);
		};
	},
	ellipsis: function ellipsis(part0, length, where) {
		length = Number(length);
		if (!(length > 3)) length = 10;

		switch (where) {
			default:
			case "end":
				return function(value) {
					var s = String(value);
					if (s.length > length) return s.substring(0, length - 3) + "...";
					return s;
				};

			case "start":
				return function(value) {
					var s = String(value);
					if (s.length > length) return "..." + s.substring(s.length - length + 3);
					return s;
				};

			case "middle":
				return function(value) {
					var s = String(value);

					if (s.length > length) {
						var x = Math.floor(length - 2) / 2;
						return s.substring(0, x) + "..." + s.substring(s.length - (length - 3 - x));
					}

					return s;
				};
		}
	}
};
formatFactory.s = formatFactory.str = formatFactory.string;
formatFactory.f = formatFactory.fixed;
formatFactory.n = formatFactory.number;
formatFactory.p = formatFactory.percentage;
formatFactory.ps = formatFactory.percentageSign;
formatFactory.d = formatFactory.date;
formatFactory.t = formatFactory.time;
formatFactory.dt = formatFactory.datetime;

function buildFormatter(format) {
	var formatter = defaultFormatter,
		nullText = "";

	if (format) {
		var pipeParts = format.split("|");
		nullText = pipeParts[1] || "";
		var colonSepParts = pipeParts[0].split(":");

		for (var i = 0; i < colonSepParts.length; i++) {
			var parts = colonSepParts[i].split(";");
			var factory = formatFactory[parts[0]];
			if (!factory) debug("Unknown string format: " + format);
			else if (i == 0) formatter = factory.apply(void 0, parts);
			else {
				(function() {
					var outerFmt = factory.apply(void 0, parts);
					var innerFmt = formatter;

					formatter = function formatter(v) {
						return outerFmt(innerFmt(v));
					};
				})();
			}
		}
	}

	return function(v) {
		return v == null || v === "" ? nullText : formatter(v);
	};
}

var format = {
	cache: {}
};

function getFormatCache() {
	if (format.cacheIdentifier != GlobalCacheIdentifier.get()) {
		format = {
			cache: {},
			cacheIdentifier: GlobalCacheIdentifier.get()
		};
	}

	return format.cache;
}

function getFormatter(format) {
	if (!format) format = "";
	var formatCache = getFormatCache();
	var formatter = formatCache[format];
	if (!formatter) formatter = formatCache[format] = buildFormatter(format);
	return formatter;
}

var Format =
	/*#__PURE__*/
	(function() {
		function Format() {}

		Format.value = function value(v, format) {
			var formatter = getFormatter(format);
			return formatter(v);
		};

		Format.parse = function parse(format) {
			return getFormatter(format);
		};

		Format.register = function register(format, formatter) {
			this.registerFactory(format, function() {
				return formatter;
			});
		};

		Format.registerFactory = function registerFactory(format, factory) {
			var _this = this;

			if (isArray(format))
				format.forEach(function(f) {
					return _this.registerFactory(f, factory);
				});
			else formatFactory[format] = factory;
		};

		return Format;
	})();
function resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits) {
	minimumFractionDigits = minimumFractionDigits != null ? Number(minimumFractionDigits) : minimumFractionDigits;
	maximumFractionDigits = maximumFractionDigits != null ? Number(maximumFractionDigits) : maximumFractionDigits;

	if (isNumber(minimumFractionDigits)) {
		if (isUndefined(maximumFractionDigits)) maximumFractionDigits = minimumFractionDigits;
		else if (isNumber(maximumFractionDigits) && maximumFractionDigits < minimumFractionDigits)
			maximumFractionDigits = minimumFractionDigits;
	} else if (minimumFractionDigits == null && maximumFractionDigits == null) {
		minimumFractionDigits = 0;
		maximumFractionDigits = 18;
	}

	return {
		minimumFractionDigits: minimumFractionDigits,
		maximumFractionDigits: maximumFractionDigits
	};
}
function trimFractionZeros(str, max) {
	var cnt = 0,
		l = str.length;

	while (cnt < max && (str[l - 1 - cnt] === "0" || str[l - 1 - cnt] === ".")) {
		cnt++;
	}

	return cnt > 0 ? str.substring(0, l - cnt) : str;
}

function quoteStr(str) {
	if (str == null) return str;
	return "'" + str.replace(/'/g, "\\i") + "'";
}

function isDigit(x) {
	return x >= "0" && x <= "9";
}

/*
   Helper usage example

   Expression.registerHelper('_', _);
   let e = Expression.compile('_.min({data})');
 */

var expCache = {},
	helpers = {},
	helperNames = [],
	helperValues = [],
	expFatArrows = null;

function getExpr(expr) {
	if (expr.memoize) return expr;

	function memoize() {
		var lastValue,
			lastRunBindings = {},
			lastRunResults = {},
			getters = {},
			currentData,
			len = -1;

		var get = function get(bindingWithFormat) {
			var getter = getters[bindingWithFormat];

			if (!getter) {
				var binding = bindingWithFormat,
					format;
				var colonIndex = bindingWithFormat.indexOf(":");

				if (colonIndex != -1) {
					format = Format.parse(bindingWithFormat.substring(colonIndex + 1));
					binding = bindingWithFormat.substring(0, colonIndex);
				} else {
					var nullSeparatorIndex = bindingWithFormat.indexOf(":");

					if (nullSeparatorIndex != -1) {
						format = Format.parse(bindingWithFormat.substring(nullSeparatorIndex));
						binding = bindingWithFormat.substring(0, nullSeparatorIndex - 1);
					}
				}

				var b = Binding.get(binding);

				getter = function getter(data) {
					var value = b.value(data);
					lastRunBindings[len] = b.value;
					lastRunResults[len] = value;
					len++;
					return value;
				};

				if (format) {
					var valueGetter = getter;

					getter = function getter(data) {
						return format(valueGetter(data));
					};
				}

				getters[bindingWithFormat] = getter;
			}

			return getter(currentData);
		};

		return function(data) {
			var i = 0;

			for (; i < len; i++) {
				if (lastRunBindings[i](data) !== lastRunResults[i]) break;
			}

			if (i !== len) {
				len = 0;
				currentData = data;
				lastValue = expr(get);
			}

			return lastValue;
		};
	}

	var result = memoize();
	result.memoize = memoize;
	return result;
}

function expression(str) {
	var _ref;

	if (isFunction(str)) return getExpr(str);
	var r = expCache[str];
	if (r) return r;
	var quote = false;
	var termStart = -1,
		curlyBrackets = 0,
		percentExpression;
	var fb = ["return ("];
	var args = {};
	var formats = [];
	var subExpr = 0;

	for (var i = 0; i < str.length; i++) {
		var c = str[i];

		switch (c) {
			case "{":
				if (curlyBrackets > 0) curlyBrackets++;
				else {
					if (!quote && termStart < 0 && (str[i + 1] != "{" || str[i - 1] == "%")) {
						termStart = i + 1;
						curlyBrackets = 1;
						percentExpression = str[i - 1] == "%";
						if (percentExpression) fb.pop(); //%
					} else if (str[i - 1] != "{") fb.push(c);
				}
				break;

			case "}":
				if (termStart >= 0) {
					if (--curlyBrackets == 0) {
						var term = str.substring(termStart, i);
						var formatStart = 0;
						if (term[0] == "[") formatStart = term.indexOf("]");
						var colon = term.indexOf(":", formatStart > 0 ? formatStart : 0);
						var binding = colon == -1 ? term : term.substring(0, colon);
						var format = colon == -1 ? null : term.substring(colon + 1);

						if (colon == -1) {
							var nullSepIndex = binding.indexOf("|");

							if (nullSepIndex != -1) {
								format = binding.substring(nullSepIndex);
								binding = binding.substring(0, nullSepIndex);
							}
						}

						var argName = binding.replace(/\./g, "_");
						if (isDigit(argName[0])) argName = "$" + argName;

						if (percentExpression || (binding[0] == "[" && binding[binding.length - 1] == "]")) {
							argName = "expr" + ++subExpr;
							args[argName] = expression(percentExpression ? binding : binding.substring(1, binding.length - 1));
						} else args[argName] = binding;

						if (format) {
							var formatter = "fmt" + formats.length;
							fb.push(formatter, "(", argName, ", ", quoteStr(format), ")");
							formats.push(Format.parse(format));
						} else fb.push(argName);

						termStart = -1;
					}
				} else fb.push(c);

				break;

			case '"':
			case "'":
				if (curlyBrackets == 0) {
					if (!quote) quote = c;
					else if (str[i - 1] != "\\" && quote == c) quote = false;
					fb.push(c);
				}

				break;

			default:
				if (termStart < 0) fb.push(c);
				break;
		}
	}

	fb.push(")");
	var body = fb.join("");
	if (expFatArrows) body = expFatArrows(body); //console.log(body);

	var keys = Object.keys(args);

	var compute = (_ref = _construct(
		Function,
		formats
			.map(function(f, i) {
				return "fmt" + i;
			})
			.concat(keys, helperNames, [body])
	)).bind.apply(_ref, [Format].concat(formats, helperValues));

	var selector = computable.apply(
		void 0,
		keys
			.map(function(k) {
				return args[k];
			})
			.concat([compute])
	);
	expCache[str] = selector;
	return selector;
}
var Expression = {
	get: function get(str) {
		return expression(str);
	},
	compile: function compile(str) {
		return this.get(str).memoize();
	},
	registerHelper: function registerHelper(name, helper) {
		helpers[name] = helper;
		helperNames = Object.keys(helpers);
		helperValues = helperNames.map(function(n) {
			return helpers[n];
		});
	}
};
function plugFatArrowExpansion(impl) {
	expFatArrows = impl;
}
function invalidateExpressionCache() {
	expCache = {};
}

function plus(str) {
	return str.length ? str + " + " : str;
}

var tplCache = {};
function stringTemplate(str) {
	var expr = tplCache[str];
	if (expr) return expr;
	expr = "";
	var termStart = -1,
		quoteStart = 0,
		term,
		bracketsOpen = 0,
		percentSign;

	for (var i = 0; i < str.length; i++) {
		var c = str[i];

		switch (c) {
			case "{":
				if (termStart < 0) {
					if (str[i + 1] == "{" && str[i - 1] != "%") {
						expr = plus(expr) + quoteStr(str.substring(quoteStart, i) + "{");
						i++;
						quoteStart = i + 1;
					} else {
						termStart = i + 1;
						percentSign = str[i - 1] == "%";
						if (i > quoteStart) expr = plus(expr) + quoteStr(str.substring(quoteStart, percentSign ? i - 1 : i));
						bracketsOpen = 1;
					}
				} else bracketsOpen++;

				break;

			case "}":
				if (termStart >= 0) {
					if (--bracketsOpen == 0) {
						term = str.substring(termStart, i);

						if (term.indexOf(":") == -1) {
							var nullSepIndex = term.indexOf("|");
							if (nullSepIndex == -1) term += ":s";
							else term = term.substring(0, nullSepIndex) + ":s" + term.substring(nullSepIndex);
						}

						expr = plus(expr) + (percentSign ? "%{" : "{") + term + "}";
						termStart = -1;
						quoteStart = i + 1;
						bracketsOpen = 0;
					}
				} else if (str[i + 1] == "}") {
					expr = plus(expr) + quoteStr(str.substring(quoteStart, i) + "}");
					i++;
					quoteStart = i + 1;
				}

				break;
		}
	}

	if (quoteStart < str.length) expr = plus(expr) + quoteStr(str.substring(quoteStart)); //console.log(expr);

	return (tplCache[str] = expression(expr));
}
var StringTemplate = {
	get: function get(str) {
		return stringTemplate(str);
	},
	compile: function compile(str) {
		return stringTemplate(str).memoize();
	},
	format: function format(_format) {
		for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		return stringTemplate(_format)(args);
	}
};
function invalidateStringTemplateCache() {
	tplCache = {};
}

function createStructuredSelector(selector, constants) {
	var keys = Object.keys(selector);
	if (keys.length == 0)
		return function() {
			return constants;
		};

	function memoize() {
		var lastResult = Object.assign({}, constants);
		var memoizedSelectors = {};
		keys.forEach(function(key) {
			memoizedSelectors[key] = selector[key].memoize ? selector[key].memoize() : selector[key];
		});
		return function(data) {
			var result = lastResult,
				k,
				v,
				i;

			for (i = 0; i < keys.length; i++) {
				k = keys[i];
				v = memoizedSelectors[k](data);

				if (result === lastResult) {
					if (v === lastResult[k]) continue;
					result = Object.assign({}, lastResult);
				}

				result[k] = v;
			}

			return (lastResult = result);
		};
	}

	function evaluate(data) {
		var result = Object.assign({}, constants);

		for (var i = 0; i < keys.length; i++) {
			result[keys[i]] = selector[keys[i]](data);
		}

		return result;
	}

	evaluate.memoize = memoize;
	return evaluate;
}

function isSelector(config) {
	if (config == null) return true;

	switch (typeof config) {
		case "object":
			if (config.type || config.$type) return false;
			return !!(config.bind || config.tpl || config.expr || config.get);

		case "function":
			return true;

		case "string":
			return true;

		case "number":
			return true;

		case "boolean":
			return true;
	}

	return false;
}

var nullF = function nullF() {
	return null;
};

function getSelector(config) {
	if (config == null) return nullF;

	switch (typeof config) {
		case "object":
			if (isArray(config)) {
				var _selectors = config.map(function(x) {
					return getSelector(x);
				});

				return function(data) {
					return _selectors.map(function(elementSelector) {
						return elementSelector(data);
					});
				};
			}

			if (config.bind) return Binding.get(config.bind).value;
			if (config.tpl) return StringTemplate.get(config.tpl);
			if (config.expr) return Expression.get(config.expr);
			if (config.get) return config.get;
			var selectors = {};
			var constants = {};

			for (var key in config) {
				if (isSelector(config[key])) selectors[key] = getSelector(config[key]);
				else constants[key] = config[key];
			}

			return createStructuredSelector(selectors, constants);

		case "function":
			return config;

		default:
			return function() {
				return config;
			};
	}
}

function isDefined(v) {
	return v !== undefined;
}

function defaultValue(pv) {
	if (typeof pv == "object" && pv && pv.structured) return pv.defaultValue;
	return pv;
}

function getSelectorConfig(props, values, nameMap) {
	var functions = {},
		structures = {},
		defaultValues = {},
		constants,
		p,
		v,
		pv,
		constant = true;

	for (p in props) {
		v = values[p];
		pv = props[p];
		if (isUndefined(v) && pv && (pv.bind || pv.tpl || pv.expr)) v = pv;

		if (v === null) {
			if (!constants) constants = {};
			constants[p] = null;
		} else if (typeof v == "object") {
			if (v.bind) {
				if (isUndefined(v.defaultValue) && v != pv) v.defaultValue = defaultValue(pv);
				if (isDefined(v.defaultValue)) defaultValues[v.bind] = v.defaultValue;
				nameMap[p] = v.bind;
				functions[p] = Binding.get(v.bind).value;
				constant = false;
			} else if (v.expr) {
				functions[p] = Expression.get(v.expr);
				constant = false;
			} else if (v.get) {
				functions[p] = v.get;
				constant = false;
			} else if (v.tpl) {
				functions[p] = StringTemplate.get(v.tpl);
				constant = false;
			} else if (pv && typeof pv == "object" && pv.structured) {
				if (isArray(v)) functions[p] = getSelector(v);
				else {
					var s = getSelectorConfig(v, v, {});
					structures[p] = s;
					Object.assign(defaultValues, s.defaultValues);
				}
				constant = false;
			} else {
				if (!constants) constants = {};
				constants[p] = v;
			}
		} else if (isFunction(v)) {
			functions[p] = v;
			constant = false;
		} else {
			if (isUndefined(v)) {
				if (isUndefined(pv)) continue;
				v = defaultValue(pv);
			}

			if (isUndefined(v)) continue;
			if (!constants) constants = {};
			constants[p] = v;
		}
	}

	return {
		functions: functions,
		structures: structures,
		defaultValues: defaultValues,
		constants: constants,
		constant: constant
	};
}

function createSelector(_ref) {
	var functions = _ref.functions,
		structures = _ref.structures,
		constants = _ref.constants,
		defaultValues = _ref.defaultValues;
	var selector = {};

	for (var n in functions) {
		selector[n] = functions[n];
	}

	for (var _n in structures) {
		selector[_n] = createSelector(structures[_n]);
	}

	return createStructuredSelector(selector, constants);
}

var StructuredSelector =
	/*#__PURE__*/
	(function() {
		function StructuredSelector(_ref2) {
			var props = _ref2.props,
				values = _ref2.values;
			this.nameMap = {};
			this.config = getSelectorConfig(props, values, this.nameMap);
		}

		var _proto = StructuredSelector.prototype;

		_proto.init = function init(store) {
			store.init(this.config.defaultValues);
		};

		_proto.create = function create() {
			var selector = createSelector(this.config);
			if (selector.memoize) return selector.memoize();
			return selector;
		};

		_proto.createStoreSelector = function createStoreSelector() {
			if (this.config.constant) {
				var result = _objectSpread({}, this.config.constants);

				return function() {
					return result;
				};
			}

			var selector = this.create();
			return function(store) {
				return selector(store.getData());
			};
		};

		return StructuredSelector;
	})();

var VDOM$1 = VDOM;

var VDOM$2 = VDOM$1;
var widgetId = 100;
var Widget =
	/*#__PURE__*/
	(function(_Component) {
		_inheritsLoose(Widget, _Component);

		function Widget(config) {
			var _this;

			_this = _Component.call(this, config) || this;
			_this.widgetId = widgetId++;

			if (isArray(_this.jsxSpread)) {
				if (!_this.jsxAttributes) _this.jsxAttributes = [];

				_this.jsxSpread.forEach(function(spread) {
					for (var key in spread) {
						_this[key] = spread[key];

						_this.jsxAttributes.push(key);
					}
				});
			}

			return _this;
		}

		var _proto = Widget.prototype;

		_proto.init = function init() {
			if (this.styles) this.style = this.styles;
			if (this.styled) this.style = parseStyle(this.style);
			else if (this.style) {
				Console.warn(
					"Components that allow use of the style attribute should set styled = true on their prototype. This will be an error in future versions."
				);
				this.style = parseStyle(this.style);
				this.styled = true;
			}
			if (typeof this.if !== "undefined") this.visible = this.if;
			this.declareData();

			if (this.outerLayout) {
				if (isArray(this.outerLayout)) throw new Error("Only single element outer layout is supported."); //TODO: better handle the case when outer layout is an array. How to get around circular dependency to PureContainer

				this.outerLayout = Widget.create(this.outerLayout);
			}

			if (this.contentFor) this.putInto = this.contentFor;
			if (this.putInto) this.isContent = true;
			if (isString(this.CSS)) this.CSS = CSSHelper.get(this.CSS);
			this.initHelpers();
			this.initComponents();
			this.initialized = true;
		};

		_proto.initComponents = function initComponents() {
			if (arguments.length > 0) {
				this.components = Object.assign.apply(Object, arguments);

				for (var k in this.components) {
					if (!this.components[k]) delete this.components[k];
				}
			}
		};

		_proto.initHelpers = function initHelpers() {
			if (arguments.length > 0) {
				this.helpers = Object.assign.apply(Object, arguments);
			}
		};

		_proto.declareData = function declareData() {
			var options = {};
			if (this.styled)
				options.class = options.className = options.style = {
					structured: true
				};

			var props = _objectSpread(
				{
					visible: undefined,
					mod: {
						structured: true
					}
				},
				options
			);

			Object.assign.apply(Object, [props].concat(Array.prototype.slice.call(arguments)));
			this.selector = new StructuredSelector({
				props: props,
				values: this
			});
			this.nameMap = this.selector.nameMap;
		};

		_proto.prepareCSS = function prepareCSS(context, _ref) {
			var data = _ref.data;
			data.classNames = this.CSS.expand(
				this.CSS.block(this.baseClass, data.mod, data.stateMods),
				data.class,
				data.className
			);
			data.style = parseStyle(data.style);
		};

		_proto.prepareData = function prepareData(context, instance) {
			if (this.styled) this.prepareCSS(context, instance);
		};

		_proto.initInstance = function initInstance(context, instance) {
			if (this.onInit) this.onInit(context, instance);
		};

		_proto.initState = function initState(context, instance) {};

		_proto.checkVisible = function checkVisible(context, instance, data) {
			return data.visible;
		};

		_proto.explore = function explore(context, instance) {
			if (this.components) instance.components = {};

			for (var cmp in this.components) {
				var ins = instance.getChild(context, this.components[cmp], "cmp-" + cmp, instance.store);
				if (ins.scheduleExploreIfVisible(context)) instance.components[cmp] = ins;
			}
		};

		_proto.render = function render(context, instance, key) {
			throw new Error(
				"Widget's render method should be overridden. This error can happen if you forgot to import the component before using it."
			);
		};

		_proto.update = function update() {
			this.version = (this.version || 0) + 1;
		};

		Widget.resetCounter = function resetCounter() {
			widgetId = 100;
		};

		return Widget;
	})(Component);
Widget.prototype.visible = true;
Widget.prototype.memoize = true; //cache rendered content and use it if possible

Widget.prototype.CSS = "cx";
Widget.prototype.styled = false;
Widget.namespace = "ui.";
Widget.optimizePrepare = true;

Widget.factory = function(type, config, more) {
	throw new Error("Invalid widget type: " + type + ".");
};

function contentAppend(result, w, prependSpace) {
	if (w == null || w === false) return false;
	if (isArray(w))
		w.forEach(function(c) {
			return contentAppend(result, c);
		});
	else if (isDefined(w.content) && !w.atomic) return contentAppend(result, w.content);
	else {
		if (prependSpace) result.push(" ");
		result.push(w);
	}
	return true;
}
function getContentArray(x) {
	var result = [];
	contentAppend(result, x);
	return result;
}
function getContent(x) {
	var result = getContentArray(x);
	if (result.length == 0) return null;
	if (result.length == 1) return result[0];
	return result;
}

var Text =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(Text, _Widget);

		function Text() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = Text.prototype;

		_proto.init = function init() {
			if (!this.value && (this.tpl || this.expr || this.bind))
				this.value = {
					tpl: this.tpl,
					expr: this.expr,
					bind: this.bind
				};

			_Widget.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[
					this,
					{
						value: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.render = function render(context, _ref, key) {
			var data = _ref.data;
			return data.value != null ? data.value : "";
		};

		return Text;
	})(Widget);
Widget.alias("text", Text);

var StaticText =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(StaticText, _Widget);

		function StaticText() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = StaticText.prototype;

		_proto.render = function render() {
			return this.text;
		};

		return StaticText;
	})(Widget);
Widget.alias("static-text", StaticText);

function innerTextTrim(str) {
	str = str.replace(/\t/g, "");
	str = str.replace(/(\s*[\r\n]\s*)/g, "");
	return str;
}

function reverseSlice(array, start) {
	var last = array.length - 1;

	while (start < last) {
		var x = array[start];
		array[start] = array[last];
		array[last] = x;
		start++;
		last--;
	}
}

function exploreChildren(context, instance, children, previousResult, key, store, beforeCallback, afterCallback) {
	var newChildren = previousResult || [];
	var oldChildren = previousResult || newChildren;
	var identical = previousResult ? 0 : -1; // if (children.length)
	//    context.exploreStack.hop();

	for (var c = 0; c < children.length; c++) {
		var cell = instance.getChild(context, children[c], key, store); // if (beforeCallback)
		//    beforeCallback(cell);

		if (cell.checkVisible(context)) {
			if (identical >= 0) {
				if (cell == oldChildren[identical]) identical++;
				else {
					newChildren = newChildren.slice(0, identical);
					identical = -1;
					newChildren.push(cell);
				}
			} else newChildren.push(cell);

			context.exploreStack.push(cell);
			if (cell.needsExploreCleanup) context.exploreStack.push(cell);
		}
	}

	if (identical >= 0 && identical != newChildren.length) newChildren = newChildren.slice(0, identical);
	return newChildren;
}

var Container =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(Container, _Widget);

		function Container() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = Container.prototype;

		_proto.init = function init(context) {
			if (typeof this.ws !== "undefined") this.preserveWhitespace = this.ws;
			if (this.preserveWhitespace) this.trimWhitespace = false;
			var items = this.items || this.children || [];
			delete this.children;
			this.items = [];

			if (this.layout) {
				var layout = Widget.create({
					type: this.layout,
					items: items
				});
				layout.init(context);
				this.layout = null;

				if (layout.noLayout) {
					this.useParentLayout = true;
					this.add(items);
				} else {
					this.add(layout);
					this.layout = layout;
				}
			} else {
				this.add(items);
			}

			_Widget.prototype.init.call(this, context);
		};

		_proto.exploreItems = function exploreItems(context, instance, items) {
			instance.children = exploreChildren(context, instance, items, instance.cached.children);
			if (instance.cache("children", instance.children)) instance.markShouldUpdate(context);
		};

		_proto.explore = function explore(context, instance) {
			_Widget.prototype.explore.call(this, context, instance);

			this.exploreItems(context, instance, this.items);
		};

		_proto.render = function render(context, instance) {
			return this.renderChildren(context, instance);
		};

		_proto.renderChildren = function renderChildren(context, instance) {
			var preserveComplexContent = this.useParentLayout;

			function append(result, r) {
				if (r == null) return; //react element

				if (!r.hasOwnProperty("content")) {
					contentAppend(result, r);
					return;
				}

				if (r.useParentLayout)
					return r.content.forEach(function(x) {
						return append(result, x);
					});

				if (r.atomic || preserveComplexContent) {
					result.push(r);
				} else {
					var first = true;

					for (var k in r) {
						if (contentAppend(result, r[k], !first)) first = false;
					}
				}
			}

			var result = [];

			for (var i = 0; i < instance.children.length; i++) {
				append(result, instance.children[i].vdom);
			}

			if (this.useParentLayout)
				return {
					useParentLayout: true,
					content: result
				};
			return result;
		};

		_proto.clear = function clear() {
			if (this.layout) this.layout.clear();
			else this.items = [];
		};

		_proto.add = function add() {
			var _this$layout,
				_this = this;

			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			if (this.layout) return (_this$layout = this.layout).add.apply(_this$layout, args);
			args.forEach(function(a) {
				if (!a) return;
				if (isArray(a))
					a.forEach(function(c) {
						return _this.add(c);
					});
				else if (isString(a)) {
					if (_this.trimWhitespace) a = innerTextTrim(a);
					if (a) _this.addText(a);
				} else if (a.isComponent) _this.items.push(_this.wrapItem(a));
				else {
					_this.add(Widget.create(a, _this.itemDefaults));
				}
			});
		};

		_proto.wrapItem = function wrapItem(item) {
			return item;
		};

		_proto.addText = function addText(text) {
			if (this.plainText || text.indexOf("{") == -1 || text.indexOf("}") == -1)
				this.add(
					Widget.create(StaticText, {
						text: text
					})
				);
			else
				this.add(
					Widget.create(Text, {
						text: {
							tpl: text
						}
					})
				);
		};

		_proto.find = function find(filter, options) {
			if (!options) options = {};
			if (!filter || !this.items) return [];
			var alias = filter;
			if (isString(filter))
				filter = function filter(w) {
					return w.componentAlias == alias;
				};
			if (filter.isComponentType)
				filter = function filter(w) {
					return w instanceof alias;
				};
			var results = [];

			for (var i = 0; i < this.items.length; i++) {
				var w = this.items[i];
				if (!w.initialized) w.init();

				if (filter(w)) {
					results.push(w);
					if (options.first) break;
				}

				if (w.find) results.push.apply(results, w.find(filter, options));
			}

			return results;
		};

		_proto.findFirst = function findFirst(filter, options) {
			return this.find(
				filter,
				_objectSpread({}, options, {
					first: true
				})
			)[0];
		};

		return Container;
	})(Widget);
Container.prototype.trimWhitespace = true;
Container.prototype.plainText = true;
Container.prototype.styled = false;

var PureContainer =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(PureContainer, _Container);

		function PureContainer() {
			return _Container.apply(this, arguments) || this;
		}

		return PureContainer;
	})(Container);
PureContainer.prototype.isPureContainer = true;
PureContainer.alias("pure-container", PureContainer);

var IsolatedScope =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(IsolatedScope, _PureContainer);

		function IsolatedScope() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = IsolatedScope.prototype;

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						data: {
							structured: true
						}
					}
				])
			);
		};

		_proto.init = function init() {
			var _this = this;

			if (typeof this.bind === "string")
				this.data = {
					bind: this.bind
				};
			else if (isArray(this.bind)) {
				this.data = {};
				this.bind.forEach(function(x, i) {
					_this.data[String(i)] = {
						bind: x
					};
				});
			}

			_PureContainer.prototype.init.call(this);
		};

		_proto.explore = function explore(context, instance) {
			if (instance.shouldUpdate) {
				_PureContainer.prototype.explore.call(this, context, instance);
			}
		};

		return IsolatedScope;
	})(PureContainer);

var Ref =
	/*#__PURE__*/
	(function(_Component) {
		_inheritsLoose(Ref, _Component);

		function Ref(config) {
			var _context;

			var _this;

			_this = _Component.call(this, config) || this;
			_this.get = (_context = _this).get.bind(_context);
			_this.set = (_context = _this).set.bind(_context);
			return _this;
		}

		var _proto = Ref.prototype;

		_proto.get = function get() {
			return this.store.get(this.path);
		};

		_proto.set = function set(value) {
			return this.store.set(this.path, value);
		};

		_proto.init = function init(value) {
			return this.store.init(this.path, value);
		};

		_proto.toggle = function toggle() {
			return this.store.toggle(this.path);
		};

		_proto.delete = function _delete() {
			return this.store.delete(this.path);
		};

		_proto.update = function update() {
			var _this$store;

			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return (_this$store = this.store).update.apply(_this$store, [this.path].concat(args));
		};

		_proto.as = function as(config) {
			return Ref.create(config, {
				store: this.store,
				path: this.path
			});
		}; //allows the function to be passed as a selector, e.g. to computable or addTrigger

		_proto.memoize = function memoize() {
			return this.get;
		};

		return Ref;
	})(Component);

Ref.factory = function(alias, config, more) {
	if (isFunction(alias)) {
		var cfg = _objectSpread({}, config, more);

		if (cfg.store) Object.assign(cfg, cfg.store.getMethods());
		var result = alias(cfg);
		if (result instanceof Ref) return result;
		return Ref.create(_objectSpread({}, config, more, result));
	}

	return Ref.create(_objectSpread({}, config, more));
};

var View =
	/*#__PURE__*/
	(function() {
		function View(config) {
			Object.assign(this, config);
			this.cache = {
				version: -1
			};
			if (this.store) this.setStore(this.store);
		}

		var _proto = View.prototype;

		_proto.getData = function getData() {
			throw new Error("abstract method");
		};

		_proto.init = function init(path, value) {
			if (path instanceof Binding) path = path.path;
			else if (typeof path == "object" && path != null) {
				var changed = false;

				for (var key in path) {
					if (path.hasOwnProperty(key) && this.get(key) === undefined && this.setItem(key, path[key])) changed = true;
				}

				return changed;
			}
			if (this.get(path) === undefined) return this.setItem(path, value);
			return false;
		};

		_proto.set = function set(path, value) {
			if (path instanceof Binding) path = path.path;
			else if (typeof path == "object" && path != null) {
				var changed = false;

				for (var key in path) {
					if (path.hasOwnProperty(key) && this.setItem(key, path[key])) changed = true;
				}

				return changed;
			}
			return this.setItem(path, value);
		};

		_proto.copy = function copy(from, to) {
			var value = this.get(from);
			this.set(to, value);
		};

		_proto.move = function move(from, to) {
			var _this = this;

			this.batch(function() {
				_this.copy(from, to);

				_this.delete(from);
			});
		}; //protected

		_proto.setItem = function setItem(path, value) {
			if (this.store) return this.store.setItem(path, value);
			throw new Error("abstract method");
		};

		_proto.delete = function _delete(path) {
			var _this2 = this;

			if (path instanceof Binding) path = path.path;
			else if (arguments.length > 1) path = Array.from(arguments);
			if (isArray(path))
				return path
					.map(function(arg) {
						return _this2.deleteItem(arg);
					})
					.some(Boolean);
			return this.deleteItem(path);
		}; //protected

		_proto.deleteItem = function deleteItem(path) {
			if (this.store) return this.store.deleteItem(path);
			throw new Error("abstract method");
		};

		_proto.clear = function clear() {
			if (this.store) return this.store.clear();
			throw new Error("abstract method");
		};

		_proto.get = function get(path) {
			var storeData = this.getData();
			if (arguments.length > 1) path = Array.from(arguments);
			if (isArray(path))
				return path.map(function(arg) {
					return Binding.get(arg).value(storeData);
				});
			return Binding.get(path).value(storeData);
		};

		_proto.toggle = function toggle(path) {
			return this.set(path, !this.get(path));
		};

		_proto.update = function update(path, updateFn) {
			for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
				args[_key - 2] = arguments[_key];
			}

			return this.set(path, updateFn.apply(null, [this.get(path)].concat(args)));
		};

		_proto.batch = function batch(callback) {
			var dirty = this.silently(callback);
			if (dirty) this.notify();
			return dirty;
		};

		_proto.silently = function silently(callback) {
			if (this.store) return this.store.silently(callback);
			throw new Error("abstract method");
		};

		_proto.notify = function notify(path) {
			if (this.notificationsSuspended) this.dirty = true;
			else this.doNotify(path);
		};

		_proto.doNotify = function doNotify(path) {
			if (this.store) return this.store.notify(path);
			throw new Error("abstract method");
		};

		_proto.subscribe = function subscribe(callback) {
			if (this.store) return this.store.subscribe(callback);
			throw new Error("abstract method");
		};

		_proto.load = function load(data) {
			return this.batch(function(store) {
				for (var key in data) {
					store.set(key, data[key]);
				}
			});
		};

		_proto.dispatch = function dispatch(action) {
			if (this.store) return this.store.dispatch(action);
			throw new Error("The underlying store doesn't support dispatch.");
		};

		_proto.getMeta = function getMeta() {
			return this.meta;
		};

		_proto.setStore = function setStore(store) {
			this.store = store;
			this.meta = store.getMeta();
		};

		_proto.ref = function ref(path, defaultValue) {
			if (isDefined(defaultValue)) this.init(path, defaultValue);
			return Ref.create({
				store: this,
				path: path
			});
		};

		_proto.getMethods = function getMethods() {
			return {
				getData: this.getData.bind(this),
				set: this.set.bind(this),
				get: this.get.bind(this),
				update: this.update.bind(this),
				delete: this.delete.bind(this),
				toggle: this.toggle.bind(this),
				init: this.init.bind(this),
				ref: this.ref.bind(this)
			};
		};

		return View;
	})();
View.prototype.sealed = false; //indicate that data should be copied before virtual items are added

var SubscriberList =
	/*#__PURE__*/
	(function() {
		function SubscriberList() {
			this.clear();
		}

		var _proto = SubscriberList.prototype;

		_proto.getSlot = function getSlot() {
			if (this.freeSlots.length) return this.freeSlots.pop();
			var slot = String(this.nextSlot++);
			return slot;
		};

		_proto.recycle = function recycle(slot, callback) {
			if (this.subscriptions[slot] === callback) {
				this.freeSlots.push(slot);
				delete this.subscriptions[slot];
				this.subscriptionCount--;
			}
		};

		_proto.subscribe = function subscribe(callback) {
			var _this = this;

			var slot = this.getSlot();
			this.subscriptions[slot] = callback;
			this.subscriptionCount++;
			return function() {
				_this.recycle(slot, callback);
			};
		};

		_proto.clear = function clear() {
			this.subscriptions = {};
			this.freeSlots = [];
			this.nextSlot = 1;
			this.subscriptionCount = 0;
		};

		_proto.isEmpty = function isEmpty() {
			return this.subscriptionCount == 0;
		};

		_proto.getSubscribers = function getSubscribers() {
			var result = [];

			for (var key in this.subscriptions) {
				result.push(this.subscriptions[key]);
			}

			return result;
		};

		_proto.notify = function notify() {
			for (var key in this.subscriptions) {
				var _this$subscriptions;

				(_this$subscriptions = this.subscriptions)[key].apply(_this$subscriptions, arguments);
			}
		};

		_proto.execute = function execute(callback) {
			for (var key in this.subscriptions) {
				callback(this.subscriptions[key]);
			}
		};

		return SubscriberList;
	})();

var SubscribableView =
	/*#__PURE__*/
	(function(_View) {
		_inheritsLoose(SubscribableView, _View);

		function SubscribableView(config) {
			var _this;

			_this = _View.call(this, config) || this;
			_this.subscribers = new SubscriberList();
			_this.changes = [];
			return _this;
		}

		var _proto = SubscribableView.prototype;

		_proto.subscribe = function subscribe(callback) {
			return this.subscribers.subscribe(callback);
		};

		_proto.unsubscribeAll = function unsubscribeAll() {
			this.subscribers.clear();
		};

		_proto.doNotify = function doNotify(path) {
			var _this2 = this;

			if (this.notificationsSuspended) return;

			if (!this.async) {
				this.subscribers.notify([path]);
			} else {
				this.changes.push(path || "");

				if (!this.scheduled) {
					this.scheduled = true;
					setTimeout(function() {
						_this2.scheduled = false;
						var changes = _this2.changes;
						_this2.changes = [];

						_this2.subscribers.notify(changes);
					}, 0);
				}
			}
		};

		_proto.silently = function silently(callback) {
			this.notificationsSuspended = (this.notificationsSuspended || 0) + 1;
			var wasDirty = this.dirty,
				dirty;
			this.dirty = false;

			try {
				callback(this);
			} finally {
				this.notificationsSuspended--;
				dirty = this.dirty;
				this.dirty = wasDirty;
			}

			return dirty;
		};

		return SubscribableView;
	})(View);
SubscribableView.prototype.async = false;

var StoreProxy =
	/*#__PURE__*/
	(function(_View) {
		_inheritsLoose(StoreProxy, _View);

		function StoreProxy(getStore) {
			var _this;

			_this =
				_View.call(this, {
					store: getStore()
				}) || this;
			Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "store", {
				get: getStore
			});
			return _this;
		}

		var _proto = StoreProxy.prototype;

		_proto.getData = function getData() {
			return this.store.getData();
		};

		return StoreProxy;
	})(View);

var computablePrefix = "computable-";
var triggerPrefix = "trigger-";
var Controller =
	/*#__PURE__*/
	(function(_Component) {
		_inheritsLoose(Controller, _Component);

		function Controller() {
			return _Component.apply(this, arguments) || this;
		}

		var _proto = Controller.prototype;

		_proto.init = function init(context) {
			if (!this.initialized) {
				this.initialized = true;
				if (this.onInit) this.onInit(context);
			}
		};

		_proto.explore = function explore(context) {
			var store = this.instance.store;
			this.store = store; //in rare cases instance may change its store

			if (!this.initialized) {
				this.init(context); //forgive if the developer forgets to call super.init()

				this.initialized = true;
			}

			if (this.computables) {
				for (var key in this.computables) {
					var x = this.computables[key];
					var v = x.selector(store.getData());
					if (x.type == "computable") store.set(x.name, v);
				}
			}

			if (this.onExplore) {
				this.onExplore(context);
			}
		};

		_proto.prepare = function prepare(context) {
			if (this.onPrepare) {
				this.onPrepare(context);
			}
		};

		_proto.cleanup = function cleanup(context) {
			if (this.onCleanup) {
				this.onCleanup(context);
			}
		};

		_proto.addComputable = function addComputable(name, args, callback) {
			if (!isArray(args)) throw new Error("Second argument to the addComputable method should be an array.");
			var selector = computable.apply(void 0, args.concat([callback])).memoize();
			if (!this.computables) this.computables = {};
			this.computables[computablePrefix + name] = {
				name: name,
				selector: selector,
				type: "computable"
			};
		};

		_proto.addTrigger = function addTrigger(name, args, callback, autoRun) {
			if (!isArray(args)) throw new Error("Second argument to the addTrigger method should be an array.");
			var selector = computable.apply(void 0, args.concat([callback])).memoize(false, !autoRun && this.store.getData());
			if (!this.computables) this.computables = {};
			this.computables[triggerPrefix + name] = {
				name: name,
				selector: selector,
				type: "trigger"
			};
		};

		_proto.removeTrigger = function removeTrigger(name) {
			if (this.computables) delete this.computables[triggerPrefix + name];
		};

		_proto.removeComputable = function removeComputable(name) {
			if (this.computables) delete this.computables[computablePrefix + name];
		};

		_proto.invokeParentMethod = function invokeParentMethod(methodName) {
			var _this$instance;

			for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}

			return (_this$instance = this.instance).invokeControllerMethod.apply(_this$instance, [methodName].concat(args));
		};

		return Controller;
	})(Component);
Controller.namespace = "ui.controller.";

Controller.factory = function(alias, config, more) {
	if (isFunction(alias)) {
		var cfg = _objectSpread({}, config, more);

		if (cfg.instance) {
			//in rare cases instance.store may change, so we cannot rely on the store passed through configuration
			cfg.store = new StoreProxy(function() {
				return cfg.instance.store;
			});
			Object.assign(cfg, cfg.store.getMethods());
		}

		var result = alias(cfg);
		if (result instanceof Controller) return result;
		return Controller.create(_objectSpread({}, config, more, result));
	}

	return Controller.create(_objectSpread({}, config, more));
};

function throttle(callback, delay) {
	var timer, context, args;
	return function() {
		context = this;
		args = arguments;
		if (!timer)
			timer = setTimeout(function() {
				callback.apply(context, args);
				timer = null;
			}, delay);
	};
}

function debounce(callback, delay) {
	var timer;
	return function() {
		var context = this,
			args = arguments;
		clearTimeout(timer);
		timer = setTimeout(function() {
			callback.apply(context, args);
		}, delay);
	};
}

var isBatching = 0;
var promiseSubscribers = new SubscriberList();
function batchUpdates(callback) {
	if (VDOM$2.DOM.unstable_batchedUpdates)
		VDOM$2.DOM.unstable_batchedUpdates(function() {
			isBatching++;

			try {
				callback();
			} finally {
				isBatching--;
			}
		});
	else callback();
}
function isBatchingUpdates() {
	return isBatching > 0;
}
function notifyBatchedUpdateStarting() {
	promiseSubscribers.execute(function(x) {
		x.pending++;
	});
}
function notifyBatchedUpdateCompleted() {
	promiseSubscribers.execute(function(x) {
		x.finished++;
		if (x.finished >= x.pending) x.complete(true);
	});
}
var updateId = 0;
function batchUpdatesAndNotify(callback, notifyCallback, timeout) {
	if (timeout === void 0) {
		timeout = 1000;
	}

	var update = {
		id: ++updateId,
		pending: 0,
		finished: 0,
		done: false
	};
	update.unsubscribe = promiseSubscribers.subscribe(update);

	update.complete = function(success) {
		if (!update.done) {
			update.done = true;
			if (update.timer) clearInterval(update.timer);
			update.unsubscribe();
			notifyCallback(!!success);
		}
	};

	batchUpdates(callback);
	if (update.pending <= update.finished) update.complete(true);
	else update.timer = setTimeout(update.complete, timeout);
}

function isNonEmptyArray(x) {
	return Array.isArray(x) && x.length > 0;
}

var instanceId = 1000;
var Instance =
	/*#__PURE__*/
	(function() {
		function Instance(widget, key, parent, store) {
			this.widget = widget;
			this.key = key;
			this.id = String(++instanceId);
			this.cached = {};
			this.parent = parent;
			this.store = store;
		}

		var _proto = Instance.prototype;

		_proto.setStore = function setStore(store) {
			this.store = store;
		};

		_proto.init = function init(context) {
			//widget is initialized when first instance is initialized
			if (!this.widget.initialized) {
				this.widget.init(context);
				this.widget.initialized = true;
			}

			if (!this.dataSelector) {
				this.widget.selector.init(this.store);
				this.dataSelector = this.widget.selector.createStoreSelector();
			} //init instance might change the store, so it must go before the controller

			this.widget.initInstance(context, this);
			this.widget.initState(context, this);
			if (this.widget.controller)
				this.controller = Controller.create(this.widget.controller, {
					widget: this.widget,
					instance: this,
					store: this.store
				});
			if (
				this.widget.exploreCleanup ||
				this.widget.outerLayout ||
				this.widget.isContent ||
				this.widget.controller ||
				this.widget.prepareCleanup
			)
				this.needsExploreCleanup = true;
			if (this.widget.prepare || this.widget.controller) this.needsPrepare = true;
			if (this.widget.cleanup || this.widget.controller) this.needsCleanup = true;
			this.initialized = true;
		};

		_proto.checkVisible = function checkVisible(context) {
			if (!this.initialized) this.init(context);
			var wasVisible = this.visible;
			this.rawData = this.dataSelector(this.store);
			this.visible = this.widget.checkVisible(context, this, this.rawData);
			this.explored = false;
			this.prepared = false;
			if (!this.visible && wasVisible) this.destroy();
			return this.visible;
		};

		_proto.scheduleExploreIfVisible = function scheduleExploreIfVisible(context) {
			if (this.checkVisible(context)) {
				context.exploreStack.push(this);
				if (this.needsExploreCleanup) context.exploreStack.push(this);
				return true;
			}

			return false;
		};

		_proto.cache = function cache(key, value) {
			var oldValue = this.cached[key];
			if (oldValue === value) return false;
			if (!this.cacheList) this.cacheList = {};
			this.cacheList[key] = value;
			return true;
		};

		_proto.markShouldUpdate = function markShouldUpdate(context) {
			var ins = this;
			var renderList = this.renderList;
			renderList.markReverseIndex(); //notify all parents that child state changed to bust up caching

			while (ins && !ins.shouldUpdate && ins.explored) {
				if (ins.renderList !== renderList) {
					renderList.reverse();
					renderList = ins.renderList;
					renderList.markReverseIndex();
				}

				ins.shouldUpdate = true;
				renderList.data.push(ins);
				ins = ins.widget.isContent
					? ins.contentPlaceholder
					: ins.parent.outerLayout === ins ? ins.parent.parent : ins.parent;
			}

			renderList.reverse();
		};

		_proto.explore = function explore(context) {
			if (!this.visible) throw new Error("Explore invisible!");

			if (this.explored) {
				if (this.widget.prepareCleanup) context.prepareList.push(this);
				if (this.widget.exploreCleanup) this.widget.exploreCleanup(context, this);
				if (this.parent.outerLayout === this) context.popNamedValue("content", "body");
				if (this.widget.controller) context.pop("controller");
				return;
			}

			this.explored = true;
			if (this.needsPrepare) context.prepareList.push(this);
			else this.prepared = true;
			if (this.needsCleanup) context.cleanupList.push(this);
			if (this.instanceCache) this.instanceCache.mark(); //controller may reconfigure the widget and need to go before shouldUpdate calculation

			this.parentOptions = context.parentOptions;

			if (!this.controller) {
				if (context.controller) this.controller = context.controller;
				else if (this.parent.controller) this.controller = this.parent.controller;
			}

			this.destroyTracked = false;

			if (this.controller) {
				if (this.widget.controller) {
					if (!this.controller.initialized) {
						this.controller.init(context);
						this.controller.initialized = true;
					}

					context.push("controller", this.controller);
					this.controller.explore(context);
					if (this.controller.onDestroy && this.controller.widget == this.widget) this.trackDestroy();
				}
			}

			if (this.widget.onDestroy || isNonEmptyArray(this.destroySubscriptions)) this.trackDestroy();
			this.renderList = this.assignedRenderList || this.parent.renderList || context.getRootRenderList();
			var shouldUpdate =
				this.rawData !== this.cached.rawData ||
				this.state !== this.cached.state ||
				this.widget.version !== this.cached.widgetVersion ||
				this.cached.globalCacheIdentifier !== GlobalCacheIdentifier.get();

			if (shouldUpdate) {
				this.data = _objectSpread({}, this.rawData);
				this.widget.prepareData(context, this);
				debug(processDataFlag, this.widget);
			} //onExplore might set the outer layout

			if (this.widget.onExplore) this.widget.onExplore(context, this);

			if (this.parent.outerLayout === this) {
				this.renderList = this.renderList.insertRight();
				context.pushNamedValue("content", "body", this.parent);
			}

			if (this.widget.outerLayout) {
				this.outerLayout = this.getChild(context, this.widget.outerLayout, null, this.store);
				this.outerLayout.scheduleExploreIfVisible(context);
				this.renderList = this.renderList.insertLeft();
			}

			if (this.widget.isContent) {
				this.contentPlaceholder = context.contentPlaceholder && context.contentPlaceholder[this.widget.putInto];
				if (this.contentPlaceholder) context.contentPlaceholder[this.widget.putInto](this);
				else {
					context.pushNamedValue("content", this.widget.putInto, this);
				}
			}

			this.shouldUpdate = false;
			if (shouldUpdate || this.childStateDirty || !this.widget.memoize) this.markShouldUpdate(context);
			context.exploreStack.hop();

			if (this.widget.helpers) {
				this.helpers = {};

				for (var cmp in this.widget.helpers) {
					var helper = this.widget.helpers[cmp];

					if (helper) {
						var ins = this.getChild(context, helper);
						if (ins.scheduleExploreIfVisible(context)) this.helpers[cmp] = ins;
					}
				}
			}

			this.widget.explore(context, this, this.data);
		};

		_proto.prepare = function prepare(context) {
			if (!this.visible) throw new Error("Prepare invisible!");

			if (this.prepared) {
				if (this.widget.prepareCleanup) this.widget.prepareCleanup(context, this);
				return;
			}

			this.prepared = true;
			if (this.widget.prepare) this.widget.prepare(context, this);
			if (this.widget.controller && this.controller.prepare) this.controller.prepare(context);
		};

		_proto.render = function render(context) {
			if (!this.visible) throw new Error("Render invisible!");

			if (this.shouldUpdate) {
				debug(renderFlag, this.widget, this.key);
				var vdom = renderResultFix(this.widget.render(context, this, this.key));
				if (this.widget.isContent || this.outerLayout) this.contentVDOM = vdom;
				else this.vdom = vdom;
			}

			if (this.cacheList)
				for (var key in this.cacheList) {
					this.cached[key] = this.cacheList[key];
				}
			this.cacheList = null;
			this.cached.rawData = this.rawData;
			this.cached.data = this.data;
			this.cached.state = this.state;
			this.cached.widgetVersion = this.widget.version;
			this.cached.globalCacheIdentifier = GlobalCacheIdentifier.get();
			this.childStateDirty = false;
			if (this.instanceCache) this.instanceCache.sweep();

			if (this.parent.outerLayout === this) {
				//if outer layouts are chained we need to find the originating element (last element with OL set)
				var parent = this.parent;

				while (parent.parent.outerLayout == parent) {
					parent = parent.parent;
				}

				parent.vdom = this.vdom;
			}

			return this.vdom;
		};

		_proto.cleanup = function cleanup(context) {
			if (this.widget.controller && this.controller.cleanup) this.controller.cleanup(context);
			if (this.widget.cleanup) this.widget.cleanup(context, this);
		};

		_proto.trackDestroy = function trackDestroy() {
			if (!this.destroyTracked) {
				this.destroyTracked = true;
				if (this.parent && !this.detached) this.parent.trackDestroyableChild(this);
			}
		};

		_proto.trackDestroyableChild = function trackDestroyableChild(child) {
			this.instanceCache.trackDestroy(child);
			this.trackDestroy();
		};

		_proto.subscribeOnDestroy = function subscribeOnDestroy(callback) {
			var _this = this;

			if (!this.destroySubscriptions) this.destroySubscriptions = [];
			this.destroySubscriptions.push(callback);
			this.trackDestroy();
			return function() {
				_this.destroySubscriptions &&
					_this.destroySubscriptions.filter(function(cb) {
						return cb != callback;
					});
			};
		};

		_proto.destroy = function destroy() {
			if (this.instanceCache) {
				this.instanceCache.destroy();
				delete this.instanceCache;
			}

			if (this.destroySubscriptions) {
				this.destroySubscriptions.forEach(function(cb) {
					return cb();
				});
				this.destroySubscriptions = null;
			}

			if (this.destroyTracked) {
				debug(destroyFlag, this);
				if (this.widget.onDestroy) this.widget.onDestroy(this);
				if (
					this.widget.controller &&
					this.controller &&
					this.controller.onDestroy &&
					this.controller.widget == this.widget
				)
					this.controller.onDestroy();
				this.destroyTracked = false;
			}
		};

		_proto.setState = function setState(state) {
			var _this2 = this;

			var skip = !!this.state;
			if (this.state)
				for (var k in state) {
					if (this.state[k] !== state[k]) {
						skip = false;
						break;
					}
				}
			if (skip) return;
			this.state = Object.assign({}, this.state, state);
			var parent = this.parent; //notify all parents that child state change to bust up caching

			while (parent) {
				parent.childStateDirty = true;
				parent = parent.parent;
			}

			batchUpdates(function() {
				_this2.store.notify();
			});
		};

		_proto.set = function set(prop, value) {
			var _this3 = this;

			var setter = this.setters && this.setters[prop];

			if (setter) {
				setter(value);
				return true;
			}

			var p = this.widget[prop];

			if (p && typeof p == "object") {
				if (p.debounce) {
					this.definePropertySetter(
						prop,
						debounce(function(value) {
							return _this3.doSet(prop, value);
						}, p.debounce)
					);
					this.set(prop, value);
					return true;
				}

				if (p.throttle) {
					this.definePropertySetter(
						prop,
						throttle(function(value) {
							return _this3.doSet(prop, value);
						}, p.throttle)
					);
					this.set(prop, value);
					return true;
				}
			}

			return this.doSet(prop, value);
		};

		_proto.definePropertySetter = function definePropertySetter(prop, setter) {
			if (!this.setters) this.setters = {};
			this.setters[prop] = setter;
		};

		_proto.doSet = function doSet(prop, value) {
			var _this4 = this;

			var changed = false;
			batchUpdates(function() {
				var p = _this4.widget[prop];

				if (isObject(p)) {
					if (p.set) {
						if (isFunction(p.set)) {
							p.set(value, _this4);
							changed = true;
						} else if (isString(p.set)) {
							_this4.controller[p.set](value, _this4);

							changed = true;
						}
					} else if (p.action) {
						var action = p.action(value, _this4);

						_this4.store.dispatch(action);

						changed = true;
					} else if (isString(p.bind)) {
						changed = _this4.store.set(p.bind, value);
					}
				}
			});
			return changed;
		};

		_proto.replaceState = function replaceState(state) {
			this.cached.state = this.state;
			this.state = state;
			this.store.notify();
		};

		_proto.getInstanceCache = function getInstanceCache() {
			if (!this.instanceCache)
				this.instanceCache = new InstanceCache(this, this.widget.isPureContainer ? this.key : null);
			return this.instanceCache;
		};

		_proto.clearChildrenCache = function clearChildrenCache() {
			if (this.instanceCache) this.instanceCache.destroy();
		};

		_proto.getChild = function getChild(context, widget, key, store) {
			return this.getInstanceCache().getChild(widget, store || this.store, key);
		};

		_proto.getDetachedChild = function getDetachedChild(widget, key, store) {
			var child = new Instance(widget, key, this, store || this.store);
			child.detached = true;
			return child;
		};

		_proto.prepareRenderCleanupChild = function prepareRenderCleanupChild(widget, store, keyPrefix, options) {
			return widget.prepareRenderCleanup(store || this.store, options, keyPrefix, this);
		};

		_proto.getJsxEventProps = function getJsxEventProps() {
			var _this5 = this;

			var widget = this.widget;
			if (!isArray(widget.jsxAttributes)) return null;
			var props = {};
			widget.jsxAttributes.forEach(function(attr) {
				if (attr.indexOf("on") == 0 && attr.length > 2)
					props[attr] = function(e) {
						return _this5.invoke(attr, e, _this5);
					};
			});
			return props;
		};

		_proto.getCallback = function getCallback(methodName) {
			var scope = this.widget;
			var callback = scope[methodName];
			if (typeof callback === "string") return this.getControllerMethod(callback);
			if (typeof callback !== "function")
				throw new Error("Cannot invoke callback method " + methodName + " as assigned value is not a function.");
			return callback.bind(scope);
		};

		_proto.getControllerMethod = function getControllerMethod(methodName) {
			if (!this.controller)
				throw new Error(
					'Cannot invoke controller method "' + methodName + '" as controller is not assigned to the widget.'
				);
			var at = this;

			while (at != null && at.controller && !at.controller[methodName]) {
				at = at.parent;
			}

			if (!at || !at.controller || !at.controller[methodName])
				throw new Error(
					'Cannot invoke controller method "' +
						methodName +
						'". The method cannot be found in any of the assigned controllers.'
				);
			return at.controller[methodName].bind(at.controller);
		};

		_proto.invoke = function invoke(methodName) {
			for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}

			return this.getCallback(methodName).apply(null, args);
		};

		_proto.invokeControllerMethod = function invokeControllerMethod(methodName) {
			for (
				var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;
				_key2 < _len2;
				_key2++
			) {
				args[_key2 - 1] = arguments[_key2];
			}

			return this.getControllerMethod(methodName).apply(null, args);
		};

		return Instance;
	})();

function renderResultFix(res) {
	return res != null && isDefined(res.content)
		? res
		: {
				content: res
			};
}

var InstanceCache =
	/*#__PURE__*/
	(function() {
		function InstanceCache(parent, keyPrefix) {
			this.children = {};
			this.parent = parent;
			this.marked = {};
			this.monitored = null;
			this.keyPrefix = keyPrefix != null ? keyPrefix + "-" : "";
		}

		var _proto2 = InstanceCache.prototype;

		_proto2.getChild = function getChild(widget, store, key) {
			var k = this.keyPrefix + (key != null ? key : widget.widgetId);
			var instance = this.children[k];

			if (!instance || (!instance.visible && (instance.widget.controller || instance.widget.onInit))) {
				instance = new Instance(widget, k, this.parent);
				this.children[k] = instance;
			}

			if (instance.store !== store) instance.setStore(store);
			this.marked[k] = instance;
			return instance;
		};

		_proto2.mark = function mark() {
			this.marked = {};
		};

		_proto2.trackDestroy = function trackDestroy(instance) {
			if (!this.monitored) this.monitored = {};
			this.monitored[instance.key] = instance;
		};

		_proto2.destroy = function destroy() {
			this.children = {};
			this.marked = {};
			if (!this.monitored) return;

			for (var key in this.monitored) {
				this.monitored[key].destroy();
			}

			this.monitored = null;
		};

		_proto2.sweep = function sweep() {
			this.children = this.marked;
			if (!this.monitored) return;
			var activeCount = 0;

			for (var key in this.monitored) {
				var monitoredChild = this.monitored[key];
				var child = this.children[key];

				if (child !== monitoredChild || !monitoredChild.visible) {
					monitoredChild.destroy();
					delete this.monitored[key];
					if (child === monitoredChild) delete this.children[key];
				} else activeCount++;
			}

			if (activeCount === 0) this.monitored = null;
		};

		return InstanceCache;
	})();

var TraversalStack =
	/*#__PURE__*/
	(function() {
		function TraversalStack() {
			this.data = [];
		}

		var _proto = TraversalStack.prototype;

		_proto.push = function push(node) {
			if (this.data.length == 0) this.hop();
			this.data[this.data.length - 1].elements.push(node);
		};

		_proto.hop = function hop() {
			this.data.push({
				elements: [],
				index: 0
			});
		};

		_proto.pop = function pop() {
			while (this.data.length > 0) {
				var line = this.data[this.data.length - 1];

				if (line.index < line.elements.length) {
					line.index++;
					return line.elements[line.index - 1];
				}

				this.data.pop();
			}

			return null;
		};

		_proto.empty = function empty() {
			while (this.data.length > 0) {
				var line = this.data[this.data.length - 1];
				if (line.index < line.elements.length) return false;
				this.data.pop();
			}

			return true;
		};

		return TraversalStack;
	})();

var RenderingContext =
	/*#__PURE__*/
	(function() {
		function RenderingContext(options) {
			this.options = options || {};
			this.exploreStack = new TraversalStack();
			this.prepareList = [];
			this.cleanupList = [];
			this.stacks = {};
			this.renderList = new LinkedListsNode();
		}

		var _proto = RenderingContext.prototype;

		_proto.getStack = function getStack(key) {
			var stack = this.stacks[key];
			if (!stack) stack = this.stacks[key] = [];
			return stack;
		};

		_proto.push = function push(key, value) {
			var stack = this.getStack(key);
			stack.push(this[key]);
			return (this[key] = value);
		};

		_proto.pop = function pop(key) {
			var stack = this.getStack(key);
			return (this[key] = stack.pop());
		};

		_proto.pushNamedValue = function pushNamedValue(key, name, value) {
			var stack = this.getStack(key + ":" + name);
			if (!this[key]) this[key] = {};
			stack.push(this[key][name]);
			return (this[key][name] = value);
		};

		_proto.popNamedValue = function popNamedValue(key, name) {
			var stack = this.getStack(key + ":" + name);
			return (this[key][name] = stack.pop());
		};

		_proto.get = function get(key) {
			return this[key];
		};

		_proto.getRootRenderList = function getRootRenderList() {
			var rl = this.renderList;

			while (rl.left) {
				rl = rl.left;
			}

			return rl;
		};

		return RenderingContext;
	})();

var LinkedListsNode =
	/*#__PURE__*/
	(function() {
		function LinkedListsNode(left, right) {
			this.left = left;
			this.right = right;
			this.data = [];
		}

		var _proto2 = LinkedListsNode.prototype;

		_proto2.insertLeft = function insertLeft() {
			var node = new LinkedListsNode(this.left, this);
			if (this.left) this.left.right = node;
			this.left = node;
			return node;
		};

		_proto2.insertRight = function insertRight() {
			var node = new LinkedListsNode(this, this.right);
			if (this.right) this.right.left = node;
			this.right = node;
			return node;
		};

		_proto2.markReverseIndex = function markReverseIndex() {
			this.reverseIndex = this.data.length;
		};

		_proto2.reverse = function reverse() {
			reverseSlice(this.data, this.reverseIndex);
		};

		return LinkedListsNode;
	})();

var appLoopFlag = "app-loop";
var vdomRenderFlag = "vdom-render";
var counter = {};
var activeFlags$1 = {};

var nowImpl = function nowImpl() {
	return Date.now();
};

function now() {
	if (process.env.NODE_ENV !== "production") {
		return nowImpl();
	} else {
		return 0;
	}
}

function enable(flag) {
	if (process.env.NODE_ENV !== "production") {
		activeFlags$1[flag] = true;
	}
}

function disable(flag) {
	if (process.env.NODE_ENV !== "production") {
		activeFlags$1[flag] = false;
	}
}

function count(flag) {
	if (process.env.NODE_ENV !== "production") {
		if (!activeFlags$1[flag]) return;
		return (counter[flag] = (counter[flag] || 0) + 1);
	}
}

function log(flag) {
	if (process.env.NODE_ENV !== "production") {
		if (!activeFlags$1[flag]) return;
		Console.log.apply(Console, arguments);
	}
}

if (
	process.env.NODE_ENV !== "production" &&
	typeof window != "undefined" &&
	window.performance &&
	window.performance.now
) {
	nowImpl = function nowImpl() {
		return performance.now();
	};
}

var Timing = {
	now: now,
	enable: enable,
	disable: disable,
	count: count,
	log: log
};

function shallowEquals(v1, v2) {
	if (v1 === v2) return true;
	var t1 = typeof v1,
		t2 = typeof v2,
		k,
		i;
	if (t1 != t2) return false;
	if (v1 == null || v2 == null)
		//this captures undefined too
		return false;

	if (t1 == "object") {
		if (isArray(v1)) {
			if (!isArray(v2) || v1.length != v2.length) return false;

			for (i = 0; i < v1.length; i++) {
				if (!shallowEquals(v1[i], v2[i])) return false;
			}

			return true;
		} else {
			for (k in v1) {
				if (v1.hasOwnProperty(k) && (!v2.hasOwnProperty(k) || v1[k] !== v2[k])) return false;
			}

			for (k in v2) {
				if (v2.hasOwnProperty(k) && (!v1.hasOwnProperty(k) || v1[k] !== v2[k])) return false;
			}

			return true;
		}
	}

	return v1 === v2;
}

function onIdleCallback(callback, options) {
	var token = null;
	if (typeof requestIdleCallback == "function") token = requestIdleCallback(callback, options);
	else token = setTimeout(callback, 1);
	return function() {
		if (typeof cancelIdleCallback == "function") cancelIdleCallback(token);
		else clearTimeout(token);
	};
}

var Cx =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(Cx, _VDOM$Component);

		function Cx(props) {
			var _context2;

			var _this;

			_this = _VDOM$Component.call(this, props) || this;

			if (props.instance) {
				_this.widget = props.instance.widget;
				_this.store = props.instance.store;
			} else {
				_this.widget = PureContainer.create({
					items: props.widget || props.items
				});

				if (props.parentInstance) {
					_this.parentInstance = props.parentInstance;
					_this.store = props.store || _this.parentInstance.store;
				} else {
					_this.parentInstance = new Instance(_this.widget, 0);
					_this.store = props.store;
				}

				if (!_this.store) throw new Error("Cx component requires store.");
			}

			_this.state = {
				deferToken: 0
			};

			if (props.subscribe) {
				var _context;

				_this.unsubscribe = _this.store.subscribe((_context = _this).update.bind(_context));
				_this.state.data = _this.store.getData();
			}

			_this.flags = {};
			_this.renderCount = 0;
			if (props.onError) _this.componentDidCatch = (_context2 = _this).componentDidCatchHandler.bind(_context2);
			_this.deferCounter = 0;

			_this.waitForIdle();

			return _this;
		}

		var _proto = Cx.prototype;

		_proto.componentWillReceiveProps = function componentWillReceiveProps(props) {
			//TODO: Switch to new props
			if (props.subscribe) {
				var data = this.store.getData();

				if (data !== this.state.data) {
					this.waitForIdle();
					this.setState({
						data: this.store.getData()
					});
				}
			}
		};

		_proto.getInstance = function getInstance() {
			if (this.props.instance) return this.props.instance;
			if (this.instance) return this.instance;
			if (this.widget && this.parentInstance)
				return (this.instance = this.parentInstance.getDetachedChild(this.widget, 0, this.store));
			throw new Error("Could not resolve a widget instance in the Cx component.");
		};

		_proto.render = function render() {
			if (!this.widget || (this.props.deferredUntilIdle && this.state.deferToken < this.deferCounter)) return null;
			return VDOM$2.createElement(CxContext, {
				instance: this.getInstance(),
				flags: this.flags,
				options: this.props.options,
				buster: ++this.renderCount,
				contentFactory: this.props.contentFactory
			});
		};

		_proto.componentDidMount = function componentDidMount() {
			this.componentDidUpdate();
			if (this.props.options && this.props.options.onPipeUpdate)
				this.props.options.onPipeUpdate(this.update.bind(this));
		};

		_proto.componentDidUpdate = function componentDidUpdate() {
			if (this.flags.dirty) {
				this.update();
			}
		};

		_proto.update = function update() {
			var _this2 = this;

			var data = this.store.getData();
			debug(appDataFlag, data);
			if (this.flags.preparing) this.flags.dirty = true;
			else if (isBatchingUpdates() || this.props.immediate) {
				notifyBatchedUpdateStarting();
				this.setState(
					{
						data: data
					},
					notifyBatchedUpdateCompleted
				);
			} else {
				//in standard mode sequential store commands are batched
				if (!this.pendingUpdateTimer) {
					notifyBatchedUpdateStarting();
					this.pendingUpdateTimer = setTimeout(function() {
						delete _this2.pendingUpdateTimer;

						_this2.setState(
							{
								data: data
							},
							notifyBatchedUpdateCompleted
						);
					}, 0);
				}
			}
		};

		_proto.waitForIdle = function waitForIdle() {
			var _this3 = this;

			if (!this.props.deferredUntilIdle) return;
			if (this.unsubscribeIdleRequest) this.unsubscribeIdleRequest();
			var token = ++this.deferCounter;
			this.unsubscribeIdleRequest = onIdleCallback(
				function() {
					_this3.setState({
						deferToken: token
					});
				},
				{
					timeout: this.props.idleTimeout || 30000
				}
			);
		};

		_proto.componentWillUnmount = function componentWillUnmount() {
			if (this.pendingUpdateTimer) clearTimeout(this.pendingUpdateTimer);
			if (this.unsubscribeIdleRequest) this.unsubscribeIdleRequest();
			if (this.unsubscribe) this.unsubscribe();
			if (this.props.options && this.props.options.onPipeUpdate) this.props.options.onPipeUpdate(null);
		};

		_proto.shouldComponentUpdate = function shouldComponentUpdate(props, state) {
			if (props.deferredUntilIdle && state.deferToken != this.deferCounter) return false;
			return (
				state !== this.state ||
				!props.params ||
				!shallowEquals(props.params, this.props.params) ||
				props.instance !== this.props.instance ||
				props.widget !== this.props.widget ||
				props.store !== this.props.store ||
				props.parentInstance !== this.props.parentInstance
			);
		};

		_proto.componentDidCatchHandler = function componentDidCatchHandler(error, info) {
			this.flags.preparing = false;
			this.props.onError(error, this.getInstance(), info);
		};

		return Cx;
	})(VDOM$2.Component);

var CxContext =
	/*#__PURE__*/
	(function(_VDOM$Component2) {
		_inheritsLoose(CxContext, _VDOM$Component2);

		function CxContext(props) {
			var _this4;

			_this4 = _VDOM$Component2.call(this, props) || this;
			_this4.renderCount = 0;

			_this4.componentWillReceiveProps(props);

			return _this4;
		}

		var _proto2 = CxContext.prototype;

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			this.timings = {
				start: now()
			};
			var instance = props.instance,
				options = props.options,
				contentFactory = props.contentFactory;
			var count = 0,
				visible,
				context; //should not be tracked by parents for destroy

			if (!instance.detached)
				throw new Error("The instance passed to a Cx component should be detached from its parent.");
			if (this.props.instance !== instance && this.props.instance.destroyTracked) this.props.instance.destroy();
			this.props.flags.preparing = true;

			do {
				context = new RenderingContext(options);
				this.props.flags.dirty = false;
				instance.assignedRenderList = context.getRootRenderList();
				visible = instance.scheduleExploreIfVisible(context);

				if (visible) {
					while (!context.exploreStack.empty()) {
						var inst = context.exploreStack.pop(); //console.log("EXPLORE", inst.widget.constructor.name, inst.widget.tag, inst.widget.widgetId);

						inst.explore(context);
					}
				} else if (instance.destroyTracked) {
					instance.destroy();
					break;
				}
			} while (this.props.flags.dirty && ++count <= 3 && Widget.optimizePrepare && now() - this.timings.start < 8);

			if (visible) {
				this.timings.afterExplore = now();

				for (var i = 0; i < context.prepareList.length; i++) {
					context.prepareList[i].prepare(context);
				}

				this.timings.afterPrepare = now(); //walk in reverse order so children get rendered first

				var renderList = context.getRootRenderList();

				while (renderList) {
					for (var _i = renderList.data.length - 1; _i >= 0; _i--) {
						renderList.data[_i].render(context);
					}

					renderList = renderList.right;
				}

				this.content = getContent(instance.vdom);
				if (contentFactory)
					this.content = contentFactory({
						children: this.content
					});
				this.timings.afterRender = now();

				for (var _i2 = 0; _i2 < context.cleanupList.length; _i2++) {
					context.cleanupList[_i2].cleanup(context);
				}
			} else {
				this.content = null;
				this.timings.afterExplore = this.timings.afterPrepare = this.timings.afterRender = now();
			}

			this.timings.beforeVDOMRender = now();
			this.props.flags.preparing = false;
			this.props.flags.rendering = true;
			this.renderingContext = context;
		};

		_proto2.render = function render() {
			return this.content;
		};

		_proto2.componentDidMount = function componentDidMount() {
			this.componentDidUpdate();
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			this.props.flags.rendering = false;
			this.timings.afterVDOMRender = now(); //let {instance} = this.props;
			//instance.cleanup(this.renderingContext);

			this.timings.afterCleanup = now();
			this.renderCount++;

			if (process.env.NODE_ENV !== "production") {
				var _this$timings = this.timings,
					start = _this$timings.start,
					beforeVDOMRender = _this$timings.beforeVDOMRender,
					afterVDOMRender = _this$timings.afterVDOMRender,
					afterPrepare = _this$timings.afterPrepare,
					afterExplore = _this$timings.afterExplore,
					afterRender = _this$timings.afterRender,
					afterCleanup = _this$timings.afterCleanup;
				Timing.log(
					vdomRenderFlag,
					this.renderCount,
					"cx",
					(beforeVDOMRender - start + afterCleanup - afterVDOMRender).toFixed(2) + "ms",
					"vdom",
					(afterVDOMRender - beforeVDOMRender).toFixed(2) + "ms"
				);
				Timing.log(
					appLoopFlag,
					this.renderCount,
					this.renderingContext.options.name || "main",
					"total",
					(afterCleanup - start).toFixed(1) + "ms",
					"explore",
					(afterExplore - start).toFixed(1) + "ms",
					"prepare",
					(afterPrepare - afterExplore).toFixed(1),
					"render",
					(afterRender - afterPrepare).toFixed(1),
					"vdom",
					(afterVDOMRender - beforeVDOMRender).toFixed(1),
					"cleanup",
					(afterCleanup - afterVDOMRender).toFixed(1)
				);
			}
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			var instance = this.props.instance;
			if (instance.destroyTracked) instance.destroy();
		};

		return CxContext;
	})(VDOM$2.Component);

var DetachedScope =
	/*#__PURE__*/
	(function(_IsolatedScope) {
		_inheritsLoose(DetachedScope, _IsolatedScope);

		function DetachedScope() {
			return _IsolatedScope.apply(this, arguments) || this;
		}

		var _proto = DetachedScope.prototype;

		_proto.declareData = function declareData() {
			var _IsolatedScope$protot;

			return (_IsolatedScope$protot = _IsolatedScope.prototype.declareData).call.apply(
				_IsolatedScope$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						exclusiveData: {
							structured: true
						}
					}
				])
			);
		};

		_proto.init = function init() {
			var _this = this;

			if (typeof this.exclusive === "string")
				this.exclusiveData = {
					bind: this.exclusive
				};

			if (Array.isArray(this.exclusive)) {
				this.exclusiveData = {};
				this.exclusive.forEach(function(x, i) {
					_this.exclusiveData[String(i)] = {
						bind: x
					};
				});
			}

			this.container = PureContainer.create({
				type: PureContainer,
				items: this.children || this.items
			});
			delete this.items;
			delete this.children;
			if (this.name)
				this.options = _objectSpread({}, this.options, {
					name: this.name
				});

			_IsolatedScope.prototype.init.call(this);
		};

		_proto.initInstance = function initInstance(context, instance) {
			instance.subStore = new ContainmentStore({
				store: instance.store,
				selector: getSelector(this.exclusiveData || this.data)
			});
		};

		_proto.render = function render(context, instance, key) {
			return VDOM$2.createElement(Cx, {
				key: key,
				widget: this.container,
				store: instance.subStore,
				parentInstance: instance,
				subscribe: true,
				options: this.options,
				onError: this.onError
			});
		};

		return DetachedScope;
	})(IsolatedScope);

var ContainmentStore =
	/*#__PURE__*/
	(function(_SubscribableView) {
		_inheritsLoose(ContainmentStore, _SubscribableView);

		function ContainmentStore() {
			return _SubscribableView.apply(this, arguments) || this;
		}

		var _proto2 = ContainmentStore.prototype;

		_proto2.getData = function getData() {
			return this.store.getData();
		};

		_proto2.setItem = function setItem() {
			var _this2 = this;

			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return this.wrapper(function() {
				var _this2$store;

				(_this2$store = _this2.store).setItem.apply(_this2$store, args);
			});
		};

		_proto2.deleteItem = function deleteItem() {
			var _this3 = this;

			for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				args[_key2] = arguments[_key2];
			}

			return this.wrapper(function() {
				var _this3$store;

				(_this3$store = _this3.store).deleteItem.apply(_this3$store, args);
			});
		};

		_proto2.wrapper = function wrapper(callback) {
			if (this.store.silently(callback)) {
				var data = this.getData();
				var containedData = this.selector(data);

				if (containedData === this.cache.containedData) {
					this.store.notify();
				} else {
					this.cache.containedData = containedData;
					this.notify();
				}

				return true;
			}

			return false;
		};

		return ContainmentStore;
	})(SubscribableView);

var Store =
	/*#__PURE__*/
	(function(_SubscribableView) {
		_inheritsLoose(Store, _SubscribableView);

		function Store(config) {
			var _this;

			if (config === void 0) {
				config = {};
			}

			_this = _SubscribableView.call(this, config) || this;
			_this.data = config.data || {};
			_this.meta = {
				version: 0
			};
			return _this;
		}

		var _proto = Store.prototype;

		_proto.getData = function getData() {
			return this.data;
		};

		_proto.setItem = function setItem(path, value) {
			var next = Binding.get(path).set(this.data, value);

			if (next != this.data) {
				this.data = next;
				this.meta.version++;
				this.notify(path);
				return true;
			}

			return false;
		};

		_proto.deleteItem = function deleteItem(path) {
			var next = Binding.get(path).delete(this.data);

			if (next != this.data) {
				this.data = next;
				this.meta.version++;
				this.notify(path);
				return true;
			}

			return false;
		};

		_proto.clear = function clear() {
			this.data = {};
			this.meta.version++;
			this.notify();
		};

		return Store;
	})(SubscribableView);
Store.prototype.async = false;

var Restate =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(Restate, _PureContainer);

		function Restate() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = Restate.prototype;

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						data: {
							structured: true
						},
						deferredUntilIdle: undefined,
						idleTimeout: undefined
					}
				])
			);
		};

		_proto.init = function init() {
			this.container = PureContainer.create({
				type: PureContainer,
				items: this.children || this.items,
				layout: this.layout,
				controller: this.controller,
				outerLayout: this.outerLayout,
				useParentLayout: this.useParentLayout,
				ws: this.ws
			});
			delete this.items;
			delete this.children;
			delete this.controller;
			delete this.outerLayout;
			delete this.layout;
			this.useParentLayout = true;

			_PureContainer.prototype.init.call(this);
		};

		_proto.initInstance = function initInstance(context, instance) {
			var bindings = {};

			for (var key in this.data) {
				if (this.data[key] && isString(this.data[key].bind)) bindings[key] = this.data[key].bind;
			}

			instance.subStore = new RestateStore({
				store: instance.store,
				bindings: bindings,
				detached: this.detached
			});

			instance.setStore = function(store) {
				instance.store = store;
				instance.subStore.setStore(store);
			};
		};

		_proto.explore = function explore(context, instance) {
			if (!this.detached) {
				instance.container = instance.getChild(context, this.container, "container", instance.subStore);
				instance.container.scheduleExploreIfVisible(context);
			}

			_PureContainer.prototype.explore.call(this, context, instance);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data,
				subStore = instance.subStore;
			subStore.setParentData(data.data);

			_PureContainer.prototype.prepareData.call(this, context, instance);
		};

		_proto.render = function render(context, instance, key) {
			if (!this.detached) return instance.container.render(context);
			return VDOM$1.createElement(Cx, {
				key: key,
				widget: this.container,
				parentInstance: instance,
				store: instance.subStore,
				subscribe: true,
				options: this.options,
				onError: this.onError,
				deferredUntilIdle: instance.data.deferredUntilIdle,
				idleTimeout: instance.data.idleTimeout
			});
		};

		return Restate;
	})(PureContainer);
Restate.prototype.detached = false;
Restate.prototype.waitForIdle = false;

var RestateStore =
	/*#__PURE__*/
	(function(_Store) {
		_inheritsLoose(RestateStore, _Store);

		function RestateStore(config) {
			var _this;

			_this = _Store.call(this, config) || this;
			_this.parentData = {};
			return _this;
		}

		var _proto2 = RestateStore.prototype;

		_proto2.setParentData = function setParentData(data) {
			var _this2 = this;

			var changed = this.silently(function() {
				for (var key in data) {
					_Store.prototype.setItem.call(_this2, key, data[key]);
				}
			});
			this.parentData = data;
			if (changed && this.detached) this.notify();
		};

		_proto2.doNotify = function doNotify(path) {
			var _this3 = this;

			_Store.prototype.doNotify.call(this, path);

			var changed = this.store.batch(function() {
				var data = _this3.getData();

				for (var key in _this3.bindings) {
					var value = data[key]; //Only values that have actually changed in the RestateStore are propagated to the parent store
					// to avoid race conditions that can happen due to async functions keeping the reference of the
					// restate store of an invisible widget

					if (value !== _this3.parentData[key]) {
						if (value === undefined) _this3.store.delete(_this3.bindings[key]);
						else _this3.store.set(_this3.bindings[key], value);
					}
				}
			}); //in non-detached mode the parent store triggers a new render cycle

			if (!this.detached && !changed) this.store.notify();
		};

		return RestateStore;
	})(Store);

var ReadOnlyDataView =
	/*#__PURE__*/
	(function(_View) {
		_inheritsLoose(ReadOnlyDataView, _View);

		function ReadOnlyDataView() {
			return _View.apply(this, arguments) || this;
		}

		var _proto = ReadOnlyDataView.prototype;

		_proto.getData = function getData() {
			if (this.sealed && this.meta.version === this.cache.version && this.cache.data === this.data)
				return this.cache.result;
			var data = this.store.getData();
			this.cache.result =
				this.sealed || this.immutable || this.store.sealed
					? Object.assign({}, data, this.getAdditionalData(data))
					: Object.assign(data, this.getAdditionalData(data));
			this.cache.version = this.meta.version;
			this.cache.data = this.data;
			return this.cache.result;
		};

		_proto.getAdditionalData = function getAdditionalData() {
			return this.data;
		};

		_proto.setData = function setData(data) {
			this.data = data;
		};

		return ReadOnlyDataView;
	})(View);
ReadOnlyDataView.prototype.immutable = false;

var UseParentLayout =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(UseParentLayout, _PureContainer);

		function UseParentLayout() {
			return _PureContainer.apply(this, arguments) || this;
		}

		return UseParentLayout;
	})(PureContainer);
UseParentLayout.prototype.noLayout = true;
UseParentLayout.prototype.useParentLayout = true;

var DataProxy =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(DataProxy, _PureContainer);

		function DataProxy() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = DataProxy.prototype;

		_proto.init = function init() {
			if (!this.data) this.data = {};
			if (this.alias) this.data[this.alias] = this.value;
			this.container = PureContainer.create({
				type: PureContainer,
				items: this.children || this.items,
				layout: this.layout,
				controller: this.controller,
				outerLayout: this.outerLayout,
				ws: this.ws
			});
			this.children = [this.container];
			delete this.items;
			delete this.controller;
			delete this.outerLayout;
			this.layout = UseParentLayout;

			_PureContainer.prototype.init.call(this);
		};

		_proto.initInstance = function initInstance(context, instance) {
			var _this = this;

			instance.store = new DataProxyView({
				store: instance.store,
				privateData: this.data,
				onSet: function onSet(path, value) {
					var config = _this.data[path];
					if (config.bind)
						return isUndefined(value)
							? instance.store.deleteItem(config.bind)
							: instance.store.setItem(config.bind, value);
					if (!config.set)
						throw new Error("Cannot set value for " + path + " in DataProxy as the setter is not defined.");
					if (isString(config.set)) instance.getControllerMethod(config.set)(value, instance);
					else if (isFunction(config.set)) config.set(value, instance);
					else
						throw new Error(
							"Cannot set value for " +
								path +
								" in DataProxy as the setter is neither a function or a controller method."
						);
					return true;
				}
			});

			instance.setStore = function(store) {
				instance.store.setStore(store);
			};
		};

		return DataProxy;
	})(PureContainer);

var DataProxyView =
	/*#__PURE__*/
	(function(_ReadOnlyDataView) {
		_inheritsLoose(DataProxyView, _ReadOnlyDataView);

		function DataProxyView(config) {
			var _this2;

			_this2 = _ReadOnlyDataView.call(this, config) || this;
			_this2.dataSelector = getSelector(_this2.privateData);
			if (_this2.dataSelector.memoize) _this2.dataSelector = _this2.dataSelector.memoize();
			return _this2;
		}

		var _proto2 = DataProxyView.prototype;

		_proto2.getAdditionalData = function getAdditionalData(parentStoreData) {
			if (this.meta.version !== this.cache.version) this.data = this.dataSelector(parentStoreData);
			return this.data;
		};

		_proto2.setItem = function setItem(path, value) {
			var binding = Binding.get(path);
			var bindingRoot = binding.parts[0];

			if (!isObject(this.privateData) || !this.privateData.hasOwnProperty(bindingRoot)) {
				if (isUndefined(value)) return _ReadOnlyDataView.prototype.deleteItem.call(this, path);
				return _ReadOnlyDataView.prototype.setItem.call(this, path, value);
			}

			var newValue = value;
			if (binding.parts.length > 1)
				newValue = binding.set(this.getAdditionalData(this.store.getData()), value)[bindingRoot];
			return this.onSet(bindingRoot, newValue);
		};

		_proto2.deleteItem = function deleteItem(path) {
			return this.setItem(path, undefined);
		};

		return DataProxyView;
	})(ReadOnlyDataView);

var Content =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(Content, _PureContainer);

		function Content() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = Content.prototype;

		_proto.init = function init() {
			_PureContainer.prototype.init.call(this);

			this.putInto = this.for || this.name;
		};

		return Content;
	})(PureContainer);
Content.prototype.name = "body";
Content.prototype.isContent = true;
Widget.alias("content", Content);

var ContentPlaceholder =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(ContentPlaceholder, _PureContainer);

		function ContentPlaceholder() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = ContentPlaceholder.prototype;

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			(_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						name: undefined
					}
				])
			);
		};

		_proto.explore = function explore(context, instance) {
			var _this = this;

			instance.content = null;
			var data = instance.data;
			var content = context.content && context.content[data.name];
			if (content && !this.scoped) this.setContent(context, instance, content);
			else
				context.pushNamedValue("contentPlaceholder", data.name, function(content) {
					_this.setContent(context, instance, content);
				});
			if (this.scoped)
				instance.unregisterContentPlaceholder = function() {
					context.popNamedValue("contentPlaceholder", data.name);
				};

			_PureContainer.prototype.explore.call(this, context, instance);
		};

		_proto.prepare = function prepare(context, instance) {
			var content = instance.content;
			if (instance.cache("content", content) || (content && content.shouldUpdate)) instance.markShouldUpdate(context);
		};

		_proto.setContent = function setContent(context, instance, content) {
			instance.content = content;
			content.contentPlaceholder = instance;
		};

		_proto.render = function render(context, instance, key) {
			var content = instance.content;
			if (content) return content.contentVDOM;
			return _PureContainer.prototype.render.call(this, context, instance, key);
		};

		return ContentPlaceholder;
	})(PureContainer);
ContentPlaceholder.prototype.name = "body";
ContentPlaceholder.prototype.scoped = false;
Widget.alias("content-placeholder", ContentPlaceholder);
var ContentPlaceholderScope =
	/*#__PURE__*/
	(function(_PureContainer2) {
		_inheritsLoose(ContentPlaceholderScope, _PureContainer2);

		function ContentPlaceholderScope() {
			return _PureContainer2.apply(this, arguments) || this;
		}

		var _proto2 = ContentPlaceholderScope.prototype;

		_proto2.init = function init() {
			_PureContainer2.prototype.init.call(this);

			if (isString(this.name)) this.name = [this.name];
		};

		_proto2.explore = function explore(context, instance) {
			this.name.forEach(function(name) {
				context.pushNamedValue("contentPlaceholder", name, null);
				context.pushNamedValue("content", name, null);
			});

			_PureContainer2.prototype.explore.call(this, context, instance);
		};

		_proto2.exploreCleanup = function exploreCleanup(context, instance) {
			this.name.forEach(function(name) {
				context.popNamedValue("contentPlaceholder", name);
				context.popNamedValue("content", name);
			});
		};

		return ContentPlaceholderScope;
	})(PureContainer);

function isPromise(x) {
	return isObject(x) && isFunction(x.then);
}

var ContentResolver =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(ContentResolver, _PureContainer);

		function ContentResolver() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = ContentResolver.prototype;

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						params: {
							structured: true
						},
						loading: undefined
					}
				])
			);
		};

		_proto.init = function init() {
			_PureContainer.prototype.init.call(this);

			this.initialItems = this.layout ? this.layout.items : this.items;
			this.clear();
		};

		_proto.initInstance = function initInstance(context, instance) {
			instance.content = this.initialItems;
			instance.cachedParams = {}; //unique value which will never pass the equality check
		};

		_proto.prepareData = function prepareData(context, instance) {
			var _this = this;

			var data = instance.data;

			if (data.params !== instance.cachedParams && this.onResolve) {
				instance.cachedParams = data.params;
				var content = instance.invoke("onResolve", data.params, instance);

				if (isPromise(content)) {
					instance.set("loading", true);
					this.setContent(instance, null);
					content.then(function(cnt) {
						_this.setContent(instance, cnt);

						instance.setState({
							cacheBuster: {}
						});
						instance.set("loading", false);
					});
				} else this.setContent(instance, content);
			}
		};

		_proto.setContent = function setContent(instance, content) {
			if (content) {
				this.clear();

				switch (this.mode) {
					case "prepend":
						this.add(content);
						this.add(this.initialItems);
						break;

					case "append":
						this.add(this.initialItems);
						this.add(content);
						break;

					case "replace":
						this.add(content);
						break;
				}

				instance.content = this.layout ? this.layout.items : this.items;
				this.clear();
			} else instance.content = this.initialItems;
		};

		_proto.explore = function explore(context, instance) {
			//a little bit hacky
			if (this.layout) this.layout.items = instance.content;
			else this.items = instance.content;

			_PureContainer.prototype.explore.call(this, context, instance);
		};

		return ContentResolver;
	})(PureContainer);
ContentResolver.prototype.mode = "replace";

var ZoomIntoPropertyView =
	/*#__PURE__*/
	(function(_View) {
		_inheritsLoose(ZoomIntoPropertyView, _View);

		function ZoomIntoPropertyView() {
			return _View.apply(this, arguments) || this;
		}

		var _proto = ZoomIntoPropertyView.prototype;

		_proto.getData = function getData() {
			if (this.cache.version != this.meta.version) {
				var _objectSpread2;

				var data = this.store.getData();
				var x = this.binding.value(data);
				if (x != null && typeof x != "object") throw new Error("Zoomed value must be an object.");
				this.cache.result = _objectSpread(
					{},
					x,
					((_objectSpread2 = {}),
					(_objectSpread2[this.rootName] = !this.store.sealed ? _objectSpread({}, data) : data),
					_objectSpread2)
				);
				this.cache.version = this.meta.version;
			}

			return this.cache.result;
		};

		_proto.setItem = function setItem(path, value) {
			if (path.indexOf(this.rootName + ".") == 0) this.store.setItem(path.substring(this.rootName.length + 1), value);
			else this.store.setItem(this.binding.path + "." + path, value);
		};

		_proto.deleteItem = function deleteItem(path) {
			if (path instanceof Binding) path = path.path;
			if (path.indexOf(this.rootName + ".") == 0) this.store.deleteItem(path.substring(this.rootName.length + 1));
			else this.store.deleteItem(this.binding.path + "." + path);
		};

		return ZoomIntoPropertyView;
	})(View);
ZoomIntoPropertyView.prototype.rootName = "$root";

var Rescope =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(Rescope, _PureContainer);

		function Rescope() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = Rescope.prototype;

		_proto.init = function init() {
			this.binding = Binding.get(this.bind);
			if (this.rootAlias) this.rootName = this.rootAlias;

			_PureContainer.prototype.init.call(this);
		};

		_proto.initInstance = function initInstance(context, instance) {
			instance.store = new ZoomIntoPropertyView({
				store: instance.store,
				binding: this.binding,
				rootName: this.rootName
			});

			instance.setStore = function(store) {
				instance.store.setStore(store);
			};
		};

		return Rescope;
	})(PureContainer);
Rescope.prototype.bind = "$page";
Rescope.prototype.rootName = "$root";
Widget.alias("rescope", Rescope);

var DataAdapter =
	/*#__PURE__*/
	(function(_Component) {
		_inheritsLoose(DataAdapter, _Component);

		function DataAdapter() {
			return _Component.apply(this, arguments) || this;
		}

		var _proto = DataAdapter.prototype;

		_proto.getRecords = function getRecords() {
			throw new Error("Abstract method");
		};

		_proto.setFilter = function setFilter() {};

		_proto.sort = function sort() {};

		return DataAdapter;
	})(Component);
DataAdapter.prototype.recordName = "$record";
DataAdapter.prototype.indexName = "$index";
DataAdapter.prototype.immutable = false;

var ExposedRecordView =
	/*#__PURE__*/
	(function(_View) {
		_inheritsLoose(ExposedRecordView, _View);

		function ExposedRecordView() {
			return _View.apply(this, arguments) || this;
		}

		var _proto = ExposedRecordView.prototype;

		_proto.getData = function getData() {
			if (this.sealed && this.meta.version === this.cache.version && this.cache.itemIndex === this.itemIndex)
				return this.cache.result;
			this.cache.result = this.embed(this.store.getData());
			this.cache.version = this.meta.version;
			this.cache.itemIndex = this.itemIndex;
			return this.cache.result;
		};

		_proto.embed = function embed(data) {
			var collection = this.collectionBinding.value(data);
			var record = collection[this.itemIndex];
			var copy = this.sealed || this.immutable || this.store.sealed ? _objectSpread({}, data) : data;
			copy[this.recordName] = record;
			if (this.indexName) copy[this.indexName] = this.itemIndex;
			return copy;
		};

		_proto.setIndex = function setIndex(index) {
			this.itemIndex = index;
		};

		_proto.setItem = function setItem(path, value) {
			if (path == this.recordName || path.indexOf(this.recordName + ".") == 0) {
				var storeData = this.store.getData();
				var collection = this.collectionBinding.value(storeData);
				var data = this.embed(storeData);
				var d = Binding.get(path).set(data, value);
				if (d === data) return false;
				var record = d[this.recordName];
				var newCollection = [].concat(
					collection.slice(0, this.itemIndex),
					[record],
					collection.slice(this.itemIndex + 1)
				);
				return this.store.setItem(this.collectionBinding.path, newCollection);
			}

			return this.store.setItem(path, value);
		};

		_proto.deleteItem = function deleteItem(path) {
			var storeData, collection, newCollection;

			if (path == this.recordName) {
				storeData = this.store.getData();
				collection = this.collectionBinding.value(storeData);
				newCollection = [].concat(collection.slice(0, this.itemIndex), collection.slice(this.itemIndex + 1));
				return this.store.setItem(this.collectionBinding.path, newCollection);
			} else if (path.indexOf(this.recordName + ".") == 0) {
				storeData = this.store.getData();
				collection = this.collectionBinding.value(storeData);
				var data = this.embed(storeData);
				var d = Binding.get(path).delete(data);
				if (d === data) return false;
				var record = d[this.recordName];
				newCollection = [].concat(collection.slice(0, this.itemIndex), [record], collection.slice(this.itemIndex + 1));
				return this.store.setItem(this.collectionBinding.path, newCollection);
			}

			return this.store.deleteItem(path);
		};

		return ExposedRecordView;
	})(View);
ExposedRecordView.prototype.immutable = false;

function getComparer(sorters, dataAccessor) {
	var data = (sorters || []).map(function(s) {
		var selector = isDefined(s.value)
			? getSelector(s.value)
			: s.field
				? function(x) {
						return x[s.field];
					}
				: function() {
						return null;
					};
		return {
			getter: dataAccessor
				? function(x) {
						return selector(dataAccessor(x));
					}
				: selector,
			factor: s.direction && s.direction[0].toLowerCase() == "d" ? -1 : 1
		};
	});
	return function(a, b) {
		var d, av, bv;

		for (var i = 0; i < data.length; i++) {
			d = data[i];
			av = d.getter(a);
			bv = d.getter(b);

			if (av == null) {
				if (bv == null) return 0;
				return -d.factor;
			} else {
				if (bv == null) return d.factor;
				if (av < bv) return -d.factor;
				if (av > bv) return d.factor;
			}
		}

		return 0;
	};
}
function sorter(sorters, dataAccessor) {
	var cmp = getComparer(sorters, dataAccessor);
	return function(data) {
		var result = [].concat(data);
		result.sort(cmp);
		return result;
	};
}

var ArrayAdapter =
	/*#__PURE__*/
	(function(_DataAdapter) {
		_inheritsLoose(ArrayAdapter, _DataAdapter);

		function ArrayAdapter() {
			return _DataAdapter.apply(this, arguments) || this;
		}

		var _proto = ArrayAdapter.prototype;

		_proto.initInstance = function initInstance(context, instance) {
			if (!instance.recordStoreCache) instance.recordStoreCache = new WeakMap();
		};

		_proto.getRecords = function getRecords(context, instance, records, parentStore) {
			return this.mapRecords(context, instance, records, parentStore, this.recordsBinding);
		};

		_proto.mapRecords = function mapRecords(context, instance, records, parentStore, recordsBinding) {
			var _this = this;

			var result = [];
			if (!instance.recordStoreCache) this.initInstance(context, instance);
			if (isArray(records))
				records.forEach(function(data, index) {
					if (_this.filterFn && !_this.filterFn(data)) return;

					var record = _this.mapRecord(context, instance, data, parentStore, recordsBinding, index);

					result.push(record);
				});
			if (this.sorter) result = this.sorter(result);
			return result;
		};

		_proto.mapRecord = function mapRecord(context, instance, data, parentStore, recordsBinding, index) {
			var recordStore = instance.recordStoreCache.get(data);
			var writable = parentStore && recordsBinding;

			if (writable) {
				if (!recordStore)
					recordStore = new ExposedRecordView({
						store: parentStore,
						collectionBinding: recordsBinding,
						itemIndex: index,
						recordName: this.recordName,
						indexName: this.indexName,
						immutable: this.immutable,
						sealed: this.sealed
					});
				else {
					recordStore.setStore(parentStore);
					recordStore.setIndex(index);
				}
			} else {
				var _data;

				if (!recordStore)
					recordStore = new ReadOnlyDataView({
						store: parentStore,
						data: ((_data = {}), (_data[this.recordName] = data), (_data[this.indexName] = index), _data),
						immutable: this.immutable,
						sealed: this.sealed
					});
				else {
					recordStore.setStore(parentStore);
				}
			}

			if (typeof data == "object") instance.recordStoreCache.set(data, recordStore);
			return {
				store: recordStore,
				index: index,
				data: data,
				type: "data",
				key: this.keyField ? data[this.keyField] : index
			};
		};

		_proto.setFilter = function setFilter(filterFn) {
			this.filterFn = filterFn;
		};

		_proto.buildSorter = function buildSorter(sorters) {
			var _this2 = this;

			if (isArray(sorters) && sorters.length > 0) {
				if (
					sorters.every(function(x) {
						return x.field && x.value == null;
					})
				) {
					//if all sorters are based on record fields access data directly (faster)
					this.sorter = sorter(
						sorters.map(function(x) {
							if (x.field)
								return {
									value: {
										bind: x.field
									},
									direction: x.direction
								};
							return x;
						}),
						function(x) {
							return x.data;
						}
					);
				} else {
					//if some sorters use computed values, use store data object
					this.sorter = sorter(
						sorters.map(function(x) {
							if (x.field && x.value == null)
								return {
									value: {
										bind: _this2.recordName + "." + x.field
									},
									direction: x.direction
								};
							return x;
						}),
						function(x) {
							return x.store.getData();
						}
					);
				}
			} else {
				this.sorter = null;
			}
		};

		_proto.sort = function sort(sorters) {
			this.buildSorter(sorters);
		};

		return ArrayAdapter;
	})(DataAdapter);
ArrayAdapter.prototype.immutable = false;
ArrayAdapter.prototype.sealed = false;

var Repeater =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(Repeater, _Container);

		function Repeater() {
			return _Container.apply(this, arguments) || this;
		}

		var _proto = Repeater.prototype;

		_proto.declareData = function declareData() {
			var _Container$prototype$;

			(_Container$prototype$ = _Container.prototype.declareData).call.apply(
				_Container$prototype$,
				[
					this,
					{
						records: undefined,
						sorters: undefined,
						sortField: undefined,
						sortDirection: undefined,
						filterParams: {
							structured: true
						}
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.init = function init() {
			if (isBinding(this.records)) this.recordsBinding = Binding.get(this.records.bind);
			if (this.recordAlias) this.recordName = this.recordAlias;
			if (this.indexAlias) this.indexName = this.indexAlias;
			this.dataAdapter = ArrayAdapter.create(
				_objectSpread({}, this.dataAdapter, {
					recordName: this.recordName,
					indexName: this.indexName,
					keyField: this.keyField,
					immutable: this.immutable,
					sealed: this.sealed
				})
			);
			this.item = PureContainer.create({
				children: this.items || this.children,
				layout: UseParentLayout
			});
			delete this.children;
			delete this.items;

			_Container.prototype.init.call(this);
		};

		_proto.initInstance = function initInstance(context, instance) {
			this.dataAdapter.initInstance(context, instance);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var _this = this;

			var data = instance.data;
			if (data.sortField)
				data.sorters = [
					{
						field: data.sortField,
						direction: data.sortDirection || "ASC"
					}
				];
			this.dataAdapter.sort(data.sorters);
			var filter = null;
			if (this.onCreateFilter) filter = instance.invoke("onCreateFilter", data.filterParams, instance);
			else if (this.filter)
				filter = function filter(item) {
					return _this.filter(item, data.filterParams);
				};
			this.dataAdapter.setFilter(filter);
			instance.mappedRecords = this.dataAdapter.mapRecords(
				context,
				instance,
				data.records,
				instance.store,
				this.recordsBinding
			);

			_Container.prototype.prepareData.call(this, context, instance);
		};

		_proto.explore = function explore(context, instance, data) {
			var _this2 = this;

			var instances = [];
			instance.mappedRecords.forEach(function(record) {
				var subInstance = instance.getChild(context, _this2.item, record.key, record.store);
				var changed = subInstance.cache("recordData", record.data) || subInstance.cache("key", record.key);
				subInstance.record = record;

				if (_this2.cached && !changed && subInstance.visible && !subInstance.childStateDirty) {
					instances.push(subInstance);
					subInstance.shouldUpdate = false;
				} else if (subInstance.scheduleExploreIfVisible(context)) instances.push(subInstance);
			});
			instance.children = instances;
		};

		return Repeater;
	})(Container);
Repeater.prototype.recordName = "$record";
Repeater.prototype.indexName = "$index";
Repeater.prototype.cached = false;
Repeater.prototype.immutable = false;
Repeater.prototype.sealed = false;
Repeater.prototype.isPureContainer = true;
Widget.alias("repeater", Repeater);

var impl = false;
function tooltipMouseMove(e, parentInstance, tooltip, options) {
	if (options === void 0) {
		options = {};
	}

	return impl && impl.tooltipMouseMove.apply(impl, arguments);
}
function tooltipMouseLeave(e, parentInstance, tooltip, options) {
	return impl && impl.tooltipMouseLeave.apply(impl, arguments);
}
function tooltipParentDidMount(element, parentInstance, tooltip, options) {
	return impl && impl.tooltipParentDidMount.apply(impl, arguments);
}
function tooltipParentWillReceiveProps(element, parentInstance, tooltip, options) {
	return impl && impl.tooltipParentWillReceiveProps.apply(impl, arguments);
}
function tooltipParentWillUnmount(parentInstance) {
	return impl && impl.tooltipParentWillUnmount.apply(impl, arguments);
}
function wireTooltipOps(ops) {
	impl = ops;
}

var Url =
	/*#__PURE__*/
	(function() {
		function Url() {}

		Url.resolve = function resolve(path) {
			return path.replace("~/", this.base);
		};

		Url.absolute = function absolute(path) {
			return path.replace("~/", this.absoluteBase);
		};

		Url.unresolve = function unresolve(path) {
			if (path.indexOf("~/") == 0) return path;
			var absBase = this.absoluteBase || "";
			if (path.indexOf(absBase) == 0) return "~/" + path.substring(absBase.length);
			return "~/" + path.substring(this.base.length);
		};

		Url.getAbsoluteBase = function getAbsoluteBase() {
			return this.absoluteBase;
		};

		Url.isLocal = function isLocal(url) {
			var absBase = this.getAbsoluteBase();
			return url.indexOf("~/") == 0 || url.indexOf(absBase) == 0 || url.indexOf(this.base) == 0;
		};

		Url.setBase = function setBase(base) {
			if (!base || base[base.length - 1] != "/") base += "/";
			this.base = base;
			if (typeof window != "undefined")
				this.absoluteBase = window.location.protocol + "//" + window.location.host + this.base;
		};

		Url.getOrigin = function getOrigin() {
			if (typeof window == "undefined") return "";
			return (
				window.location.protocol +
				"//" +
				window.location.hostname +
				(window.location.port ? ":" + window.location.port : "")
			);
		};

		Url.getBaseFromScriptSrc = function getBaseFromScriptSrc(src, scriptPath) {
			if (!(scriptPath instanceof RegExp)) scriptPath = getBasePathRegex(scriptPath);
			var index = src.search(scriptPath);
			if (index == -1) return false;
			var origin = this.getOrigin();
			return src.substring(src.indexOf(origin) == 0 ? origin.length : 0, index);
		};

		Url.setBaseFromScript = function setBaseFromScript(scriptPath) {
			var scripts = document.getElementsByTagName("script"),
				base;
			if (!(scriptPath instanceof RegExp)) scriptPath = getBasePathRegex(scriptPath);

			for (var i = 0; i < scripts.length; i++) {
				base = this.getBaseFromScriptSrc(scripts[i].src, scriptPath);

				if (base) {
					this.setBase(base);
					return;
				}
			}

			throw new Error("Could not resolve url base from script matching '" + scriptPath + "'.");
		};

		return Url;
	})();
Url.setBase("/");

function getBasePathRegex(str) {
	var regex = "";
	var start = 0;
	if (str.indexOf("~/") == 0) start = 2;

	for (var i = start; i < str.length; i++) {
		switch (str[i]) {
			case ".":
				regex += "\\.";
				break;

			case "*":
				regex += ".*";
				break;

			default:
				regex += str[i];
		}
	}

	return new RegExp(regex + "(\\?.*)?$", "i");
}

var isDataAttribute = function isDataAttribute(attr) {
	return attr.indexOf("data-") == 0 ? attr.substring(5) : false;
};

var urlAttributes = {
	"a.href": true,
	"img.src": true,
	"iframe.src": true
};
var HtmlElement =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(HtmlElement, _Container);

		function HtmlElement(config) {
			var _context;

			var _this;

			_this = _Container.call(this, config) || this;
			if (isUndefined(_this.jsxAttributes) && config)
				_this.jsxAttributes = Object.keys(config).filter((_context = _this).isValidHtmlAttribute.bind(_context));
			return _this;
		}

		var _proto = HtmlElement.prototype;

		_proto.declareData = function declareData() {
			var _this2 = this,
				_Container$prototype$;

			var data = {
				text: undefined,
				innerHtml: undefined,
				attrs: {
					structured: true
				},
				data: {
					structured: true
				}
			};
			var name;
			this.urlAttributes = [];

			if (this.jsxAttributes) {
				this.jsxAttributes.forEach(function(attr) {
					if (urlAttributes[_this2.tag + "." + attr]) _this2.urlAttributes.push(attr);

					if ((name = isDataAttribute(attr))) {
						if (!_this2.data) _this2.data = {};
						_this2.data[name] = _this2[attr];
					} else if ((name = _this2.isValidHtmlAttribute(attr)) && !data.hasOwnProperty(name)) {
						if (name.indexOf("on") == 0) {
							if (_this2[attr]) {
								if (!_this2.events) _this2.events = {};
								_this2.events[name] = _this2[attr];
							}
						} else {
							if (!_this2.attrs) _this2.attrs = {};
							_this2.attrs[name] = _this2[attr];
						}
					}
				});
			}

			if (this.urlAttributes.length == 0) delete this.urlAttributes;

			(_Container$prototype$ = _Container.prototype.declareData).call.apply(
				_Container$prototype$,
				[this].concat(Array.prototype.slice.call(arguments), [data])
			);
		};

		_proto.isValidHtmlAttribute = function isValidHtmlAttribute(attrName) {
			switch (attrName) {
				case "tag":
				case "type":
				case "$type":
				case "$props":
				case "text":
				case "layout":
				case "class":
				case "className":
				case "style":
				case "controller":
				case "outerLayout":
				case "items":
				case "children":
				case "visible":
				case "if":
				case "mod":
				case "putInto":
				case "contentFor":
				case "trimWhitespace":
				case "preserveWhitespace":
				case "ws":
				case "plainText":
				case "vertical":
				case "memoize":
				case "onInit":
				case "onExplore":
				case "onDestroy":
				case "html":
				case "innerText":
				case "baseClass":
				case "CSS":
				case "tooltip":
				case "styles":
				case "jsxAttributes":
				case "jsxSpread":
				case "instance":
				case "store":
					return false;

				default:
					if (isDataAttribute(attrName)) return false;
					break;
			}

			return attrName;
		};

		_proto.init = function init() {
			if (this.html) this.innerHtml = this.html;
			if (this.innerText) this.text = this.innerText;

			_Container.prototype.init.call(this);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;

			if (this.urlAttributes && data.attrs) {
				data.attrs = _objectSpread({}, data.attrs);
				this.urlAttributes.forEach(function(attr) {
					if (isString(data.attrs[attr])) data.attrs[attr] = Url.resolve(data.attrs[attr]);
				});
			}

			_Container.prototype.prepareData.call(this, context, instance);
		};

		_proto.attachProps = function attachProps(context, instance, props) {
			Object.assign(props, this.extraProps);
			if (!isString(this.tag)) props.instance = instance;
		};

		_proto.render = function render(context, instance, key) {
			//rebind events to pass instance
			if (this.events && !instance.events) {
				instance.events = {};

				var _loop = function _loop(eventName) {
					instance.events[eventName] = function(e) {
						return instance.invoke(eventName, e, instance);
					};
				};

				for (var eventName in this.events) {
					_loop(eventName);
				}
			}

			var data = instance.data,
				events = instance.events;
			var props = Object.assign(
				{
					key: key
				},
				data.attrs,
				events
			);
			if (data.classNames) props.className = data.classNames;
			if (data.style) props.style = data.style;
			var children;
			if (isDefined(data.text)) children = data.text;
			else if (isString(data.innerHtml)) {
				props.dangerouslySetInnerHTML = {
					__html: data.innerHtml
				};
			} else {
				children = this.renderChildren(context, instance);
				if (children && isArray(children) && children.length == 0) children = undefined;
			}
			props.children = children;
			this.attachProps(context, instance, props);
			if (this.tooltip)
				return VDOM$2.createElement(
					ContainerComponent,
					{
						key: key,
						tag: this.tag,
						props: props,
						instance: instance,
						data: data
					},
					props.children
				);
			return VDOM$2.createElement(this.tag, props, props.children);
		};

		return HtmlElement;
	})(Container);
HtmlElement.prototype.tag = "div";
HtmlElement.prototype.styled = true;

var ContainerComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(ContainerComponent, _VDOM$Component);

		function ContainerComponent() {
			return _VDOM$Component.apply(this, arguments) || this;
		}

		var _proto2 = ContainerComponent.prototype;

		_proto2.render = function render() {
			var _this3 = this;

			var _this$props = this.props,
				tag = _this$props.tag,
				props = _this$props.props,
				children = _this$props.children,
				instance = _this$props.instance;

			if (instance.widget.tooltip) {
				props.ref = function(c) {
					_this3.el = c;
				};

				var onMouseLeave = props.onMouseLeave,
					onMouseMove = props.onMouseMove;

				props.onMouseLeave = function(e) {
					tooltipMouseLeave(e, instance, instance.widget.tooltip);
					if (onMouseLeave) onMouseLeave(e);
				};

				props.onMouseMove = function(e) {
					tooltipMouseMove(e, instance, instance.widget.tooltip);
					if (onMouseMove) onMouseMove(e);
				};
			}

			return VDOM$2.createElement(tag, props, children);
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			tooltipParentWillUnmount(this.props.instance);
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			tooltipParentWillReceiveProps(this.el, props.instance, this.props.instance.widget.tooltip);
		};

		_proto2.componentDidMount = function componentDidMount() {
			tooltipParentDidMount(this.el, this.props.instance, this.props.instance.widget.tooltip);
		};

		return ContainerComponent;
	})(VDOM$2.Component);

var originalWidgetFactory = Widget.factory; //support for React components

Widget.factory = function(type, config, more) {
	var typeType = typeof type;

	if (typeType == "undefined") {
		debug("Creating a widget of unknown type.", config, more);
		return new HtmlElement(Object.assign({}, config, more));
	}

	if (typeType == "function")
		return HtmlElement.create(
			HtmlElement,
			{
				tag: type
			},
			config
		);
	return originalWidgetFactory.call(Widget, type, config, more);
};

Widget.alias("html-element", HtmlElement);

var flattenProps = function flattenProps(props) {
	if (!props) return {};

	if (props.jsxSpread) {
		props = _objectSpread(
			{},
			props,
			props.jsxSpread.reduce(function(acc, prop) {
				return Object.assign(acc, prop);
			}, {})
		);
	}

	if (props.$props !== undefined) {
		props = _objectSpread({}, props.$props, {
			jsxAttributes: props.jsxAttributes,
			children: props.children
		});
	}

	return _objectSpread({}, props);
};

var FunctionalComponent =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(FunctionalComponent, _PureContainer);

		function FunctionalComponent() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = FunctionalComponent.prototype;

		_proto.initInstance = function initInstance(context, instance) {
			this.clear();
			this.add(
				this.childrenFactory(
					_objectSpread({}, this.props, {
						store: new StoreProxy(function() {
							return instance.store;
						})
					})
				)
			);
			instance.content = this.layout ? this.layout.items : this.items;
			this.clear();
		};

		_proto.explore = function explore(context, instance) {
			if (this.layout) this.layout.items = instance.content;
			else this.items = instance.content;
			this.exploreItems(context, instance, instance.content);
		};

		return FunctionalComponent;
	})(PureContainer);

function createFunctionalComponent(factory) {
	if (isComponentFactory(factory)) return factory;
	return createComponentFactory(factory, function(props) {
		if (props === void 0) {
			props = {};
		}

		var innerProps = flattenProps(props);
		delete innerProps.visible;
		delete innerProps.if;
		delete innerProps.controller;
		delete innerProps.layout;
		delete innerProps.outerLayout;
		delete innerProps.putInto;
		delete innerProps.contentFor;
		return {
			type: FunctionalComponent,
			visible: isDefined(props.if) ? props.if : isDefined(props.visible) ? props.visible : true,
			layout: props.layout || UseParentLayout,
			controller: props.controller,
			outerLayout: props.outerLayout,
			putInto: props.contentFor || props.putInto,
			childrenFactory: factory,
			props: innerProps
		};
	});
}

var htmlFactoryCache = {};

function getHtmlElementFactory(tagName) {
	var factory = htmlFactoryCache[tagName];
	if (factory) return factory;
	return (htmlFactoryCache[tagName] = createComponentFactory(
		function() {},
		function(config) {
			return HtmlElement.create(
				HtmlElement,
				{
					tag: tagName
				},
				flattenProps(config)
			);
		},
		{
			tag: tagName
		}
	));
}

function cx(typeName, props) {
	for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
		children[_key - 2] = arguments[_key];
	}

	if (isArray(typeName)) return typeName;
	if (isFunction(typeName) && isUndefined(props))
		return createFunctionalComponent(function(config) {
			return typeName(flattenProps(config));
		});
	if (typeName.type || typeName.$type) return typeName;
	if (children && children.length == 0) children = null;
	if (children && children.length == 1) children = children[0];
	if (typeName == "cx") return children;
	if (typeName == "react") return react(children);
	if (isString(typeName) && typeName[0] == typeName[0].toLowerCase()) typeName = getHtmlElementFactory(typeName);
	return {
		$type: typeName,
		$props: props,
		jsxAttributes: props && Object.keys(props),
		children: children
	};
}
function react(config) {
	if (!config || isString(config) || isNumber(config) || VDOM$2.isValidElement(config)) return config;
	if (isArray(config)) return config.map(react);
	var type = config.$type;
	if (isComponentFactory(type) && type.$meta && type.$meta.tag) type = type.$meta.tag;
	if (isArray(config.children))
		return VDOM$2.createElement.apply(VDOM$2, [type, config.$props].concat(config.children.map(react)));
	return VDOM$2.createElement(type, config.$props, react(config.children));
}

function getMessage(options) {
	debug(
		deprecatedFlag,
		"Call enableMsgBoxes() on startup to use Cx based message boxes. Message boxes are not auto enabled anymore to reduce the bundle size for apps that do not use them. "
	);
	if (!options) return null;
	if (isString(options)) return options;
	if (options && options.message) return options.message;
	return null;
}

var impl$1 = {
	yesNo: function yesNo(options) {
		var result = window.confirm(getMessage(options));
		return Promise.resolve(result ? "yes" : "no");
	},
	alert: function alert(options) {
		window.alert(getMessage(options));
		return Promise.resolve();
	}
};
function yesNo(options) {
	return impl$1.yesNo.apply(impl$1, arguments);
}
function registerAlertImpl(x) {
	impl$1 = x;
}

var icons = {};
var iconFactory = null;
var defaultIcons = {};
var unregisteredDefaultIcons = {};
function registerIcon(name, icon, defaultIcon) {
	if (defaultIcon === void 0) {
		defaultIcon = false;
	}

	if (!defaultIcon || !unregisteredDefaultIcons[name]) icons[name] = icon;
	if (!defaultIcon) unregisteredDefaultIcons[name] = true;
	else defaultIcons[name] = icon;
	return function(props) {
		return renderIcon(name, props);
	};
}
function unregisterIcon() {
	for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
		args[_key] = arguments[_key];
	}

	args.forEach(function(name) {
		delete icons[name];
		unregisteredDefaultIcons[name] = true;
	});
}
function renderIcon(name, props) {
	if (isFunction(name)) return name(props);
	if (icons[name]) return icons[name](props);
	if (iconFactory) return iconFactory(name, props);
	return null;
}
function clearIcons() {
	icons = {};
}
function registerIconFactory(factory) {
	iconFactory = factory;
}
function restoreDefaultIcons() {
	icons = _objectSpread({}, defaultIcons);
}

registerIcon(
	"calendar",
	function(props) {
		return VDOM$2.createElement(
			"svg",
			_extends({}, props, {
				viewBox: "0 0 32 32"
			}),
			VDOM$2.createElement("path", {
				d: "M4 3h6m10 0h6",
				fill: "none",
				stroke: "currentColor",
				strokeWidth: "2"
			}),
			VDOM$2.createElement("path", {
				d: "M19 21h4v4h-4z",
				fill: "currentColor"
			}),
			VDOM$2.createElement("path", {
				d: "M3 25h24M3 21h24M3 17h24M7 28V13m-4 0h24M11 28V13.2M15 28V13.27M19 28V13.03M23 28V13.5",
				fill: "none",
				stroke: "currentColor"
			}),
			VDOM$2.createElement("path", {
				fill: "currentColor",
				d: "M10 8h10v2H10z"
			}),
			VDOM$2.createElement("path", {
				fill: "none",
				stroke: "currentColor",
				strokeWidth: "2",
				d: "M3 5h24v24H3z"
			})
		);
	},
	true
);

var CheckIcon = registerIcon(
	"check",
	function(props) {
		return VDOM$2.createElement(
			"svg",
			_extends({}, props, {
				viewBox: "0 0 64 64"
			}),
			VDOM$2.createElement("path", {
				d: "M7.136 42.94l20.16 14.784 29.568-40.32-9.72-7.128-22.598 30.816-10.44-7.656z",
				fill: "currentColor"
			})
		);
	},
	true
);

var ClearIcon = registerIcon(
	"clear",
	function(props) {
		return VDOM$2.createElement(
			"svg",
			_extends({}, props, {
				viewBox: "0 0 32 32"
			}),
			VDOM$2.createElement("path", {
				fill: "currentColor",
				strokeWidth: "1",
				stroke: "currentColor",
				d:
					"M16.9 16l4.92-4.92c.24-.24.24-.6 0-.84s-.6-.24-.84 0l-4.92 4.92-5.04-4.98c-.24-.24-.6-.24-.84 0s-.24.6 0 .84L15.16 16l-4.98 4.98c-.24.24-.24.6 0 .84s.6.24.84 0L16 16.84l4.98 4.98c.24.24.6.24.84 0s.24-.6 0-.84L16.9 16z"
			})
		);
	},
	true
);

registerIcon(
	"close",
	function(props) {
		return VDOM$2.createElement(
			"svg",
			_extends({}, props, {
				viewBox: "0 0 32 32"
			}),
			VDOM$2.createElement("path", {
				fill: "currentColor",
				strokeWidth: "1",
				stroke: "currentColor",
				d:
					"M17.8 16l9.84-9.84c.48-.48.48-1.2 0-1.68s-1.2-.48-1.68 0l-9.84 9.84L6.04 4.36c-.48-.48-1.2-.48-1.68 0s-.48 1.2 0 1.68L14.32 16l-9.96 9.96c-.48.48-.48 1.2 0 1.68s1.2.48 1.68 0L16 17.68l9.96 9.96c.48.48 1.2.48 1.68 0s.48-1.2 0-1.68L17.8 16z"
			}),
			"/>"
		);
	},
	true
);

var DropdownIcon = registerIcon(
	"drop-down",
	function(props) {
		return VDOM$2.createElement(
			"svg",
			_extends({}, props, {
				viewBox: "0 0 20 20"
			}),
			VDOM$2.createElement("path", {
				fill: "currentColor",
				strokeWidth: "0",
				stroke: "currentColor",
				d: "M4.516 8.147L10.01 12.5l5.474-4.33-.473-.65-5 3.98-5-4z"
			})
		);
	},
	true
);

registerIcon(
	"folder",
	function(props) {
		return VDOM$2.createElement(
			"svg",
			_extends({}, props, {
				viewBox: "0 0 16 16"
			}),
			VDOM$2.createElement("path", {
				d: "M1 5h13v9H1zm1 0h6L7 3H3z",
				fill: "currentColor",
				stroke: "none"
			})
		);
	},
	true
);

registerIcon(
	"folder-open",
	function(props) {
		return VDOM$2.createElement(
			"svg",
			_extends({}, props, {
				viewBox: "0 0 16 16"
			}),
			VDOM$2.createElement("path", {
				d: "M0 5v7l2.5-6H13V5zm1 0h6L6 3H2z",
				fill: "currentColor",
				stroke: "none"
			}),
			VDOM$2.createElement("path", {
				d: "M3 7h13l-3 7H0z",
				fill: "currentColor",
				stroke: "none"
			})
		);
	},
	true
);

registerIcon(
	"menu",
	function(props) {
		return VDOM$2.createElement(
			"svg",
			_extends({}, props, {
				viewBox: "0 0 24 24"
			}),
			VDOM$2.createElement("path", {
				d: "M0 0h24v24H0z",
				fill: "none"
			}),
			VDOM$2.createElement("path", {
				d:
					"M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z",
				fill: "currentColor"
			})
		);
	},
	true
);

registerIcon(
	"loading",
	function(props) {
		var style = {
			animation: "linear infinite 0.5s cx-rotate"
		};
		if (props && props.style) Object.assign(style, props.style);
		props = _objectSpread({}, props, {
			style: style
		});
		return VDOM$2.createElement(
			"svg",
			_extends({}, props, {
				viewBox: "0 0 50 50"
			}),
			VDOM$2.createElement("path", {
				fill: "currentColor",
				d:
					"M43.94 25.14c0-10.3-8.37-18.68-18.7-18.68-10.3 0-18.67 8.37-18.67 18.68h4.07c0-8.07 6.54-14.6 14.6-14.6 8.08 0 14.63 6.53 14.63 14.6h4.07z"
			})
		);
	},
	true
);

registerIcon(
	"search",
	function(props) {
		return VDOM$2.createElement(
			"svg",
			_extends({}, props, {
				viewBox: "0 0 32 32"
			}),
			VDOM$2.createElement("path", {
				fill: "currentColor",
				d:
					"M25.595 22.036l-5.26-5.075c.75-1.18 1.206-2.56 1.206-4.05 0-4.32-3.63-7.82-8.103-7.82-4.477 0-8.107 3.503-8.107 7.82 0 4.32 3.63 7.825 8.106 7.825 1.544 0 2.972-.44 4.198-1.162l5.26 5.074c.37.356.98.354 1.35 0l1.352-1.304c.37-.357.37-.947 0-1.304zm-12.16-3.91c-2.985 0-5.405-2.336-5.405-5.216 0-2.88 2.42-5.214 5.405-5.214 2.984 0 5.404 2.335 5.404 5.214 0 2.88-2.42 5.215-5.407 5.215z"
			})
		);
	},
	true
);

registerIcon(
	"cx",
	function(props) {
		return VDOM$2.createElement(
			"svg",
			_extends({}, props, {
				viewBox: "-347 249.7 48 48"
			}),
			VDOM$2.createElement(
				"g",
				null,
				VDOM$2.createElement("path", {
					fill: "currentColor",
					opacity: "0.7",
					d: "M-337.1 273.16l-4.23-7.33h8.46z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					d: "M-318.32 273.16l-4.23-7.33h8.46z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					opacity: "0.7",
					d: "M-337.53 273.43h-8.45l4.22-7.33z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					d: "M-309.38 273.43h-8.46l4.23-7.33z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					opacity: "0.7",
					d: "M-332.4 265.03l-4.22-7.33h8.46z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					d: "M-304.24 265.03l-4.23-7.33h8.45z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					d: "M-322.97 265.03l-4.28-7.33h8.5z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					opacity: "0.7",
					d: "M-332.87 265.3h-8.46l4.23-7.33z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					opacity: "0.7",
					d: "M-323.45 265.3h-8.46l4.2-7.33z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					d: "M-314.1 265.3h-8.45l4.23-7.33z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					d: "M-308.9 273.16l-4.23-7.33h8.46z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					d: "M-304.67 265.3h-8.46l4.23-7.33z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					d: "M-314.1 281.57h-8.45l4.23-7.33z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					d: "M-313.6 281.3l-4.24-7.33h8.46z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					d: "M-318.32 289.43l-4.23-7.33h8.46z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					d: "M-304.67 281.57h-8.46l4.23-7.33z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					d: "M-308.9 289.43l-4.23-7.33h8.46z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					opacity: "0.7",
					d: "M-341.76 281.3l-4.22-7.33h8.45z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					opacity: "0.7",
					d: "M-332.87 281.57h-8.46l4.23-7.33z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					opacity: "0.7",
					d: "M-337.1 289.43l-4.23-7.33h8.46z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					opacity: "0.7",
					d: "M-327.68 289.43l-4.23-7.33h8.43z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					opacity: "0.7",
					d: "M-328.16 289.7h-8.46l4.23-7.33z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					d: "M-318.75 289.7h-8.5l4.28-7.33z"
				}),
				VDOM$2.createElement("path", {
					fill: "currentColor",
					d: "M-300.02 289.7h-8.45l4.23-7.33z"
				})
			)
		);
	},
	true
);

registerIcon(
	"file",
	function(props) {
		return VDOM$2.createElement(
			"svg",
			_extends({}, props, {
				viewBox: "0 0 16 16"
			}),
			VDOM$2.createElement("path", {
				d: "M2 2h5v5h5v7H2z",
				fill: "currentColor",
				stroke: "none"
			}),
			VDOM$2.createElement("path", {
				d: "M8 2v4h4z",
				fill: "currentColor",
				stroke: "none"
			})
		);
	},
	true
);

var Icon =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(Icon, _Widget);

		function Icon() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = Icon.prototype;

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						name: undefined
					}
				])
			);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			return renderIcon(data.name, {
				key: key,
				className: data.classNames,
				style: data.style
			});
		};

		Icon.register = function register(name, icon, defaultIcon) {
			if (defaultIcon === void 0) {
				defaultIcon = false;
			}

			return registerIcon(name, icon, defaultIcon);
		};

		Icon.unregister = function unregister() {
			return unregisterIcon.apply(void 0, arguments);
		};

		Icon.render = function render(name, props) {
			return renderIcon(name, props);
		};

		Icon.clear = function clear() {
			return clearIcons();
		};

		Icon.registerFactory = function registerFactory(factory) {
			return registerIconFactory(factory);
		};

		Icon.restoreDefaultIcons = function restoreDefaultIcons$$1() {
			restoreDefaultIcons();
		};

		return Icon;
	})(Widget);
Icon.prototype.baseClass = "icon";
Icon.prototype.styled = true;
Widget.alias("icon", Icon);

function findFirst(el, condition) {
	if (condition(el)) return el;
	var children = el.childNodes;
	if (children)
		for (var i = 0; i < children.length; i++) {
			var child = findFirst(children[i], condition);
			if (child) return child;
		}
	return null;
}
function findFirstChild(el, condition) {
	var children = el.childNodes;
	if (children)
		for (var i = 0; i < children.length; i++) {
			var child = findFirst(children[i], condition);
			if (child) return child;
		}
	return null;
}
function closest(el, condition) {
	while (el) {
		if (condition(el)) return el;
		el = el.parentNode;
	}

	return null;
}
function closestParent(el, condition) {
	return el && closest(el.parentNode, condition);
}
function isFocused(el) {
	return document.activeElement == el;
}
function isFocusedDeep(el) {
	return document.activeElement == el || (document.activeElement && el.contains(document.activeElement));
}
var focusableWithoutTabIndex = ["INPUT", "SELECT", "TEXTAREA", "A", "BUTTON"];
function isFocusable(el) {
	var firstPass = el && isNumber(el.tabIndex) && el.tabIndex >= 0;
	if (!firstPass) return false;
	if (focusableWithoutTabIndex.indexOf(el.tagName) != -1 && !el.hasAttribute("disabled")) return true;
	return el.hasAttribute("tabindex");
}
function getFocusedElement() {
	return document.activeElement;
}
function isSelfOrDescendant(el, descEl) {
	return el == descEl || el.contains(descEl);
}

var passiveEventsSupported = null;
function browserSupportsPassiveEventHandlers() {
	if (passiveEventsSupported == null) {
		try {
			passiveEventsSupported = false;
			var options = Object.defineProperty({}, "passive", {
				get: function get() {
					passiveEventsSupported = true;
				}
			});
			window.addEventListener("test", null, options);
		} catch (e) {}
	}

	return passiveEventsSupported;
}

var isTouch = null;
function isTouchDevice() {
	if (isTouch == null) isTouch = typeof window != "undefined" && "ontouchstart" in window;
	return isTouch;
}

var lastTouchEvent = 0;
var isTouchDetectionEnabled = false;
function enableTouchEventDetection() {
	if (isTouchDevice() && !isTouchDetectionEnabled) {
		var options;
		if (browserSupportsPassiveEventHandlers())
			options = {
				passive: true
			};
		document.addEventListener(
			"touchstart",
			function() {
				lastTouchEvent = new Date().getTime();
			},
			options
		);
		document.addEventListener(
			"touchmove",
			function() {
				//console.log('TOUCHMOVE');
				lastTouchEvent = new Date().getTime();
			},
			options
		);
		document.addEventListener(
			"touchend",
			function() {
				lastTouchEvent = new Date().getTime(); //console.log('TOUCHEND');
			},
			options
		);
		isTouchDetectionEnabled = true;
	}
}
function isTouchEvent() {
	return isTouchDevice() && (!isTouchDetectionEnabled || new Date().getTime() - lastTouchEvent < 1000);
} //enable touch event detection if there is no performance penalty on scrolling

if (isTouchDevice() && browserSupportsPassiveEventHandlers()) enableTouchEventDetection();

//IE sometimes returns null while other browsers always return document.body.
function getActiveElement() {
	return document.activeElement || document.body;
}

/*
*  Purpose of FocusManager is to provide focusout notifications.
*  IE and Firefox do not provide relatedTarget info in blur events which makes it impossible
*  to determine if focus went outside or stayed inside the component.
*/

var subscribers = new SubscriberList(),
	timerInterval = 300,
	timerId = null;
var lastActiveElement = null;
var pending = false;
var FocusManager =
	/*#__PURE__*/
	(function() {
		function FocusManager() {}

		FocusManager.subscribe = function subscribe(callback) {
			var unsubscribe = subscribers.subscribe(callback);
			checkTimer();
			return unsubscribe;
		};

		FocusManager.onFocusOut = function onFocusOut(el, callback) {
			var active = isSelfOrDescendant(el, getActiveElement());
			return this.subscribe(function(focusedEl) {
				if (!active) active = isSelfOrDescendant(el, getActiveElement());
				else if (!isSelfOrDescendant(el, focusedEl)) {
					active = false;
					callback(focusedEl);
				}
			});
		};

		FocusManager.oneFocusOut = function oneFocusOut(el, callback) {
			this.nudge();
			var off = this.subscribe(function(focusedEl) {
				if (!isSelfOrDescendant(el, focusedEl)) {
					callback(focusedEl);
					off();
				}
			});
			return off;
		};

		FocusManager.nudge = function nudge() {
			if (typeof document !== "undefined" && getActiveElement() !== lastActiveElement) {
				if (!pending) {
					pending = true;
					setTimeout(function() {
						pending = false;

						if (getActiveElement() !== lastActiveElement) {
							lastActiveElement = getActiveElement();
							batchUpdates(function() {
								subscribers.notify(lastActiveElement);
							});
							checkTimer();
						}
					}, 0);
				}
			}
		};

		FocusManager.focus = function focus(el) {
			el.focus();
			this.nudge();
		};

		FocusManager.focusFirst = function focusFirst(el) {
			var focusable = findFirst(el, isFocusable);
			if (focusable) this.focus(focusable);
			return focusable;
		};

		FocusManager.focusFirstChild = function focusFirstChild(el) {
			var focusable = findFirstChild(el, isFocusable);
			if (focusable) this.focus(focusable);
			return focusable;
		};

		FocusManager.focusNext = function focusNext(el) {
			var next = el,
				skip = true;

			do {
				if (!skip) {
					var focusable = this.focusFirst(next);
					if (focusable) return focusable;
				}

				if (next.nextSibling) {
					next = next.nextSibling;
					skip = false;
				} else {
					next = next.parentNode;
					skip = true;
				}
			} while (next);
		};

		FocusManager.setInterval = function setInterval(interval) {
			timerInterval = interval;
			checkTimer();
		};

		return FocusManager;
	})();
function oneFocusOut(component, el, callback) {
	if (!component.oneFocusOut)
		component.oneFocusOut = FocusManager.oneFocusOut(el, function(focus) {
			delete component.oneFocusOut;
			callback(focus);
		});
}
function offFocusOut(component) {
	if (component.oneFocusOut) {
		component.oneFocusOut();
		delete component.oneFocusOut;
	}
}
function preventFocus(e) {
	//Focus can be prevented only on mousedown event. On touchstart should not call
	//preventDefault as it prevents scrolling
	if (e.type !== "mousedown") return;
	e.preventDefault(); //unfocus activeElement

	var activeElement = getActiveElement();

	if (e.currentTarget !== activeElement && !activeElement.contains(e.currentTarget)) {
		//force field validation on outside click, however, preserve active window or dropdown menu
		var focusableParent = closestParent(activeElement, isFocusable) || document.body;
		if (focusableParent === document.body) activeElement.blur();
		else focusableParent.focus();
		FocusManager.nudge();
	}
}

function checkTimer() {
	var shouldRun = !subscribers.isEmpty();
	if (shouldRun && !timerId)
		timerId = setInterval(function() {
			FocusManager.nudge();
		}, timerInterval);

	if (!shouldRun && timerId) {
		clearInterval(timerId);
		timerId = null;
	}
}

function preventFocusOnTouch(e, force) {
	if (force === void 0) {
		force = false;
	}

	if (force || isTouchEvent()) preventFocus(e);
}

var Button =
	/*#__PURE__*/
	(function(_HtmlElement) {
		_inheritsLoose(Button, _HtmlElement);

		function Button() {
			return _HtmlElement.apply(this, arguments) || this;
		}

		var _proto = Button.prototype;

		_proto.declareData = function declareData() {
			var _HtmlElement$prototyp;

			(_HtmlElement$prototyp = _HtmlElement.prototype.declareData).call.apply(
				_HtmlElement$prototyp,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						confirm: {
							structured: true
						},
						pressed: undefined,
						icon: undefined,
						disabled: undefined,
						enabled: undefined
					}
				])
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			data.stateMods = _objectSpread({}, data.stateMods, {
				pressed: data.pressed
			});
			if (isDefined(data.enabled)) data.disabled = !data.enabled;

			_HtmlElement.prototype.prepareData.call(this, context, instance);
		};

		_proto.explore = function explore(context, instance) {
			instance.data.parentDisabled = context.parentDisabled;
			if (instance.cache("parentDisabled", context.parentDisabled)) instance.markShouldUpdate(context);

			_HtmlElement.prototype.explore.call(this, context, instance);
		};

		_proto.attachProps = function attachProps(context, instance, props) {
			var _this = this;

			_HtmlElement.prototype.attachProps.call(this, context, instance, props);

			if (!this.focusOnMouseDown) {
				props.onMouseDown = function(e) {
					if (_this.onMouseDown) instance.invoke("onMouseDown", e, instance);
					preventFocus(e);
				};
			}

			if (this.dismiss) {
				var onClick = props.onClick;

				props.onClick = function() {
					if (onClick && onClick.apply(void 0, arguments) === false) return;
					if (instance.parentOptions && isFunction(instance.parentOptions.dismiss)) instance.parentOptions.dismiss();
				};
			}

			if (this.tag === "button") props.type = this.submit ? "submit" : "button";
			delete props.confirm;
			delete props.dismiss;
			delete props.pressed;
			delete props.submit;
			delete props.focusOnMouseDown;
			delete props.icon;
			delete props.enabled;
			var oldOnClick,
				data = instance.data;
			props.disabled = data.disabled || data.parentDisabled;

			if (data.confirm) {
				oldOnClick = props.onClick;

				props.onClick = function() {
					yesNo(data.confirm).then(function(btn) {
						if (btn == "yes") oldOnClick.call(_this, null);
					});
				};
			}

			var icon, children;

			if (data.icon) {
				icon = Icon.render(data.icon, {
					key: "icon",
					className: this.CSS.element(this.baseClass, "icon")
				});
				children = getContentArray(props.children);
				props.children = [icon].concat(children);
				props.className = this.CSS.expand(
					props.className,
					this.CSS.state("icon"),
					children.length == 0 && this.CSS.state("empty")
				);

				if (children.length == 0) {
					props.children.push(
						VDOM$2.createElement(
							"span",
							{
								key: "baseline",
								className: this.CSS.element(this.baseClass, "baseline")
							},
							"\xA0"
						)
					);
				}
			}
		};

		return Button;
	})(HtmlElement);
Button.prototype.tag = "button";
Button.prototype.baseClass = "button";
Button.prototype.icon = false;
Button.prototype.focusOnMouseDown = false;
Button.prototype.submit = false;
Widget.alias("button", Button);

var DocumentTitle =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(DocumentTitle, _Widget);

		function DocumentTitle() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = DocumentTitle.prototype;

		_proto.init = function init() {
			if (this.value) this.text = this.value;
			if (this.append) this.action = "append";

			_Widget.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						value: undefined,
						text: undefined,
						action: undefined,
						separator: undefined
					}
				])
			);
		};

		_proto.explore = function explore(context, instance) {
			if (!context.documentTitle) {
				context.documentTitle = {
					activeInstance: instance,
					title: ""
				};
			}

			var data = instance.data;

			if (data.text) {
				switch (data.action) {
					case "append":
						if (context.documentTitle.title) context.documentTitle.title += data.separator;
						context.documentTitle.title += data.text;
						break;

					case "prepend":
						context.documentTitle.title = data.text + data.separator + context.documentTitle.title;
						break;

					default:
					case "replace":
						context.documentTitle.title = data.text;
						break;
				}
			}

			_Widget.prototype.explore.call(this, context, instance);
		};

		_proto.prepare = function prepare(context, instance) {
			if (context.documentTitle.activeInstance == instance) document.title = context.documentTitle.title;
		};

		_proto.render = function render() {
			return null;
		};

		return DocumentTitle;
	})(Widget);
DocumentTitle.prototype.action = "append";
DocumentTitle.prototype.separator = "";
Widget.alias("document-title", DocumentTitle);

var AggregateFunction =
	/*#__PURE__*/
	(function() {
		function AggregateFunction() {}

		AggregateFunction.sum = function sum() {
			return new Sum();
		};

		AggregateFunction.avg = function avg() {
			return new Avg();
		};

		AggregateFunction.count = function count() {
			return new Count();
		};

		AggregateFunction.distinct = function distinct() {
			return new Distinct();
		};

		AggregateFunction.min = function min() {
			return new Min();
		};

		AggregateFunction.max = function max() {
			return new Max();
		};

		return AggregateFunction;
	})();

var Sum =
	/*#__PURE__*/
	(function() {
		function Sum() {}

		var _proto = Sum.prototype;

		_proto.process = function process(value) {
			this.empty = false;
			if (!isNaN(value)) this.result += value;
			else this.invalid = true;
		};

		_proto.getResult = function getResult() {
			if (this.invalid) return null;
			return this.result;
		};

		return Sum;
	})();

Sum.prototype.result = 0;
Sum.prototype.empty = true;

var Avg =
	/*#__PURE__*/
	(function() {
		function Avg() {}

		var _proto2 = Avg.prototype;

		_proto2.process = function process(value, count) {
			if (count === void 0) {
				count = 1;
			}

			this.empty = false;

			if (!isNaN(value) && !isNaN(count)) {
				this.result += value * count;
				this.count += count;
			} else this.invalid = true;
		};

		_proto2.getResult = function getResult() {
			if (this.empty || this.invalid || this.count == 0) return null;
			return this.result / this.count;
		};

		return Avg;
	})();

Avg.prototype.result = 0;
Avg.prototype.count = 0;
Avg.prototype.empty = true;

var Count =
	/*#__PURE__*/
	(function() {
		function Count() {}

		var _proto3 = Count.prototype;

		_proto3.process = function process(value) {
			if (value != null) this.result++;
		};

		_proto3.getResult = function getResult() {
			return this.result;
		};

		return Count;
	})();

Count.prototype.result = 0;

var Distinct =
	/*#__PURE__*/
	(function() {
		function Distinct() {
			this.values = {};
		}

		var _proto4 = Distinct.prototype;

		_proto4.process = function process(value) {
			if (value == null || this.values[value]) return;
			this.values[value] = true;
			this.empty = false;
			this.result++;
		};

		_proto4.getResult = function getResult() {
			if (this.empty || this.invalid) return null;
			return this.result;
		};

		return Distinct;
	})();

Distinct.prototype.result = 0;
Distinct.prototype.empty = true;

var Max =
	/*#__PURE__*/
	(function() {
		function Max() {}

		var _proto5 = Max.prototype;

		_proto5.process = function process(value) {
			if (!isNaN(value)) {
				if (this.empty) this.result = value;
				else if (value > this.result) this.result = value;
				this.empty = false;
			} else if (value != null) this.invalid = true;
		};

		_proto5.getResult = function getResult() {
			if (this.empty || this.invalid) return null;
			return this.result;
		};

		return Max;
	})();

Max.prototype.result = 0;
Max.prototype.empty = true;

var Min =
	/*#__PURE__*/
	(function() {
		function Min() {}

		var _proto6 = Min.prototype;

		_proto6.process = function process(value) {
			if (!isNaN(value)) {
				if (this.empty) this.result = value;
				else if (value < this.result) this.result = value;
				this.empty = false;
			} else if (value != null) this.invalid = true;
		};

		_proto6.getResult = function getResult() {
			if (this.empty || this.invalid) return null;
			return this.result;
		};

		return Min;
	})();

Min.prototype.result = 0;
Min.prototype.empty = true;

/*
 'column': {
   index: 0,
   sort: 'asc',
   group: true
   aggregate: 'count'
 }
 */

function transform(o, f) {
	var res = {};

	for (var k in o) {
		res[k] = f(o[k], k);
	}

	return res;
}

var Grouper =
	/*#__PURE__*/
	(function() {
		function Grouper(key, aggregates, dataGetter, nameGetter) {
			this.keys = Object.keys(key).map(function(k) {
				return {
					name: k,
					value: getSelector(key[k])
				};
			});
			if (nameGetter) this.nameGetter = getSelector(nameGetter);

			this.dataGetter =
				dataGetter ||
				function(x) {
					return x;
				};

			this.aggregates =
				aggregates &&
				transform(aggregates, function(prop) {
					if (!AggregateFunction[prop.type]) throw new Error("Unknown aggregate function '" + prop.type + "'.");
					return {
						value: getSelector(prop.value),
						weight: getSelector(prop.weight || 1),
						type: prop.type
					};
				});
			this.reset();
		}

		var _proto = Grouper.prototype;

		_proto.reset = function reset() {
			this.groups = this.initGroup(this.keys.length == 0);
		};

		_proto.initGroup = function initGroup(leaf) {
			if (!leaf) return {};
			return {
				records: [],
				indexes: [],
				aggregates:
					this.aggregates &&
					transform(this.aggregates, function(prop) {
						var f = AggregateFunction[prop.type];
						return {
							processor: f(),
							value: prop.value,
							weight: prop.weight
						};
					})
			};
		};

		_proto.process = function process(record, index) {
			var data = this.dataGetter(record);
			var key = this.keys.map(function(k) {
				return k.value(data);
			});
			var g = this.groups;

			for (var i = 0; i < key.length; i++) {
				var sg = g[key[i]];

				if (!sg) {
					sg = g[key[i]] = this.initGroup(i + 1 == key.length);
					if (this.nameGetter) sg.name = this.nameGetter(data);
				}

				g = sg;
			}

			g.records.push(record);
			g.indexes.push(index);

			if (g.aggregates) {
				for (var k in g.aggregates) {
					g.aggregates[k].processor.process(g.aggregates[k].value(data), g.aggregates[k].weight(data));
				}
			}
		};

		_proto.processAll = function processAll(records, indexes) {
			var _this = this;

			if (indexes) {
				for (var i = 0; i < records.length; i++) {
					this.process(records[i], indexes[i]);
				}
			} else
				records.forEach(function(r, i) {
					return _this.process(r, i);
				});
		};

		_proto.report = function report(g, path, level, results) {
			var _this2 = this;

			if (level == this.keys.length) {
				var key = {};
				this.keys.forEach(function(k, i) {
					return (key[k.name] = path[i]);
				});
				results.push({
					key: key,
					name: g.name,
					records: g.records,
					indexes: g.indexes,
					aggregates: transform(g.aggregates, function(p) {
						return p.processor.getResult();
					})
				});
			} else {
				Object.keys(g).forEach(function(k) {
					return _this2.report(g[k], [].concat(path, [k]), level + 1, results);
				});
			}
		};

		_proto.getResults = function getResults() {
			var g = this.groups;
			var results = [];
			this.report(g, [], 0, results);
			return results;
		};

		return Grouper;
	})();

var GroupAdapter =
	/*#__PURE__*/
	(function(_ArrayAdapter) {
		_inheritsLoose(GroupAdapter, _ArrayAdapter);

		function GroupAdapter() {
			return _ArrayAdapter.apply(this, arguments) || this;
		}

		var _proto = GroupAdapter.prototype;

		_proto.init = function init() {
			_ArrayAdapter.prototype.init.call(this);

			if (this.groupings) this.groupBy(this.groupings);
		};

		_proto.getRecords = function getRecords(context, instance, records, parentStore) {
			var result = _ArrayAdapter.prototype.getRecords.call(this, context, instance, records, parentStore);

			if (this.groupings) {
				var groupedResults = [];
				this.processLevel([], result, groupedResults, parentStore);
				result = groupedResults;
			}

			return result;
		};

		_proto.processLevel = function processLevel(keys, records, result, parentStore) {
			var _this = this;

			var level = keys.length;
			var inverseLevel = this.groupings.length - level;

			if (inverseLevel == 0) {
				for (var i = 0; i < records.length; i++) {
					records[i].store.setStore(parentStore);
					result.push(records[i]);
				}

				return;
			}

			var grouping = this.groupings[level];
			var grouper = grouping.grouper;
			grouper.reset();
			grouper.processAll(records);
			var results = grouper.getResults();
			if (grouping.comparer) results.sort(grouping.comparer);
			results.forEach(function(gr) {
				var _data;

				keys.push(gr.key);

				var $group = _objectSpread({}, gr.key, gr.aggregates, {
					$name: gr.name,
					$level: inverseLevel
				});

				var groupStore = new ReadOnlyDataView({
					store: parentStore,
					data: ((_data = {}), (_data[_this.groupName] = $group), _data),
					immutable: _this.immutable
				});
				var group = {
					key: keys
						.map(function(key) {
							return Object.keys(key)
								.map(function(k) {
									return key[k];
								})
								.join(":");
						})
						.join("|"),
					data: gr.records[0],
					group: $group,
					grouping: grouping,
					store: groupStore,
					level: inverseLevel
				};
				if (grouping.includeHeader !== false)
					result.push(
						_objectSpread({}, group, {
							type: "group-header",
							key: "header:" + group.key
						})
					);

				_this.processLevel(keys, gr.records, result, groupStore);

				if (grouping.includeFooter !== false)
					result.push(
						_objectSpread({}, group, {
							type: "group-footer",
							key: "footer:" + group.key
						})
					);
				keys.pop();
			});
		};

		_proto.groupBy = function groupBy(groupings) {
			var _this2 = this;

			if (!groupings) this.groupings = null;
			else if (isArray(groupings)) {
				this.groupings = groupings;
				this.groupings.forEach(function(g) {
					var groupSorters = [];
					var key = {};

					for (var name in g.key) {
						if (!g.key[name] || !isDefined(g.key[name].direction) || !isDefined(g.key[name].value))
							g.key[name] = {
								value: g.key[name],
								direction: "ASC"
							};
						key[name] = g.key[name].value;
						groupSorters.push({
							field: name,
							direction: g.key[name].direction
						});
					}

					g.grouper = new Grouper(
						key,
						_objectSpread({}, _this2.aggregates, g.aggregates),
						function(r) {
							return r.store.getData();
						},
						g.text
					);
					g.comparer = null;
					if (groupSorters.length > 0)
						g.comparer = getComparer(groupSorters, function(x) {
							return x.key;
						});
				});
			} else throw new Error("Invalid grouping provided.");
		};

		return GroupAdapter;
	})(ArrayAdapter);
GroupAdapter.prototype.groupName = "$group";

var Selection =
	/*#__PURE__*/
	(function(_Component) {
		_inheritsLoose(Selection, _Component);

		function Selection() {
			return _Component.apply(this, arguments) || this;
		}

		var _proto = Selection.prototype;

		_proto.isSelected = function isSelected(store, record, index) {
			return this.bind && store.get(this.bind) === record;
		};

		_proto.getIsSelectedDelegate = function getIsSelectedDelegate(store) {
			var _this = this;

			return function(record, index) {
				return _this.isSelected(store, record, index);
			};
		};

		_proto.select = function select(store, record, index, options) {
			this.selectMultiple(store, [record], [index], options);
		};

		_proto.selectMultiple = function selectMultiple(store, records, indexes, options) {
			//abstract
		};

		_proto.declareData = function declareData() {
			var declaration = {
				$selection: {
					structured: true
				}
			};
			return Object.assign.apply(Object, [declaration].concat(Array.prototype.slice.call(arguments)));
		};

		_proto.configureWidget = function configureWidget(widget) {
			if (this.record || this.index) {
				widget.$selection = Object.assign(widget.$selection || {}, {
					record: this.record,
					index: this.index
				});
			}

			return this.declareData();
		};

		_proto.selectInstance = function selectInstance(instance) {
			var store = instance.store,
				data = instance.data;
			if (!data.$selection)
				throw new Error(
					"Selection model not properly configured. Using the selectInstance method without specified record and index bindings."
				);
			return this.select(store, data.$selection.record, data.$selection.index);
		};

		_proto.isInstanceSelected = function isInstanceSelected(instance) {
			var store = instance.store,
				data = instance.data;
			return data.$selection && this.isSelected(store, data.$selection.record, data.$selection.index);
		};

		return Selection;
	})(Component);
Selection.prototype.toggle = false;
Selection.namespace = "ui.selection.";

var SimpleSelection =
	/*#__PURE__*/
	(function(_Selection) {
		_inheritsLoose(SimpleSelection, _Selection);

		function SimpleSelection() {
			return _Selection.apply(this, arguments) || this;
		}

		var _proto2 = SimpleSelection.prototype;

		_proto2.isSelected = function isSelected(store, record, index) {
			return this.getIsSelectedDelegate(store)(record, index);
		};

		_proto2.getIsSelectedDelegate = function getIsSelectedDelegate(store) {
			var selection = this.bind && store.get(this.bind);
			return function(record, index) {
				return record === selection;
			};
		};

		_proto2.selectMultiple = function selectMultiple(store, records, index) {
			if (this.bind) store.set(this.bind, records[0]);
		};

		return SimpleSelection;
	})(Selection);

var DummySelection =
	/*#__PURE__*/
	(function(_Selection2) {
		_inheritsLoose(DummySelection, _Selection2);

		function DummySelection() {
			return _Selection2.apply(this, arguments) || this;
		}

		var _proto3 = DummySelection.prototype;

		_proto3.isSelected = function isSelected(store, record, index) {
			return false;
		};

		_proto3.selectMultiple = function selectMultiple() {
			//dummy
		};

		_proto3.selectInstance = function selectInstance() {
			//dummy
		};

		return DummySelection;
	})(Selection);

DummySelection.prototype.isDummy = true;

Selection.factory = function(name) {
	if (typeof name == "object") return new SimpleSelection(name);
	return new DummySelection();
};

var KeyCode = {
	backspace: 8,
	tab: 9,
	enter: 13,
	shift: 16,
	ctrl: 17,
	alt: 18,
	esc: 27,
	space: 32,
	pageUp: 33,
	pageDown: 34,
	end: 35,
	home: 36,
	left: 37,
	up: 38,
	right: 39,
	down: 40,
	insert: 45,
	delete: 46
};

function findScrollableParent(sourceEl, horizontal) {
	if (horizontal === void 0) {
		horizontal = false;
	}

	var scrollParent =
		sourceEl &&
		closest(sourceEl, function(el) {
			if (el.nodeType != Node.ELEMENT_NODE) return false;
			if (!horizontal && el.clientHeight >= el.scrollHeight) return false;
			if (horizontal && el.clientWidth >= el.scrollWidth) return false;
			var overflow = getComputedStyle(el)[horizontal ? "overflow-x" : "overflow-y"];
			return overflow == "auto" || overflow == "scroll";
		});
	return scrollParent || sourceEl.ownerDocument.scrollingElement || sourceEl.ownerDocument.documentElement;
}

function getParentFrameBoundingClientRect(el) {
	if (el.ownerDocument == document) {
		return {
			top: 0,
			left: 0,
			right: window.innerWidth,
			bottom: window.innerHeight,
			width: window.innerWidth,
			height: window.innerHeight
		};
	}

	var frames = document.getElementsByTagName("iframe");

	for (var i = 0; i < frames.length; i++) {
		if (frames[i].contentDocument == el.ownerDocument) {
			return frames[i].getBoundingClientRect();
		}
	}
}

function getTopLevelBoundingClientRect(el) {
	var bounds = el.getBoundingClientRect();
	var offset = getParentFrameBoundingClientRect(el);
	return {
		top: bounds.top + offset.top,
		left: bounds.left + offset.left,
		bottom: bounds.bottom + offset.top,
		right: bounds.right + offset.left,
		width: bounds.right - bounds.left,
		height: bounds.bottom - bounds.top
	};
}

function getScrollerBoundingClientRect(scrollEl, topLevel) {
	if (topLevel === void 0) {
		topLevel = false;
	}

	if (scrollEl == scrollEl.ownerDocument.body || scrollEl == scrollEl.ownerDocument.documentElement) {
		if (topLevel) return getParentFrameBoundingClientRect(scrollEl.ownerDocument.body);
		return {
			left: 0,
			top: 0,
			right: window.innerWidth,
			bottom: window.innerHeight,
			width: window.innerWidth,
			height: window.innerHeight
		};
	}

	return topLevel ? getTopLevelBoundingClientRect(scrollEl) : scrollEl.getBoundingClientRect();
}

function scrollElementIntoView(el, vertical, horizontal) {
	if (vertical === void 0) {
		vertical = true;
	}

	if (horizontal === void 0) {
		horizontal = false;
	}

	if (horizontal) {
		var parentEl = findScrollableParent(el, true);

		if (parentEl) {
			var pr = getScrollerBoundingClientRect(parentEl);
			var er = el.getBoundingClientRect();
			var scrollbarWidth = parentEl.offsetWidth - parentEl.clientWidth;
			if (er.right > pr.right - scrollbarWidth)
				parentEl.scrollLeft = Math.max(0, parentEl.scrollLeft + er.right - pr.right + scrollbarWidth);
			if (er.left < pr.left) parentEl.scrollLeft = Math.max(0, parentEl.scrollLeft + er.left - pr.left);
		}
	}

	if (vertical) {
		var _parentEl = findScrollableParent(el);

		if (_parentEl) {
			var _pr = getScrollerBoundingClientRect(_parentEl);

			var _er = el.getBoundingClientRect();

			var scrollbarHeight = _parentEl.offsetHeight - _parentEl.clientHeight;
			if (_er.bottom > _pr.bottom - scrollbarHeight)
				_parentEl.scrollTop = Math.max(0, _parentEl.scrollTop + _er.bottom - _pr.bottom + scrollbarHeight);
			if (_er.top < _pr.top) _parentEl.scrollTop = Math.max(0, _parentEl.scrollTop + _er.top - _pr.top);
		}
	}
}

/*
 - renders list of items
 - focusable (keyboard navigation)
 - selection
 - fake focus - list appears focused and receives keyboard inputs redirected from other control (dropdown scenario)
 */

var List =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(List, _Widget);

		function List() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = List.prototype;

		_proto.init = function init() {
			if (this.recordAlias) this.recordName = this.recordAlias;
			if (this.indexAlias) this.indexName = this.indexAlias;
			this.adapter = GroupAdapter.create(this.adapter || GroupAdapter, {
				recordName: this.recordName,
				indexName: this.indexName,
				recordsBinding: isBinding(this.records) && Binding.get(this.records.bind),
				keyField: this.keyField
			});
			this.child = Widget.create({
				type: PureContainer,
				layout: this.layout,
				items: this.items,
				children: this.children,
				styled: true,
				class: this.itemClass,
				className: this.itemClassName,
				style: this.itemStyle
			});
			delete this.children;
			this.selection = Selection.create(this.selection, {
				records: this.records
			});

			_Widget.prototype.init.call(this);

			if (this.grouping) {
				this.groupBy(this.grouping);
			}
		};

		_proto.initInstance = function initInstance(context, instance) {
			this.adapter.initInstance(context, instance);
		};

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			var selection = this.selection.configureWidget(this);

			(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[
					this,
					selection,
					{
						records: undefined,
						sorters: undefined,
						sortField: undefined,
						sortDirection: undefined,
						filterParams: {
							structured: true
						},
						itemStyle: {
							structured: true
						},
						emptyText: undefined,
						tabIndex: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var _this = this;

			var data = instance.data;
			if (data.sortField)
				data.sorters = [
					{
						field: data.sortField,
						direction: data.sortDirection || "ASC"
					}
				];
			this.adapter.sort(data.sorters);
			var filter = null;
			if (this.onCreateFilter) filter = instance.invoke("onCreateFilter", data.filterParams, instance);
			else if (this.filter)
				filter = function filter(item) {
					return _this.filter(item, data.filterParams);
				};
			this.adapter.setFilter(filter);
			instance.mappedRecords = this.adapter.getRecords(context, instance, data.records, instance.store);
			data.stateMods = Object.assign(data.stateMods || {}, {
				selectable: !this.selection.isDummy || this.onItemClick,
				empty: instance.mappedRecords.length == 0
			});

			_Widget.prototype.prepareData.call(this, context, instance);
		};

		_proto.explore = function explore(context, instance, data) {
			var _this2 = this;

			var instances = [];
			var isSelected = this.selection.getIsSelectedDelegate(instance.store);
			instance.mappedRecords.forEach(function(record) {
				if (record.type == "data") {
					var itemInstance = instance.getChild(context, _this2.child, record.key, record.store);
					itemInstance.record = record;
					itemInstance.selected = isSelected(record.data, record.index);
					var changed = false;
					if (itemInstance.cache("recordData", record.data)) changed = true;
					if (itemInstance.cache("selected", itemInstance.selected)) changed = true;

					if (_this2.cached && !changed && itemInstance.visible && !itemInstance.childStateDirty) {
						instances.push(itemInstance);
						itemInstance.shouldUpdate = false;
					} else if (itemInstance.scheduleExploreIfVisible(context)) instances.push(itemInstance);
				} else if (record.type == "group-header" && record.grouping.header) {
					var _itemInstance = instance.getChild(context, record.grouping.header, record.key, record.store);

					_itemInstance.record = record;
					if (_itemInstance.scheduleExploreIfVisible(context)) instances.push(_itemInstance);
				} else if (record.type == "group-footer" && record.grouping.footer) {
					var _itemInstance2 = instance.getChild(context, record.grouping.footer, record.key, record.store);

					_itemInstance2.record = record;
					if (_itemInstance2.scheduleExploreIfVisible(context)) instances.push(_itemInstance2);
				}
			});
			instance.instances = instances;
		};

		_proto.render = function render(context, instance, key) {
			var items = instance.instances.map(function(x, i) {
				return {
					instance: x,
					key: x.record.key,
					type: x.record.type,
					content: getContent(x.render(context))
				};
			});
			return VDOM$2.createElement(ListComponent, {
				key: key,
				instance: instance,
				items: items,
				selectable: !this.selection.isDummy || this.onItemClick
			});
		};

		_proto.groupBy = function groupBy(grouping) {
			var _this3 = this;

			if (grouping) {
				if (!isArray(grouping)) {
					if (isString(grouping) || typeof grouping == "object") return this.groupBy([grouping]);
					throw new Error("DynamicGrouping should be an array of grouping objects");
				}

				grouping = grouping.map(function(g, i) {
					if (isString(g)) {
						var _key;

						return {
							key: ((_key = {}),
							(_key[g] = {
								bind: _this3.recordName + "." + g
							}),
							_key)
						};
					}

					return g;
				});
			}

			grouping.forEach(function(g) {
				if (g.header) g.header = Widget.create(g.header);
				if (g.footer) g.footer = Widget.create(g.footer);
			});
			this.adapter.groupBy(grouping);
			this.update();
		};

		return List;
	})(Widget);
List.prototype.recordName = "$record";
List.prototype.indexName = "$index";
List.prototype.baseClass = "list";
List.prototype.focusable = true;
List.prototype.focused = false;
List.prototype.itemPad = true;
List.prototype.cached = false;
List.prototype.styled = true;
List.prototype.scrollSelectionIntoView = false;
Widget.alias("list", List);

var ListComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(ListComponent, _VDOM$Component);

		function ListComponent(props) {
			var _context;

			var _this4;

			_this4 = _VDOM$Component.call(this, props) || this;
			var widget = props.instance.widget;
			var focused = widget.focused;
			_this4.state = {
				cursor: focused && props.selectable ? 0 : -1,
				focused: focused
			};
			_this4.handleItemMouseDown = (_context = _this4).handleItemMouseDown.bind(_context);
			_this4.handleItemDoubleClick = (_context = _this4).handleItemDoubleClick.bind(_context);
			_this4.handleItemClick = (_context = _this4).handleItemClick.bind(_context);
			return _this4;
		}

		var _proto2 = ListComponent.prototype;

		_proto2.shouldComponentUpdate = function shouldComponentUpdate(props, state) {
			return props.instance.shouldUpdate || state != this.state;
		};

		_proto2.componentDidMount = function componentDidMount() {
			var instance = this.props.instance;
			var widget = instance.widget;

			if (widget.pipeKeyDown) {
				instance.invoke("pipeKeyDown", this.handleKeyDown.bind(this), instance);
				this.showCursor();
			}
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			this.setState({
				cursor: Math.max(Math.min(this.state.cursor, props.items.length - 1), this.state.focused ? 0 : -1)
			});
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			var instance = this.props.instance;
			var widget = instance.widget;
			offFocusOut(this);
			if (widget.pipeKeyDown) instance.invoke("pipeKeyDown", null, instance);
		};

		_proto2.handleItemMouseDown = function handleItemMouseDown(e) {
			var index = Number(e.currentTarget.dataset.recordIndex);
			this.moveCursor(index);
			if (e.shiftKey) e.preventDefault();
			this.moveCursor(index, {
				select: true,
				selectOptions: {
					toggle: e.ctrlKey
				},
				selectRange: e.shiftKey
			});
		};

		_proto2.handleItemClick = function handleItemClick(e) {
			var _this$props = this.props,
				instance = _this$props.instance,
				items = _this$props.items;
			var index = Number(e.currentTarget.dataset.recordIndex);
			var item = items[this.cursorChildIndex[index]];
			if (instance.invoke("onItemClick", e, item.instance) === false) return;
			this.moveCursor(index, {
				select: true,
				selectOptions: {
					toggle: e.ctrlKey
				},
				selectRange: e.shiftKey
			});
		};

		_proto2.handleItemDoubleClick = function handleItemDoubleClick(e) {
			var _this$props2 = this.props,
				instance = _this$props2.instance,
				items = _this$props2.items;
			var index = Number(e.currentTarget.dataset.recordIndex);
			var item = items[this.cursorChildIndex[index]];
			instance.invoke("onItemDoubleClick", e, item.instance);
		};

		_proto2.render = function render() {
			var _this5 = this;

			var _this$props3 = this.props,
				instance = _this$props3.instance,
				items = _this$props3.items,
				selectable = _this$props3.selectable;
			var data = instance.data,
				widget = instance.widget;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var itemStyle = CSS.parseStyle(data.itemStyle);
			this.cursorChildIndex = [];
			var cursorIndex = 0;
			var onDblClick, onClick;
			if (widget.onItemClick) onClick = this.handleItemClick;
			if (widget.onItemDoubleClick) onDblClick = this.handleItemDoubleClick;
			var children =
				items.length > 0 &&
				items.map(function(x, i) {
					var _x$instance = x.instance,
						data = _x$instance.data,
						selected = _x$instance.selected;
					var className;

					if (x.type == "data") {
						var ind = cursorIndex++;

						_this5.cursorChildIndex.push(i);

						className = CSS.element(baseClass, "item", {
							selected: selected,
							cursor: ind == _this5.state.cursor,
							pad: widget.itemPad
						});
						return VDOM$2.createElement(
							"li",
							{
								key: x.key,
								className: CSS.expand(className, data.classNames),
								style: itemStyle,
								"data-record-index": ind,
								onMouseDown: _this5.handleItemMouseDown,
								onClick: onClick,
								onDoubleClick: onDblClick
							},
							x.content
						);
					} else {
						return VDOM$2.createElement(
							"li",
							{
								key: x.key,
								className: CSS.element(baseClass, x.type)
							},
							x.content
						);
					}
				});

			if (!children && data.emptyText) {
				children = VDOM$2.createElement(
					"li",
					{
						className: CSS.element(baseClass, "empty-text")
					},
					data.emptyText
				);
			}

			return VDOM$2.createElement(
				"ul",
				{
					ref: function ref(el) {
						_this5.el = el;
					},
					className: CSS.expand(
						data.classNames,
						CSS.state({
							focused: this.state.focused
						})
					),
					style: data.style,
					tabIndex: widget.focusable && selectable && items.length > 0 ? data.tabIndex || 0 : null,
					onMouseDown: function onMouseDown(e) {
						return preventFocusOnTouch(e);
					},
					onKeyDown: this.handleKeyDown.bind(this),
					onMouseLeave: this.handleMouseLeave.bind(this),
					onFocus: this.onFocus.bind(this),
					onBlur: this.onBlur.bind(this)
				},
				children
			);
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			var widget = this.props.instance.widget;

			if (widget.scrollSelectionIntoView) {
				var CSS = widget.CSS,
					baseClass = widget.baseClass;
				var selectedRowSelector = "." + CSS.element(baseClass, "item") + "." + CSS.state("selected");
				var firstSelectedRow = this.el.querySelector(selectedRowSelector);

				if (firstSelectedRow != this.selectedEl) {
					if (firstSelectedRow) scrollElementIntoView(firstSelectedRow);
					this.selectedEl = firstSelectedRow;
				}
			}
		};

		_proto2.moveCursor = function moveCursor(index, _temp) {
			var _this6 = this;

			var _ref = _temp === void 0 ? {} : _temp,
				focused = _ref.focused,
				hover = _ref.hover,
				scrollIntoView = _ref.scrollIntoView,
				select = _ref.select,
				selectRange = _ref.selectRange,
				selectOptions = _ref.selectOptions;

			var _this$props4 = this.props,
				instance = _this$props4.instance,
				selectable = _this$props4.selectable;
			if (!selectable) return;
			var widget = instance.widget;
			var newState = {};
			if (widget.focused) focused = true;
			if (focused != null && this.state.focused != focused) newState.focused = focused; //ignore mouse enter/leave events (support with a flag if a feature request comes)

			if (!hover) newState.cursor = index;

			if (select) {
				var start = selectRange && this.state.selectionStart >= 0 ? this.state.selectionStart : index;
				if (start < 0) start = index;
				this.selectRange(start, index, selectOptions);
				if (!selectRange) newState.selectionStart = index;
			}

			if (Object.keys(newState).length > 0) {
				this.setState(newState, function() {
					if (scrollIntoView) {
						var item = _this6.el.children[_this6.cursorChildIndex[index]];
						if (item) scrollElementIntoView(item);
					}
				});
			}
		};

		_proto2.selectRange = function selectRange(from, to, options) {
			var _this$props5 = this.props,
				instance = _this$props5.instance,
				items = _this$props5.items;
			var widget = instance.widget;

			if (from > to) {
				var tmp = from;
				from = to;
				to = tmp;
			}

			var selection = [],
				indexes = [];

			for (var cursor = from; cursor <= to; cursor++) {
				var item = items[this.cursorChildIndex[cursor]];

				if (item) {
					var record = item.instance.record;
					selection.push(record.data);
					indexes.push(record.index);
				}
			}

			widget.selection.selectMultiple(instance.store, selection, indexes, options);
		};

		_proto2.showCursor = function showCursor(focused) {
			if (this.state.cursor == -1) {
				var index = -1,
					firstSelected = -1;

				for (var i = 0; i < this.props.items.length; i++) {
					if (this.props.items[i].type == "data") {
						index++;

						if (this.props.items[i].instance.selected) {
							firstSelected = index;
							break;
						}
					}
				}

				this.moveCursor(firstSelected != -1 ? firstSelected : 0, {
					focused: true
				});
			}
		};

		_proto2.onFocus = function onFocus() {
			var _this7 = this;

			FocusManager.nudge();
			this.showCursor(true);
			var widget = this.props.instance.widget;
			if (!widget.focused)
				oneFocusOut(this, this.el, function() {
					_this7.moveCursor(-1, {
						focused: false
					});
				});
			this.setState({
				focused: true
			});
		};

		_proto2.onBlur = function onBlur() {
			FocusManager.nudge();
		};

		_proto2.handleMouseLeave = function handleMouseLeave() {
			this.moveCursor(-1, {
				hover: true
			});
		};

		_proto2.handleKeyDown = function handleKeyDown(e) {
			var _this$props6 = this.props,
				instance = _this$props6.instance,
				items = _this$props6.items;
			var widget = instance.widget;
			if (this.onKeyDown && instance.invoke("onKeyDown", e, instance) === false) return;

			switch (e.keyCode) {
				case KeyCode.enter:
					var item = items[this.cursorChildIndex[this.state.cursor]];
					if (item && widget.onItemClick && instance.invoke("onItemClick", e, item.instance) === false) return;
					this.moveCursor(this.state.cursor, {
						select: true,
						selectOptions: {
							toggle: e.ctrlKey
						},
						selectRange: e.shiftKey
					});
					break;

				case KeyCode.down:
					if (this.state.cursor + 1 < this.cursorChildIndex.length) {
						this.moveCursor(this.state.cursor + 1, {
							focused: true,
							scrollIntoView: true,
							select: e.shiftKey,
							selectRange: true
						});
						e.stopPropagation();
						e.preventDefault();
					}

					break;

				case KeyCode.up:
					if (this.state.cursor > 0) {
						this.moveCursor(this.state.cursor - 1, {
							focused: true,
							scrollIntoView: true,
							select: e.shiftKey,
							selectRange: true
						});
						e.stopPropagation();
						e.preventDefault();
					}

					break;
			}
		};

		return ListComponent;
	})(VDOM$2.Component);

var ExposedValueView =
	/*#__PURE__*/
	(function(_View) {
		_inheritsLoose(ExposedValueView, _View);

		function ExposedValueView() {
			return _View.apply(this, arguments) || this;
		}

		var _proto = ExposedValueView.prototype;

		_proto.getData = function getData() {
			if (this.sealed && this.meta.version === this.cache.version && this.cache.key === this.key)
				return this.cache.result;
			var data = this.store.getData();
			var container = this.containerBinding.value(data) || {};
			var record = container[this.key];
			this.cache.version = this.meta.version;
			this.cache.key = this.key;
			this.cache.result = this.sealed || this.immutable || this.store.sealed ? _objectSpread({}, data) : data;
			this.cache.result[this.recordName] = record;
			return this.cache.result;
		};

		_proto.setKey = function setKey(key) {
			this.key = key;
		};

		_proto.getKey = function getKey() {
			return this.key;
		};

		_proto.setItem = function setItem(path, value) {
			if (path == this.recordName || path.indexOf(this.recordName + ".") == 0) {
				var data = this.getData();
				var d = Binding.get(path).set(data, value);
				if (d === data) return false;
				var container = this.containerBinding.value(d);
				var record = d[this.recordName];
				var newContainer = Object.assign({}, container);
				newContainer[this.key] = record;
				return this.store.setItem(this.containerBinding.path, newContainer);
			}

			return this.store.setItem(path, value);
		};

		_proto.deleteItem = function deleteItem(path) {
			var data, container, newContainer;

			if (path == this.recordName) {
				data = this.getData();
				container = this.containerBinding.value(data);
				if (!container || !container.hasOwnProperty(path)) return false;
				newContainer = Object.assign({}, container);
				delete newContainer[this.key];
				this.store.set(this.containerBinding.path, newContainer);
			} else if (path.indexOf(this.recordName + ".") == 0) {
				data = this.getData();
				var d = Binding.get(path).delete(data);
				if (d === data) return false;
				container = this.containerBinding.value(d);
				var record = d[this.recordName];
				newContainer = Object.assign({}, container);
				newContainer[this.key] = record;
				return this.store.setItem(this.containerBinding.path, newContainer);
			}

			return this.store.deleteItem(path);
		};

		return ExposedValueView;
	})(View);
ExposedValueView.prototype.immutable = false;

var Sandbox =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(Sandbox, _PureContainer);

		function Sandbox() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = Sandbox.prototype;

		_proto.init = function init() {
			if (this.recordAlias) this.recordName = this.recordAlias;
			if (this.accessKey) this.key = this.accessKey;
			this.storageBinding = Binding.get(this.storage.bind);

			_PureContainer.prototype.init.call(this);
		};

		_proto.initInstance = function initInstance(context, instance) {
			instance.store = new ExposedValueView({
				store: instance.store,
				containerBinding: this.storageBinding,
				key: null,
				recordName: this.recordName,
				immutable: this.immutable
			});

			instance.setStore = function(store) {
				instance.store.setStore(store);
			};
		};

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			(_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[
					this,
					{
						storage: undefined,
						key: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var store = instance.store,
				data = instance.data;

			if (store.getKey() !== data.key) {
				instance.store = new ExposedValueView({
					store: store,
					containerBinding: this.storageBinding,
					key: data.key,
					recordName: this.recordName,
					immutable: this.immutable
				}); //when navigating to a page using the same widget tree as the previous page
				//everything needs to be reinstantiated, e.g. user/1 => user/2

				instance.clearChildrenCache();
			}

			_PureContainer.prototype.prepareData.call(this, context, instance);
		};

		return Sandbox;
	})(PureContainer);
Sandbox.prototype.recordName = "$page";
Sandbox.prototype.immutable = false;
Widget.alias("sandbox", Sandbox);

var CxCredit =
	/*#__PURE__*/
	(function(_HtmlElement) {
		_inheritsLoose(CxCredit, _HtmlElement);

		function CxCredit() {
			return _HtmlElement.apply(this, arguments) || this;
		}

		var _proto = CxCredit.prototype;

		_proto.init = function init() {
			this.tooltip = {
				mouseTrap: true,
				title: "Credits",
				items: {
					$type: HtmlElement,
					tag: "div",
					ws: true,
					jsxAttributes: ["ws"],
					children: [
						"\n               User interface of this project is implemented using the CxJS framework.\n               For more information about CxJS, please visit\n               ",
						{
							$type: HtmlElement,
							tag: "a",
							href: "https://cxjs.io/",
							target: "_blank",
							jsxAttributes: ["href", "target"],
							children: ["the CxJS homepage"]
						},
						".\n            "
					]
				}
			};

			_HtmlElement.prototype.init.call(this);
		};

		_proto.attachProps = function attachProps(context, instance, props) {
			props.children = Icon.render("cx", {
				className: this.CSS.element(this.baseClass, "icon")
			});
		};

		return CxCredit;
	})(HtmlElement);
CxCredit.prototype.baseClass = "cxcredit";
CxCredit.prototype.tag = "div";
Widget.alias("cx-credit", CxCredit);

var Heading =
	/*#__PURE__*/
	(function(_HtmlElement) {
		_inheritsLoose(Heading, _HtmlElement);

		function Heading() {
			return _HtmlElement.apply(this, arguments) || this;
		}

		var _proto = Heading.prototype;

		_proto.init = function init() {
			this.tag = "h" + this.level;

			_HtmlElement.prototype.init.call(this);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var _objectSpread2;

			var data = instance.data;
			data.stateMods = _objectSpread(
				{},
				data.stateMods,
				((_objectSpread2 = {}), (_objectSpread2["level-" + this.level] = true), _objectSpread2)
			);

			_HtmlElement.prototype.prepareData.call(this, context, instance);
		};

		_proto.isValidHtmlAttribute = function isValidHtmlAttribute(attrName) {
			switch (attrName) {
				case "level":
					return false;

				default:
					return _HtmlElement.prototype.isValidHtmlAttribute.call(this, attrName);
			}
		};

		return Heading;
	})(HtmlElement);
Heading.prototype.level = 3;
Heading.prototype.baseClass = "heading";

var Section =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(Section, _Container);

		function Section() {
			return _Container.apply(this, arguments) || this;
		}

		var _proto = Section.prototype;

		_proto.init = function init() {
			if (isString(this.headerStyle)) this.headerStyle = parseStyle(this.headerStyle);
			if (isString(this.footerStyle)) this.footerStyle = parseStyle(this.footerStyle);
			if (isString(this.bodyStyle)) this.bodyStyle = parseStyle(this.bodyStyle);

			_Container.prototype.init.call(this);
		};

		_proto.add = function add(item) {
			if (item && item.putInto == "header")
				this.header = _objectSpread({}, item, {
					putInto: null
				});
			else if (item && item.putInto == "footer")
				this.footer = _objectSpread({}, item, {
					putInto: null
				});
			else _Container.prototype.add.apply(this, arguments);
		};

		_proto.declareData = function declareData() {
			return _Container.prototype.declareData.call(this, {
				id: undefined,
				headerStyle: {
					structured: true
				},
				headerClass: {
					structured: true
				},
				bodyStyle: {
					structured: true
				},
				bodyClass: {
					structured: true
				},
				footerStyle: {
					structured: true
				},
				footerClass: {
					structured: true
				}
			});
		};

		_proto.initComponents = function initComponents() {
			_Container.prototype.initComponents.call(this, {
				header: this.getHeader(),
				footer: this.getFooter()
			});
		};

		_proto.getHeader = function getHeader() {
			if (this.title)
				return Widget.create(Heading, {
					text: this.title,
					level: this.hLevel
				});
			if (this.header) return Heading.create(this.header);
			return null;
		};

		_proto.getFooter = function getFooter() {
			if (this.footer) return Widget.create(this.footer);
			return null;
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			data.stateMods = _objectSpread({}, data.stateMods, {
				pad: this.pad
			});

			_Container.prototype.prepareData.call(this, context, instance);
		};

		_proto.initInstance = function initInstance(context, instance) {
			instance.eventHandlers = instance.getJsxEventProps();

			_Container.prototype.initInstance.call(this, context, instance);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data,
				components = instance.components,
				eventHandlers = instance.eventHandlers;
			var header, footer;
			var CSS = this.CSS,
				baseClass = this.baseClass;

			if (components.header) {
				header = VDOM$2.createElement(
					"header",
					{
						className: CSS.expand(CSS.element(baseClass, "header"), data.headerClass),
						style: data.headerStyle
					},
					getContent(components.header.render(context))
				);
			}

			if (components.footer) {
				footer = VDOM$2.createElement(
					"footer",
					{
						className: CSS.expand(CSS.element(baseClass, "footer"), data.footerClass),
						style: data.footerStyle
					},
					getContent(components.footer.render(context))
				);
			}

			return VDOM$2.createElement(
				"section",
				_extends(
					{
						key: key,
						className: data.classNames,
						style: data.style,
						id: data.id
					},
					eventHandlers
				),
				header,
				VDOM$2.createElement(
					"div",
					{
						className: CSS.expand(CSS.element(this.baseClass, "body"), data.bodyClass),
						style: data.bodyStyle
					},
					this.renderChildren(context, instance)
				),
				footer
			);
		};

		return Section;
	})(Container);
Section.prototype.styled = true;
Section.prototype.pad = true;
Section.prototype.baseClass = "section";
Section.prototype.hLevel = 3;

var FlexBox =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(FlexBox, _Container);

		function FlexBox() {
			return _Container.apply(this, arguments) || this;
		}

		var _proto = FlexBox.prototype;

		_proto.init = function init() {
			if (this.padding) this.pad = this.padding;
			if (this.hpadding) this.hpad = this.hpadding;
			if (this.vpadding) this.vpad = this.vpadding;
			this.hpad = isUndefined(this.hpad) ? this.pad : this.hpad;
			this.vpad = isUndefined(this.vpad) ? this.pad : this.hpad;
			if (this.hpad === true) this.hpad = "medium";
			if (this.vpad === true) this.vpad = "medium";
			this.hspacing = isUndefined(this.hspacing) ? this.spacing : this.hspacing;
			this.vspacing = isUndefined(this.vspacing) ? this.spacing : this.vspacing;
			if (this.hspacing === true) this.hspacing = "medium";
			if (this.vspacing === true) this.vspacing = "medium";

			_Container.prototype.init.call(this);
		};

		_proto.initInstance = function initInstance(context, instance) {
			instance.eventHandlers = instance.getJsxEventProps();

			_Container.prototype.initInstance.call(this, context, instance);
		};

		_proto.prepareCSS = function prepareCSS(context, instance) {
			var _objectSpread2;

			var data = instance.data;
			data.stateMods = _objectSpread(
				{},
				data.stateMods,
				((_objectSpread2 = {}),
				(_objectSpread2[this.hpad + "-hpad"] = this.hpad),
				(_objectSpread2[this.vpad + "-vpad"] = this.vpad),
				(_objectSpread2.nested = this.nested),
				_objectSpread2)
			);

			_Container.prototype.prepareCSS.call(this, context, instance);
		};

		_proto.render = function render(context, instance, key) {
			var _flexboxMods;

			var data = instance.data,
				eventHandlers = instance.eventHandlers;
			var CSS = this.CSS,
				baseClass = this.baseClass;
			var flexboxMods = ((_flexboxMods = {}),
			(_flexboxMods[this.hspacing + "-hspacing"] = this.hspacing),
			(_flexboxMods[this.vspacing + "-vspacing"] = this.vspacing),
			(_flexboxMods["align-" + this.align] = this.align),
			(_flexboxMods["justify-" + this.justify] = this.justify),
			(_flexboxMods.wrap = this.wrap),
			(_flexboxMods["target-" + this.target] = true),
			(_flexboxMods[this.direction] = true),
			_flexboxMods);
			return VDOM$2.createElement(
				"div",
				_extends(
					{
						key: key,
						className: data.classNames,
						style: data.style
					},
					eventHandlers
				),
				VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "flexbox", flexboxMods)
					},
					this.renderChildren(context, instance)
				)
			);
		};

		return FlexBox;
	})(Container);
FlexBox.prototype.baseClass = "flexbox";
FlexBox.prototype.styled = true;
FlexBox.prototype.direction = "row";
FlexBox.prototype.spacing = false;
FlexBox.prototype.hspacing = undefined;
FlexBox.prototype.vspacing = undefined;
FlexBox.prototype.pad = false;
FlexBox.prototype.hpad = undefined;
FlexBox.prototype.vpad = undefined;
FlexBox.prototype.wrap = false;
FlexBox.prototype.align = false;
FlexBox.prototype.justify = false;
FlexBox.prototype.target = "any";
FlexBox.prototype.nested = false;
var FlexRow =
	/*#__PURE__*/
	(function(_FlexBox) {
		_inheritsLoose(FlexRow, _FlexBox);

		function FlexRow() {
			return _FlexBox.apply(this, arguments) || this;
		}

		return FlexRow;
	})(FlexBox);
var FlexCol =
	/*#__PURE__*/
	(function(_FlexBox2) {
		_inheritsLoose(FlexCol, _FlexBox2);

		function FlexCol() {
			return _FlexBox2.apply(this, arguments) || this;
		}

		return FlexCol;
	})(FlexBox);
FlexCol.prototype.direction = "column";

var ProgressBar =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(ProgressBar, _Widget);

		function ProgressBar() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = ProgressBar.prototype;

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			return (_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[
					this,
					{
						disabled: undefined,
						text: undefined,
						value: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.render = function render(context, instance, key) {
			var widget = instance.widget,
				data = instance.data;
			var text = data.text,
				value = data.value,
				disabled = data.disabled;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			if (!isNumber(value)) value = 0;
			return VDOM$2.createElement(
				"div",
				{
					key: key,
					className: CSS.expand(
						data.classNames,
						CSS.state({
							disabled: disabled
						})
					),
					style: data.style
				},
				VDOM$2.createElement("div", {
					className: CSS.element(this.baseClass, "indicator"),
					style: {
						width: (value > 1 ? 1 : value < 0 ? 0 : value) * 100 + "%"
					}
				}),
				VDOM$2.createElement(
					"div",
					{
						className: CSS.element(this.baseClass, "label")
					},
					text
				)
			);
		};

		return ProgressBar;
	})(Widget);
ProgressBar.prototype.styled = true;
ProgressBar.prototype.disabled = false;
ProgressBar.prototype.baseClass = "progressbar";

function captureMouse(e, onMouseMove, onMouseUp, captureData, cursor) {
	var surface = document.createElement("div");
	surface.className = "cxb-mousecapture";
	if (cursor) surface.style.cursor = cursor;
	document.body.appendChild(surface);

	if (surface.setCapture) {
		e.preventDefault();
		surface.setCapture(true);
	}

	var move = function move(e) {
		batchUpdates(function() {
			if (onMouseMove) onMouseMove(e, captureData);
			e.stopPropagation();
			e.preventDefault(); //disable text selection
		});
	};

	var end = function end(e) {
		batchUpdates(function() {
			if (surface.releaseCapture) surface.releaseCapture();
			surface.style.display = "none";

			try {
				if (onMouseUp) onMouseUp(e, captureData);
			} finally {
				surface.removeEventListener("mousemove", move);
				surface.removeEventListener("mouseup", end);
				document.body.removeChild(surface);
			}
		});
	};

	surface.addEventListener("mousemove", move);
	surface.addEventListener("mouseup", end);
	e.stopPropagation();
}
function captureMouseOrTouch(e, onMouseMove, onMouseUp, captureData, cursor) {
	if (e.type.indexOf("touch") == 0) {
		var el = e.currentTarget;

		var move = function move(e) {
			batchUpdates(function() {
				if (onMouseMove) onMouseMove(e, captureData);
				e.preventDefault();
			});
		};

		var end = function end(e) {
			batchUpdates(function() {
				el.removeEventListener("touchmove", move);
				el.removeEventListener("touchend", end);
				if (onMouseUp) onMouseUp(e);
				e.preventDefault();
			});
		};

		el.addEventListener("touchmove", move);
		el.addEventListener("touchend", end);
		e.stopPropagation();
	} else captureMouse(e, onMouseMove, onMouseUp, captureData, cursor || e.target.style.cursor);
}
function getCursorPos(e) {
	var p = (e.touches && e.touches[0]) || e;
	var offset = getParentFrameBoundingClientRect(e.target);
	return {
		clientX: p.clientX + offset.left,
		clientY: p.clientY + offset.top
	};
}

var Resizer =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(Resizer, _Widget);

		function Resizer() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = Resizer.prototype;

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[this].concat(args, [
					{
						size: undefined,
						defaultSize: undefined,
						minSize: undefined,
						maxSize: undefined
					}
				])
			);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			return VDOM$2.createElement(ResizerCmp, {
				key: key,
				instance: instance,
				data: data
			});
		};

		return Resizer;
	})(Widget);
Resizer.prototype.baseClass = "resizer";
Resizer.prototype.styled = true;
Resizer.prototype.horizontal = false;
Resizer.prototype.forNextElement = false;
Resizer.prototype.defaultSize = null;
Resizer.prototype.minSize = 0;
Resizer.prototype.maxSize = 1e6;

var ResizerCmp =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(ResizerCmp, _VDOM$Component);

		function ResizerCmp(props) {
			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			_this.state = {
				dragged: false,
				offset: 0
			};
			return _this;
		}

		var _proto2 = ResizerCmp.prototype;

		_proto2.shouldComponentUpdate = function shouldComponentUpdate(props, state) {
			return state != this.state;
		};

		_proto2.render = function render() {
			var _this2 = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				data = _this$props.data;
			var widget = instance.widget;
			var baseClass = widget.baseClass,
				CSS = widget.CSS;
			return VDOM$2.createElement(
				"div",
				{
					ref: function ref(el) {
						_this2.el = el;
					},
					className: CSS.expand(
						data.classNames,
						CSS.state({
							vertical: !widget.horizontal,
							horizontal: widget.horizontal
						})
					),
					style: data.style,
					onDoubleClick: function onDoubleClick(e) {
						instance.set("size", data.defaultSize);
					},
					onMouseDown: function onMouseDown(e) {
						var initialPosition = getCursorPos(e);

						_this2.setState({
							dragged: true,
							initialPosition: initialPosition
						});
					},
					onMouseUp: function onMouseUp(e) {
						_this2.setState({
							dragged: false
						});
					},
					onMouseMove: this.startCapture.bind(this),
					onMouseLeave: this.startCapture.bind(this)
				},
				VDOM$2.createElement("div", {
					className: CSS.element(baseClass, "handle", {
						dragged: this.state.dragged
					}),
					style: {
						left: !widget.horizontal ? this.state.offset : 0,
						top: widget.horizontal ? this.state.offset : 0
					}
				})
			);
		};

		_proto2.startCapture = function startCapture(e) {
			var instance = this.props.instance;
			var widget = instance.widget;

			if (this.state.dragged && !this.hasCapture) {
				this.hasCapture = true;
				captureMouseOrTouch(
					e,
					this.onHandleMove.bind(this),
					this.onDragComplete.bind(this),
					this.state.initialPosition,
					widget.horizontal ? "row-resize" : "col-resize"
				);
			}
		};

		_proto2.onHandleMove = function onHandleMove(e, initialPosition) {
			var instance = this.props.instance;
			var widget = instance.widget;
			var currentPosition = getCursorPos(e);
			var offset = !widget.horizontal
				? currentPosition.clientX - initialPosition.clientX
				: currentPosition.clientY - initialPosition.clientY;
			var size = this.getNewSize(0);
			var newSize = this.getNewSize(offset);
			var allowedOffset = widget.forNextElement ? size - newSize : newSize - size;
			this.setState({
				offset: allowedOffset
			});
		};

		_proto2.getNewSize = function getNewSize(offset) {
			var _this$props2 = this.props,
				instance = _this$props2.instance,
				data = _this$props2.data;
			var _instance$widget = instance.widget,
				horizontal = _instance$widget.horizontal,
				forNextElement = _instance$widget.forNextElement;
			if (
				!this.el ||
				(!forNextElement && !this.el.previousElementSibling) ||
				(forNextElement && !this.el.nextElementSibling)
			)
				return 0;
			var newSize;

			if (horizontal) {
				if (forNextElement) newSize = this.el.nextElementSibling.offsetHeight - offset;
				else newSize = this.el.previousElementSibling.offsetHeight + offset;
			} else {
				if (forNextElement) newSize = this.el.nextElementSibling.offsetWidth - offset;
				else newSize = this.el.previousElementSibling.offsetWidth + offset;
			}

			return Math.max(data.minSize, Math.min(newSize, data.maxSize));
		};

		_proto2.onDragComplete = function onDragComplete() {
			this.hasCapture = false;
			var instance = this.props.instance;
			instance.set("size", this.getNewSize(this.state.offset));
			this.setState({
				dragged: false,
				offset: 0
			});
		};

		return ResizerCmp;
	})(VDOM$2.Component);

function startAppLoop(parentDOMElement, storeOrInstance, widget, options) {
	if (options === void 0) {
		options = {};
	}

	if (!parentDOMElement || parentDOMElement.nodeType !== 1)
		throw new Error("First argument to startAppLoop should be a valid DOM element.");
	var store, instance, parentInstance;
	if (!storeOrInstance) storeOrInstance = new Store();
	if (storeOrInstance.notify) store = storeOrInstance;
	else if (storeOrInstance.getChild) {
		if (storeOrInstance.widget === widget) instance = storeOrInstance;
		else parentInstance = storeOrInstance;
	} else throw new Error("Second argument to startAppLoop should be either of type Store or Instance");
	var root = VDOM$2.createElement(Cx, {
		store: store,
		widget: widget,
		instance: instance,
		parentInstance: parentInstance,
		options: options,
		subscribe: true
	});
	VDOM$2.DOM.render(root, parentDOMElement);
	var stopped = false;
	return function() {
		if (stopped) return;
		stopped = true;
		if (!options.destroyDelay) destroy(parentDOMElement, options);
		else {
			setTimeout(function() {
				destroy(parentDOMElement, options);
			}, options.destroyDelay);
		}
	};
}

function destroy(parentDOMElement, options) {
	VDOM$2.DOM.unmountComponentAtNode(parentDOMElement);
	if (options.removeParentDOMElement && parentDOMElement.parentNode)
		parentDOMElement.parentNode.removeChild(parentDOMElement);
}

var lastZIndex = 10000;
var ZIndexManager =
	/*#__PURE__*/
	(function() {
		function ZIndexManager() {}

		ZIndexManager.next = function next() {
			return ++lastZIndex;
		};

		ZIndexManager.reset = function reset(zIndex) {
			lastZIndex = zIndex;
		};

		return ZIndexManager;
	})();

var dropZones = new SubscriberList(),
	dragStartedZones,
	activeZone,
	nearZones,
	puppet,
	scrollTimer,
	vscrollParent,
	hscrollParent;
function registerDropZone(dropZone) {
	return dropZones.subscribe(dropZone);
}
function initiateDragDrop(e, options, onDragEnd) {
	if (options === void 0) {
		options = {};
	}

	if (puppet) {
		//last operation didn't finish properly
		notifyDragDrop(e);
	}

	var sourceEl = options.sourceEl || e.currentTarget;
	var sourceBounds = getTopLevelBoundingClientRect(sourceEl);
	var cursor = getCursorPos(e);

	var clone = _objectSpread({}, options.clone);

	var cloneEl = document.createElement("div");
	cloneEl.classList.add("cxb-dragclone");
	if (isString(clone["class"])) cloneEl.classList.add(clone["class"]);
	if (isObject(clone.style)) Object.assign(cloneEl.style, clone.style);
	cloneEl.style.left = "-1000px";
	cloneEl.style.top = "-1000px";
	if (clone.matchSize || clone.matchWidth) cloneEl.style.width = Math.ceil(sourceBounds.width) + "px";
	if (clone.matchSize || clone.matchHeight) cloneEl.style.height = Math.ceil(sourceBounds.height) + "px";
	cloneEl.style.zIndex = ZIndexManager.next() + 1000;

	if (clone.cloneContent) {
		cloneEl.appendChild(sourceEl.cloneNode(true));
	}

	document.body.appendChild(cloneEl);
	var styles = getComputedStyle(sourceEl);
	var deltaX = clone.matchCursorOffset ? cursor.clientX - sourceBounds.left : -3;
	var deltaY = clone.matchCursorOffset ? cursor.clientY - sourceBounds.top : -3;

	var source = _objectSpread({}, options.source, {
		width: sourceBounds.width,
		height: sourceBounds.height,
		deltaX: deltaX,
		deltaY: deltaY,
		margin: [
			styles.getPropertyValue("margin-top"),
			styles.getPropertyValue("margin-right"),
			styles.getPropertyValue("margin-bottom"),
			styles.getPropertyValue("margin-left")
		]
	});

	puppet = {
		deltaX: deltaX,
		deltaY: deltaY,
		el: cloneEl,
		clone: clone,
		source: source,
		onDragEnd: onDragEnd
	};

	if (clone.widget && clone.store && !clone.cloneContent) {
		puppet.stop = startAppLoop(cloneEl, clone.store, clone.widget, {
			removeParentDOMElement: true
		});
	} else {
		puppet.stop = function() {
			document.body.removeChild(cloneEl);
		};
	}

	var event = getDragEvent(e, "dragstart");
	dragStartedZones = new WeakMap();
	dropZones.execute(function(zone) {
		if (zone.onDropTest && !zone.onDropTest(event)) return;
		if (zone.onDragStart) zone.onDragStart(event);
		dragStartedZones.set(zone, true);
	});
	notifyDragMove(e);
	captureMouseOrTouch(e, notifyDragMove, notifyDragDrop);
}

function notifyDragMove(e, captureData) {
	var event = getDragEvent(e, "dragmove");
	var over = null,
		best = null;
	var near = [],
		away = [];
	dropZones.execute(function(zone) {
		if (zone.onDropTest && !zone.onDropTest(event)) return;

		if (zone.onDragMeasure) {
			var result = zone.onDragMeasure(event) || {};
			if (result.near) near.push(zone);
			else away.push(zone);

			if (isNumber(result.over) && (best == null || result.over < best)) {
				over = zone;
				best = result.over;
			}
		}
	});
	var newNear = new WeakMap();

	if (nearZones != null) {
		away.forEach(function(z) {
			if (z.onDragAway && nearZones.has(z)) z.onDragAway(z);
		});
	}

	near.forEach(function(z) {
		if (z.onDragNear && z != over && (nearZones == null || !nearZones.has(z))) {
			z.onDragNear(z);
			newNear.set(z, true);
		}
	});
	nearZones = newNear;

	if (over != activeZone) {
		vscrollParent = null;
		hscrollParent = null;
	}

	if (over != activeZone && activeZone && activeZone.onDragLeave) activeZone.onDragLeave(event);

	if (over != activeZone && over) {
		if (over.onDragEnter) over.onDragEnter(event);
		vscrollParent = over.onGetVScrollParent && over.onGetVScrollParent();
		hscrollParent = over.onGetHScrollParent && over.onGetHScrollParent();
	}

	activeZone = over;

	if (over && over.onDragOver) {
		over.onDragOver(event);
	} //do it last to avoid forced redraw if nothing changed

	var cursor = getCursorPos(e);
	puppet.el.style.left = cursor.clientX - puppet.deltaX + "px";
	puppet.el.style.top = cursor.clientY - puppet.deltaY + "px";

	if (vscrollParent || hscrollParent) {
		var scrollX = 0,
			scrollY = 0;
		var vscrollBounds = vscrollParent && getScrollerBoundingClientRect(vscrollParent, true);
		var hscrollBounds =
			hscrollParent == vscrollParent
				? vscrollBounds
				: hscrollParent && getScrollerBoundingClientRect(hscrollParent, true);

		if (vscrollBounds) {
			if (cursor.clientY < vscrollBounds.top + 20) scrollY = -1;
			else if (cursor.clientY >= vscrollBounds.bottom - 20) scrollY = 1;
		}

		if (hscrollBounds) {
			if (cursor.clientX < hscrollBounds.left + 20) scrollX = -1;
			else if (cursor.clientX >= hscrollBounds.right - 20) scrollX = 1;
		}

		if (scrollY || scrollX) {
			if (!scrollTimer) {
				var cb = function cb() {
					if (scrollY) {
						var current = vscrollParent.scrollTop;
						var next = Math.min(
							vscrollParent.scrollHeight,
							Math.max(0, current + scrollY * 5 * Math.min(200, Math.max(50, event.source.height)) / 60)
						); //60 FPS

						vscrollParent.scrollTop = next;
					}

					if (scrollX) {
						var _current = hscrollParent.scrollLeft;

						var _next = Math.min(
							hscrollParent.scrollWidth,
							Math.max(0, _current + scrollX * 5 * Math.min(200, Math.max(50, event.source.width)) / 60)
						); //60 FPS

						hscrollParent.scrollLeft = _next;
					}

					scrollTimer = requestAnimationFrame(cb);
				};

				scrollTimer = requestAnimationFrame(cb);
			}
		} else {
			clearScrollTimer();
		}
	} else clearScrollTimer();
}

function clearScrollTimer() {
	if (scrollTimer) {
		cancelAnimationFrame(scrollTimer);
		scrollTimer = null;
	}
}

function notifyDragDrop(e) {
	clearScrollTimer();
	var event = getDragEvent(e, "dragdrop");
	if (puppet.stop) puppet.stop();
	if (activeZone && activeZone.onDrop) event.result = activeZone.onDrop(event);
	dropZones.execute(function(zone) {
		if (nearZones != null && zone.onDragAway && nearZones.has(zone)) zone.onDragAway(e);
		if (!dragStartedZones.has(zone)) return;
		if (zone.onDragEnd) zone.onDragEnd(event);
	});
	if (puppet.onDragEnd) puppet.onDragEnd(event);
	nearZones = null;
	activeZone = null;
	puppet = null;
	dragStartedZones = null;
}

function getDragEvent(e, type) {
	return {
		type: type,
		event: e,
		cursor: getCursorPos(e),
		source: puppet.source
	};
}

var dragCandidate = {};
function ddMouseDown(e) {
	dragCandidate = {
		el: e.currentTarget,
		start: _objectSpread({}, getCursorPos(e))
	};
}
function ddMouseUp() {
	dragCandidate = {};
}
function ddDetect(e) {
	var cursor = getCursorPos(e);

	if (
		e.currentTarget == dragCandidate.el &&
		Math.abs(cursor.clientX - dragCandidate.start.clientX) + Math.abs(cursor.clientY - dragCandidate.start.clientY) >= 2
	) {
		dragCandidate = {};
		return true;
	}
}
var lastDragHandle;
function ddHandle(e) {
	lastDragHandle = e.currentTarget;
}
function isDragHandleEvent(e) {
	return lastDragHandle && (e.target == lastDragHandle || lastDragHandle.contains(e.target));
}

/*
 Features:
 - renders itself on top of other elements
 - provide resizing capabilities
 - adds positioning hook and ability to position itself in the center of the page
 - provides header, body, and footer elements and updates body's height on resize (move this to Window)
 - stop mouse events from bubbling to parents, but allow keystrokes
 */

var Overlay =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(Overlay, _Container);

		function Overlay() {
			return _Container.apply(this, arguments) || this;
		}

		var _proto = Overlay.prototype;

		_proto.declareData = function declareData() {
			var _Container$prototype$;

			return (_Container$prototype$ = _Container.prototype.declareData).call.apply(
				_Container$prototype$,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						shadowStyle: {
							structured: true
						},
						resizable: undefined,
						draggable: undefined
					}
				])
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			data.stateMods = _objectSpread({}, data.stateMods, {
				inline: this.inline,
				modal: this.modal,
				pad: this.pad,
				resizable: data.resizable,
				draggable: data.draggable,
				animate: this.animate
			});

			_Container.prototype.prepareData.call(this, context, instance);
		};

		_proto.explore = function explore(context, instance) {
			if (isBinding(this.visible)) {
				if (!instance.dismiss) {
					instance.dismiss = function() {
						if (instance.onBeforeDismiss && instance.onBeforeDismiss() === false) return;
						instance.set("visible", false);
					};
				}
			} else if (context.options.dismiss) instance.dismiss = context.options.dismiss;

			if (instance.dismiss) {
				context.push(
					"parentOptions",
					_objectSpread({}, context.parentOptions, {
						dismiss: instance.dismiss
					})
				);
			}

			if (instance.cache("dismiss", instance.dismiss)) instance.markShouldUpdate(context);

			_Container.prototype.explore.call(this, context, instance);
		};

		_proto.exploreCleanup = function exploreCleanup(context, instance) {
			if (instance.dismiss) context.pop("parentOptions");
		};

		_proto.render = function render(context, instance, key) {
			return VDOM$2.createElement(
				OverlayComponent,
				{
					key: key,
					instance: instance,
					subscribeToBeforeDismiss: context.options.subscribeToBeforeDismiss,
					parentEl: context.options.parentEl
				},
				this.renderContents(context, instance)
			);
		};

		_proto.renderContents = function renderContents(context, instance) {
			return this.renderChildren(context, instance);
		};

		_proto.overlayDidMount = function overlayDidMount(instance, component) {
			if (this.center) {
				var el = component.el;
				if (!el.style.left) el.style.left = (window.innerWidth - el.offsetWidth) / 2 + "px";
				if (!el.style.top) el.style.top = (window.innerHeight - el.offsetHeight) / 2 + "px";
			}
		};

		_proto.overlayDidUpdate = function overlayDidUpdate(instance, component) {};

		_proto.overlayWillUnmount = function overlayWillUnmount(instance, component) {};

		_proto.handleFocusOut = function handleFocusOut(instance, component) {
			if (this.onFocusOut) instance.invoke("onFocusOut", instance, component);
			if (this.dismissOnFocusOut && instance.dismiss) instance.dismiss();
		};

		_proto.handleKeyDown = function handleKeyDown(e, instance, component) {
			return this.onKeyDown && instance.invoke("onKeyDown", e, instance, component);
		};

		_proto.handleMouseLeave = function handleMouseLeave(instance, component) {
			if (this.onMouseLeave) instance.invoke("onMouseLeave", instance, component);
		};

		_proto.handleMouseEnter = function handleMouseEnter(instance, component) {
			if (this.onMouseEnter) instance.invoke("onMouseEnter", instance, component);
		};

		_proto.containerFactory = function containerFactory() {
			var el = document.createElement("div");
			document.body.appendChild(el);
			el.style.position = "absolute";
			if (this.containerStyle) Object.assign(el.style, parseStyle(this.containerStyle));
			return el;
		};

		_proto.open = function open(storeOrInstance, options) {
			if (!this.initialized) this.init();
			var el = this.containerFactory();
			el.style.display = "hidden";
			var beforeDismiss, stop;
			options = _objectSpread(
				{
					destroyDelay: this.destroyDelay,
					removeParentDOMElement: true
				},
				options,
				{
					parentEl: el,
					dismiss: function dismiss() {
						if (beforeDismiss && beforeDismiss() === false) return;
						stop();
						beforeDismiss = null;
					},
					subscribeToBeforeDismiss: function subscribeToBeforeDismiss(cb) {
						beforeDismiss = cb;
					}
				}
			);
			options.name = options.name || "overlay";
			stop = startAppLoop(el, storeOrInstance, this, options);
			return options.dismiss;
		};

		_proto.handleMove = function handleMove(e, instance, component) {
			var _this = this;

			var widget = instance.widget;

			if (!widget.onMove || instance.invoke("onMove", e, instance, component) !== false) {
				instance.store.silently(function() {
					if (isObject(_this.style) && isObject(_this.style.top) && _this.style.top.bind) {
						instance.store.set(_this.style.top.bind, component.el.style.top);
					}

					if (isObject(_this.style) && isObject(_this.style.left) && _this.style.left.bind) {
						instance.store.set(_this.style.left.bind, component.el.style.left);
					}
				});
			}
		};

		_proto.handleResize = function handleResize(e, instance, component) {
			var _this2 = this;

			var widget = instance.widget;

			if (!widget.onResize || instance.invoke("onResize", e, instance, component) !== false) {
				instance.store.silently(function() {
					if (isObject(_this2.style) && isObject(_this2.style.width) && _this2.style.width.bind) {
						instance.store.set(_this2.style.width.bind, component.el.style.width);
					}

					if (isObject(_this2.style) && isObject(_this2.style.height) && _this2.style.height.bind) {
						instance.store.set(_this2.style.height.bind, component.el.style.height);
					}
				});
			}
		};

		return Overlay;
	})(Container);
Overlay.prototype.styled = true;
Overlay.prototype.baseClass = "overlay";
Overlay.prototype.resizable = false;
Overlay.prototype.resizeWidth = 7;
Overlay.prototype.center = false;
Overlay.prototype.modal = false;
Overlay.prototype.backdrop = false;
Overlay.prototype.inline = false;
Overlay.prototype.autoFocus = false;
Overlay.prototype.autoFocusFirstChild = false;
Overlay.prototype.animate = false;
Overlay.prototype.draggable = false;
Overlay.prototype.destroyDelay = 0;
Overlay.prototype.dismissOnFocusOut = false;
Overlay.prototype.focusable = false;
Overlay.prototype.containerStyle = null;
Overlay.prototype.dismissOnPopState = false;
Widget.alias("overlay", Overlay); //TODO: all el related logic should be moved here

var OverlayContent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(OverlayContent, _VDOM$Component);

		function OverlayContent() {
			return _VDOM$Component.apply(this, arguments) || this;
		}

		var _proto2 = OverlayContent.prototype;

		_proto2.render = function render() {
			return VDOM$2.createElement(
				"div",
				{
					ref: this.props.onRef,
					className: this.props.className,
					style: this.props.style,
					tabIndex: this.props.tabIndex,
					onFocus: this.props.onFocus,
					onBlur: this.props.onBlur,
					onKeyDown: this.props.onKeyDown,
					onMouseMove: this.props.onMouseMove,
					onMouseUp: this.props.onMouseUp,
					onMouseDown: this.props.onMouseDown,
					onTouchStart: this.props.onTouchStart,
					onTouchEnd: this.props.onTouchEnd,
					onTouchMove: this.props.onTouchMove,
					onMouseEnter: this.props.onMouseEnter,
					onMouseLeave: this.props.onMouseLeave,
					onClick: this.props.onClick
				},
				this.props.children
			);
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			this.props.onDidUpdate();
		};

		return OverlayContent;
	})(VDOM$2.Component); //TODO: This should be called OverlayPortal

var OverlayComponent =
	/*#__PURE__*/
	(function(_VDOM$Component2) {
		_inheritsLoose(OverlayComponent, _VDOM$Component2);

		function OverlayComponent(props) {
			var _this3;

			_this3 = _VDOM$Component2.call(this, props) || this;
			_this3.state = {};
			_this3.customStyle = {};
			return _this3;
		}

		var _proto3 = OverlayComponent.prototype;

		_proto3.render = function render() {
			var _this$props = this.props,
				instance = _this$props.instance,
				parentEl = _this$props.parentEl;
			var widget = instance.widget;
			if (widget.inline || parentEl) return this.renderOverlay();

			if (!this.containerEl) {
				this.ownedEl = widget.containerFactory();
				this.ownedEl.style.display = "hidden";
				this.containerEl = this.ownedEl;
			}

			if (VDOM$2.DOM.createPortal) return VDOM$2.DOM.createPortal(this.renderOverlay(), this.containerEl); //rendered in componentDidUpdate if portals are not supported

			return null;
		};

		_proto3.renderOverlay = function renderOverlay() {
			var _this4 = this;

			var _this$props$instance = this.props.instance,
				widget = _this$props$instance.widget,
				data = _this$props$instance.data;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			if (!this.onOverlayRef)
				this.onOverlayRef = function(el) {
					_this4.el = el;
				};
			var content = VDOM$2.createElement(
				OverlayContent,
				{
					onRef: this.onOverlayRef,
					className: data.classNames,
					style: data.style,
					tabIndex: widget.focusable ? 0 : null,
					onFocus: this.onFocus.bind(this),
					onBlur: this.onBlur.bind(this),
					onKeyDown: this.onKeyDown.bind(this),
					onMouseDown: this.onMouseDown.bind(this),
					onMouseUp: this.onMouseUp.bind(this),
					onMouseMove: this.onMouseMove.bind(this),
					onTouchStart: this.onMouseDown.bind(this),
					onTouchEnd: this.onMouseUp.bind(this),
					onTouchMove: this.onMouseMove.bind(this),
					onMouseLeave: this.onMouseLeave.bind(this),
					onMouseEnter: this.onMouseEnter.bind(this),
					onClick: this.onClick.bind(this),
					onDidUpdate: this.overlayDidUpdate.bind(this)
				},
				widget.modal ||
					(widget.backdrop &&
						VDOM$2.createElement("div", {
							key: "backdrop",
							className: CSS.element(baseClass, "modal-backdrop"),
							onClick: this.onBackdropClick.bind(this)
						})),
				this.renderOverlayBody()
			);
			var result = content;

			if (widget.modal || widget.backdrop) {
				result = VDOM$2.createElement(
					"div",
					{
						key: "shadow",
						ref: function ref(el) {
							_this4.shadowEl = el;
						},
						className: CSS.element(baseClass, "shadow", {
							animated: this.state.animated,
							"animate-enter": this.state.animated && !this.dismissed,
							animate: widget.animate
						}),
						style: parseStyle(data.shadowStyle)
					},
					content
				);
			}

			return result;
		};

		_proto3.renderOverlayBody = function renderOverlayBody() {
			return this.props.children;
		};

		_proto3.onFocus = function onFocus() {
			FocusManager.nudge();
			this.onFocusIn();
			if (this.el) oneFocusOut(this, this.el, this.onFocusOut.bind(this));
		};

		_proto3.onBlur = function onBlur() {
			FocusManager.nudge();
		};

		_proto3.onFocusIn = function onFocusIn() {};

		_proto3.onFocusOut = function onFocusOut() {
			var widget = this.props.instance.widget;
			widget.handleFocusOut(this.props.instance, this);
		};

		_proto3.onMouseEnter = function onMouseEnter(e) {
			var widget = this.props.instance.widget;
			widget.handleMouseEnter(this.props.instance, this);
		};

		_proto3.onMouseLeave = function onMouseLeave(e) {
			var widget = this.props.instance.widget;
			widget.handleMouseLeave(this.props.instance, this);
		};

		_proto3.onClick = function onClick(e) {
			var instance = this.props.instance;
			var widget = instance.widget;
			if (widget.onClick) instance.invoke("onClick", e, instance, this);
		};

		_proto3.onKeyDown = function onKeyDown(e) {
			var widget = this.props.instance.widget;
			widget.handleKeyDown(e, this.props.instance, this);
		};

		_proto3.getResizePrefix = function getResizePrefix(e) {
			var _this$props$instance2 = this.props.instance,
				widget = _this$props$instance2.widget,
				data = _this$props$instance2.data;
			if (!data.resizable) return "";
			var cursor = this.getCursorPos(e);
			var bounds = getTopLevelBoundingClientRect(this.el);
			var leftMargin = cursor.clientX - bounds.left;
			var rightMargin = bounds.right - cursor.clientX;
			var topMargin = cursor.clientY - bounds.top;
			var bottomMargin = bounds.bottom - cursor.clientY;
			var prefix = "";
			if (topMargin >= 0 && topMargin < widget.resizeWidth) prefix += "n";
			else if (bottomMargin >= 0 && bottomMargin < widget.resizeWidth) prefix += "s";
			if (leftMargin >= 0 && leftMargin < widget.resizeWidth) prefix += "w";
			else if (rightMargin >= 0 && rightMargin < widget.resizeWidth) prefix += "e";
			return prefix;
		};

		_proto3.onMouseDown = function onMouseDown(e) {
			var data = this.props.instance.data;
			var prefix = this.getResizePrefix(e);

			if (prefix) {
				//e.preventDefault();
				var rect = getTopLevelBoundingClientRect(this.el);
				var cursor = this.getCursorPos(e);
				var captureData = {
					prefix: prefix,
					dl: cursor.clientX - rect.left,
					dt: cursor.clientY - rect.top,
					dr: cursor.clientX - rect.right,
					db: cursor.clientY - rect.bottom,
					rect: rect
				};
				captureMouseOrTouch(e, this.onMouseMove.bind(this), null, captureData, prefix + "-resize");
			} else if (data.draggable) {
				ddMouseDown(e);
			}

			e.stopPropagation();
		};

		_proto3.onBackdropClick = function onBackdropClick(e) {
			e.stopPropagation();
			var instance = this.props.instance;
			var widget = instance.widget;
			if (widget.onBackdropClick) instance.invoke("onBackdropClick", e, instance);

			if (widget.backdrop) {
				if (instance.dismiss) instance.dismiss();
			}
		};

		_proto3.onMouseUp = function onMouseUp(e) {
			ddMouseUp();
			e.stopPropagation();
		};

		_proto3.onMouseMove = function onMouseMove(e, captureData) {
			// handle dragging
			var instance = this.props.instance;
			var data = instance.data,
				widget = instance.widget;
			var detect = ddDetect(e);

			if (data.draggable && detect) {
				this.startMoveOperation(e);
				return;
			}

			if (captureData && captureData.prefix) {
				var prefix = captureData.prefix,
					rect = captureData.rect,
					dl = captureData.dl,
					dt = captureData.dt,
					dr = captureData.dr,
					db = captureData.db;
				var cursor = this.getCursorPos(e);
				if (prefix.indexOf("w") != -1)
					this.setCustomStyle({
						left: cursor.clientX - dl + "px",
						width: rect.right - cursor.clientX + dl + "px",
						right: "auto"
					});
				if (prefix.indexOf("n") != -1)
					this.setCustomStyle({
						top: cursor.clientY - dt + "px",
						height: rect.bottom - cursor.clientY + dt + "px",
						bottom: "auto"
					});
				if (prefix.indexOf("e") != -1)
					this.setCustomStyle({
						width: cursor.clientX - dr - rect.left + "px",
						left: rect.left + "px",
						right: "auto"
					});
				if (prefix.indexOf("s") != -1)
					this.setCustomStyle({
						height: cursor.clientY - db - rect.top + "px",
						top: rect.top + "px",
						bottom: "auto"
					});
				if (prefix.indexOf("w") >= 0 || prefix.indexOf("n") >= 0) widget.handleMove(e, instance, this);
				widget.handleResize(e, instance, this);
			} else {
				var _prefix = this.getResizePrefix(e);

				this.setCustomStyle({
					cursor: _prefix ? _prefix + "-resize" : null
				});
			}
		};

		_proto3.getCursorPos = function getCursorPos$$1(e) {
			var x = (e.touches && e.touches[0]) || e;
			return {
				clientX: x.clientX,
				clientY: x.clientY
			};
		};

		_proto3.startMoveOperation = function startMoveOperation(e) {
			if (this.el && !this.getResizePrefix(e)) {
				e.stopPropagation();
				var rect = getTopLevelBoundingClientRect(this.el);
				var cursor = this.getCursorPos(e);
				var data = {
					dx: cursor.clientX - rect.left,
					dy: cursor.clientY - rect.top
				};
				captureMouseOrTouch(e, this.onMove.bind(this), null, data, getComputedStyle(e.target).cursor);
			}
		};

		_proto3.onMove = function onMove(e, data) {
			if (data) {
				var cursor = this.getCursorPos(e);
				e.preventDefault();
				this.setCustomStyle({
					left: cursor.clientX - data.dx + "px",
					top: cursor.clientY - data.dy + "px",
					right: "auto",
					bottom: "auto"
				});
				var instance = this.props.instance;
				var widget = instance.widget;
				widget.handleMove(e, instance, this);
			}
		};

		_proto3.onBeforeDismiss = function onBeforeDismiss() {
			var instance = this.props.instance;
			var widget = instance.widget;
			if (widget.overlayWillDismiss && widget.overlayWillDismiss(instance, this) === false) return false;
			this.dismissed = true; //this.el might be null if visible is set to false

			if (this.el) {
				this.el.className = this.getOverlayCssClass(); // if (widget.animate)
				//    this.setState({
				//       animated: false
				//    });
			}

			return true;
		};

		_proto3.componentDidMount = function componentDidMount() {
			var _this5 = this;

			var _this$props2 = this.props,
				instance = _this$props2.instance,
				subscribeToBeforeDismiss = _this$props2.subscribeToBeforeDismiss,
				parentEl = _this$props2.parentEl;
			var widget = instance.widget;
			this.setZIndex(ZIndexManager.next());
			this.componentDidUpdate();
			widget.overlayDidMount(instance, this);
			if (this.containerEl) this.containerEl.style.display = null;
			else if (parentEl) parentEl.style.display = null;
			var childHasFocus = isSelfOrDescendant(this.el, document.activeElement);
			if (childHasFocus) oneFocusOut(this, this.el, this.onFocusOut.bind(this));
			else {
				if (!widget.autoFocusFirstChild || !FocusManager.focusFirstChild(this.el))
					if (widget.focusable && widget.autoFocus) FocusManager.focus(this.el);
			}
			instance.onBeforeDismiss = this.onBeforeDismiss.bind(this);

			if (subscribeToBeforeDismiss) {
				subscribeToBeforeDismiss(instance.onBeforeDismiss);
			}

			if (widget.animate) {
				setTimeout(function() {
					if (!_this5.unmounting)
						_this5.setState({
							animated: true
						});
				}, 0);
			}

			if (widget.dismissOnPopState) {
				this.onPopState = function() {
					_this5.props.instance.dismiss();
				};

				window.addEventListener("popstate", this.onPopState);
			}
		};

		_proto3.componentWillUnmount = function componentWillUnmount() {
			var _this6 = this;

			if (this.onPopState) window.removeEventListener("popstate", this.onPopState);
			offFocusOut(this);
			this.unmounting = true;
			var widget = this.props.instance.widget;
			var baseClass = widget.baseClass,
				CSS = widget.CSS; // //we didn't have a chance to call onBeforeDismiss

			if (this.state.animated && this.el) {
				this.el.className = this.getOverlayCssClass();
				if (this.shadowEl)
					this.shadowEl.className = CSS.element(baseClass, "shadow", {
						animate: widget.animate,
						"animate-leave": true
					});
			}

			widget.overlayWillUnmount(this.props.instance, this);

			if (this.ownedEl) {
				setTimeout(function() {
					if (_this6.ownedEl.parentNode) _this6.ownedEl.parentNode.removeChild(_this6.ownedEl);
					_this6.ownedEl = null;
				}, widget.destroyDelay);
			}

			delete this.containerEl;
		};

		_proto3.setZIndex = function setZIndex(zIndex) {
			if (this.shadowEl) this.shadowEl.style.zIndex = zIndex;
			this.setCustomStyle({
				zIndex: zIndex
			});
		};

		_proto3.setCustomStyle = function setCustomStyle(style) {
			Object.assign(this.customStyle, style);
			if (this.el) Object.assign(this.el.style, this.customStyle);
		};

		_proto3.getOverlayStyle = function getOverlayStyle() {
			var data = this.props.instance.data;
			return _objectSpread({}, data.style, this.customStyle);
		};

		_proto3.setCSSState = function setCSSState(mods) {
			var m = _objectSpread({}, this.state.mods);

			var changed = false;

			for (var k in mods) {
				if (m[k] !== mods[k]) {
					m[k] = mods[k];
					changed = true;
				}
			}

			if (changed)
				this.setState({
					mods: mods
				});
		};

		_proto3.getOverlayCssClass = function getOverlayCssClass() {
			var _this$props$instance3 = this.props.instance,
				data = _this$props$instance3.data,
				widget = _this$props$instance3.widget;
			var CSS = widget.CSS;
			return CSS.expand(
				data.classNames,
				CSS.state(
					_objectSpread({}, this.state.mods, {
						animated: this.state.animated && !this.unmounting && !this.dismissed,
						"animate-enter": this.state.animated && !this.dismissed,
						"animate-leave": widget.animate && this.dismissed
					})
				)
			);
		};

		_proto3.overlayDidUpdate = function overlayDidUpdate() {
			if (this.el && !this.dismissed) {
				var widget = this.props.instance.widget;
				widget.overlayDidUpdate(this.props.instance, this);
				this.el.className = this.getOverlayCssClass();
				Object.assign(this.el.style, this.getOverlayStyle());
			}
		};

		_proto3.componentDidUpdate = function componentDidUpdate() {
			if (this.containerEl && !VDOM$2.DOM.createPortal) {
				VDOM$2.DOM.render(this.renderOverlay(), this.containerEl);
			}

			this.overlayDidUpdate();
		};

		return OverlayComponent;
	})(VDOM$2.Component);

var subscribers$1 = new SubscriberList();
var ResizeManager =
	/*#__PURE__*/
	(function() {
		function ResizeManager() {}

		ResizeManager.subscribe = function subscribe(callback) {
			return subscribers$1.subscribe(callback);
		};

		ResizeManager.notify = function notify() {
			batchUpdates(function() {
				subscribers$1.notify();
			});
		};

		ResizeManager.trackElement = function trackElement(el, callback) {
			if (typeof ResizeObserver !== "function") return this.subscribe(callback);
			var obs = new ResizeObserver(callback);
			obs.observe(el);
			return function() {
				obs.disconnect();
			};
		};

		return ResizeManager;
	})();
if (typeof window != "undefined")
	window.addEventListener("resize", function() {
		return ResizeManager.notify();
	});

var contents = {};
var localizations = {};
var overrides = {};
var defaults = {};
var _trackDefaults = false;
var Localization =
	/*#__PURE__*/
	(function() {
		function Localization() {}

		Localization.register = function register(key) {
			var _this = this;

			return function(type) {
				_this.registerPrototype(key, type);

				return type;
			};
		};

		Localization.registerPrototype = function registerPrototype(key, type) {
			contents[key] = type.prototype;
			if (overrides[key]) this.override(key, overrides[key]);
		};

		Localization.trackDefaults = function trackDefaults() {
			_trackDefaults = true;
		};

		Localization.restoreDefaults = function restoreDefaults() {
			for (var type in defaults) {
				var proto = contents[type];
				if (!proto) continue;
				var d = defaults[type];

				for (var key in d) {
					proto[key] = d[key];
				}
			}

			defaults = {};
		};

		Localization.override = function override(key, values) {
			overrides[key] = values;
			var p = contents[key];

			if (p) {
				if (_trackDefaults && !defaults[key]) {
					var d = (defaults[key] = {});

					for (var _key in values) {
						d[_key] = p[_key];
					}
				}

				Object.assign(p, values);
			}
		};

		Localization.localize = function localize(culture, key, values) {
			var l = localizations[culture];
			if (!l) l = localizations[culture] = {};
			l[key] = _objectSpread({}, l[key], values);
		};

		Localization.setCulture = function setCulture(culture) {
			var l = localizations[culture];

			if (l) {
				for (var key in l) {
					var content = contents[key];
					if (content) Object.assign(content, l[key]);
				}
			}
		};

		return Localization;
	})();

/*
 Dropdown specific features:
 - ability to position itself next to parent element
 - monitor scrollable parents and updates it's position
 */

var Dropdown =
	/*#__PURE__*/
	(function(_Overlay) {
		_inheritsLoose(Dropdown, _Overlay);

		function Dropdown() {
			return _Overlay.apply(this, arguments) || this;
		}

		var _proto = Dropdown.prototype;

		_proto.init = function init() {
			if (this.trackMouse) {
				this.trackMouseX = true;
				this.trackMouseY = true;
			}

			_Overlay.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Overlay$prototype$de;

			return (_Overlay$prototype$de = _Overlay.prototype.declareData).call.apply(
				_Overlay$prototype$de,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						placement: undefined
					}
				])
			);
		};

		_proto.initInstance = function initInstance(context, instance) {
			instance.positionChangeSubcribers = new SubscriberList();
			instance.mousePosition = this.mousePosition;

			_Overlay.prototype.initInstance.call(this, context, instance);
		};

		_proto.explore = function explore(context, instance) {
			context.push("parentPositionChangeEvent", instance.positionChangeSubcribers);
			context.push("lastDropdown", instance);

			_Overlay.prototype.explore.call(this, context, instance);
		};

		_proto.exploreCleanup = function exploreCleanup(context, instance) {
			context.pop("parentPositionChangeEvent");
			context.pop("lastDropdown");
		};

		_proto.overlayDidMount = function overlayDidMount(instance, component) {
			var _this = this;

			_Overlay.prototype.overlayDidMount.call(this, instance, component);

			var scrollableParents = (component.scrollableParents = [window]);

			component.updateDropdownPosition = function(e) {
				return _this.updateDropdownPosition(instance, component);
			};

			var el = this.relatedElement.parentElement;

			while (el) {
				scrollableParents.push(el);
				el = el.parentElement;
			}

			scrollableParents.forEach(function(el) {
				el.addEventListener("scroll", component.updateDropdownPosition);
			});
			component.offResize = ResizeManager.subscribe(component.updateDropdownPosition);
			if (this.onDropdownDidMount) instance.invoke("onDropdownDidMount", instance, component);
			if (this.pipeValidateDropdownPosition)
				instance.invoke("pipeValidateDropdownPosition", component.updateDropdownPosition, instance);
			if (this.parentPositionChangeEvent)
				component.offParentPositionChange = this.parentPositionChangeEvent.subscribe(component.updateDropdownPosition);
		};

		_proto.overlayDidUpdate = function overlayDidUpdate(instance, component) {
			this.updateDropdownPosition(instance, component);
		};

		_proto.overlayWillUnmount = function overlayWillUnmount(instance, component) {
			var scrollableParents = component.scrollableParents;

			if (scrollableParents) {
				scrollableParents.forEach(function(el) {
					el.removeEventListener("scroll", component.updateDropdownPosition);
				});
				delete component.scrollableParents;
				delete component.updateDropdownPosition;
			}

			if (component.offResize) component.offResize();
			if (this.pipeValidateDropdownPosition) instance.invoke("pipeValidateDropdownPosition", null, instance);
			if (component.offParentPositionChange) component.offParentPositionChange();
			delete component.parentBounds;
		};

		_proto.updateDropdownPosition = function updateDropdownPosition(instance, component) {
			var el = component.el;
			var data = instance.data;
			var parentBounds = (component.parentBounds = getTopLevelBoundingClientRect(this.relatedElement)); //getBoundingClientRect() will return an empty rect if the element is hidden or removed

			if (parentBounds.left == 0 && parentBounds.top == 0 && parentBounds.bottom == 0 && parentBounds.right == 0)
				return;

			if (this.trackMouseX && instance.mousePosition) {
				parentBounds = {
					top: parentBounds.top,
					bottom: parentBounds.bottom,
					left: instance.mousePosition.x,
					right: instance.mousePosition.x
				};
			}

			if (this.trackMouseY && instance.mousePosition) {
				parentBounds = {
					left: parentBounds.left,
					right: parentBounds.right,
					top: instance.mousePosition.y,
					bottom: instance.mousePosition.y
				};
			}

			var explode = this.pad && typeof this.elementExplode === "number" ? this.elementExplode : 0;

			if (explode) {
				parentBounds = {
					left: Math.round(parentBounds.left - explode),
					right: Math.round(parentBounds.right + explode),
					top: Math.round(parentBounds.top - explode),
					bottom: Math.round(parentBounds.bottom + explode)
				};
			}

			var style = {};
			if (this.matchWidth) style.minWidth = parentBounds.right - parentBounds.left + "px";
			var contentSize = this.measureNaturalDropdownSize(instance, component);
			var placement = this.findOptimalPlacement(contentSize, parentBounds, data.placement, component.lastPlacement);

			switch (this.positioning) {
				case "absolute":
					this.applyAbsolutePositioningPlacementStyles(style, placement, contentSize, parentBounds, el);
					break;

				case "auto":
					if (isTouchDevice())
						this.applyAbsolutePositioningPlacementStyles(style, placement, contentSize, parentBounds, el);
					else this.applyFixedPositioningPlacementStyles(style, placement, contentSize, parentBounds, el);
					break;

				default:
					this.applyFixedPositioningPlacementStyles(style, placement, contentSize, parentBounds, el);
					break;
			}

			component.setCustomStyle(style);
			this.setDirectionClass(component, placement);
			if (this.onDropdownPositionDidUpdate) instance.invoke("onDropdownPositionDidUpdate", instance, component);
			instance.positionChangeSubcribers.notify();
		};

		_proto.applyFixedPositioningPlacementStyles = function applyFixedPositioningPlacementStyles(
			style,
			placement,
			contentSize,
			rel,
			el
		) {
			var viewport = getViewportRect(this.screenPadding);
			var pad = this.screenPadding + "px";
			style.position = "fixed";

			switch (placement) {
				case "down":
				case "down-center":
					style.top = (this.cover ? rel.top : rel.bottom) + this.offset + "px";
					style.right = "auto";
					style.bottom =
						this.constrain && rel.bottom + this.offset + contentSize.height > viewport.bottom ? pad : "auto";
					style.left = Math.round((rel.left + rel.right - el.offsetWidth) / 2) + "px";
					break;

				case "down-right":
					style.top = (this.cover ? rel.top : rel.bottom) + this.offset + "px";
					style.right = "auto";
					style.left = rel.left + "px";
					style.bottom =
						this.constrain && rel.bottom + this.offset + contentSize.height > viewport.bottom ? pad : "auto";
					break;

				case "down-left":
					style.top = (this.cover ? rel.top : rel.bottom) + this.offset + "px";
					style.right = document.documentElement.offsetWidth - rel.right + "px";
					style.bottom =
						this.constrain && rel.bottom + this.offset + contentSize.height > viewport.bottom ? pad : "auto";
					style.left = "auto";
					break;

				case "up":
				case "up-center":
					style.top = this.constrain && rel.top - this.offset - contentSize.height < viewport.top ? pad : "auto";
					style.right = "auto";
					style.bottom =
						document.documentElement.offsetHeight - (this.cover ? rel.bottom : rel.top) + this.offset + "px";
					style.left = Math.round((rel.left + rel.right - el.offsetWidth) / 2) + "px";
					break;

				case "up-right":
					style.top = this.constrain && rel.top - this.offset - contentSize.height < viewport.top ? pad : "auto";
					style.right = "auto";
					style.bottom =
						document.documentElement.offsetHeight - (this.cover ? rel.bottom : rel.top) + this.offset + "px";
					style.left = rel.left + "px";
					break;

				case "up-left":
					style.top = this.constrain && rel.top - this.offset - contentSize.height < viewport.top ? pad : "auto";
					style.right = document.documentElement.offsetWidth - rel.right + "px";
					style.bottom =
						document.documentElement.offsetHeight - (this.cover ? rel.bottom : rel.top) + this.offset + "px";
					style.left = "auto";
					break;

				case "right":
				case "right-center":
					style.top = Math.round((rel.top + rel.bottom - el.offsetHeight) / 2) + "px";
					style.right = "auto";
					style.bottom = "auto";
					style.left = rel.right + this.offset + "px";
					break;

				case "right-down":
					style.top = rel.top + "px";
					style.right = "auto";
					style.bottom = "auto";
					style.left = rel.right + this.offset + "px";
					break;

				case "right-up":
					style.top = "auto";
					style.right = "auto";
					style.bottom = document.documentElement.offsetHeight - rel.bottom + "px";
					style.left = rel.right + this.offset + "px";
					break;

				case "left":
				case "left-center":
					style.top = Math.round((rel.top + rel.bottom - el.offsetHeight) / 2) + "px";
					style.right = document.documentElement.offsetWidth - rel.left + this.offset + "px";
					style.bottom = "auto";
					style.left = "auto";
					break;

				case "left-down":
					style.top = rel.top + "px";
					style.right = document.documentElement.offsetWidth - rel.left + this.offset + "px";
					style.bottom = "auto";
					style.left = "auto";
					break;

				case "left-up":
					style.top = "auto";
					style.right = document.documentElement.offsetWidth - rel.left + this.offset + "px";
					style.bottom = document.documentElement.offsetHeight - rel.bottom + "px";
					style.left = "auto";
					break;

				case "screen-center":
					var w = Math.min(contentSize.width, document.documentElement.offsetWidth - 2 * this.screenPadding);
					var h = Math.min(contentSize.height, document.documentElement.offsetHeight - 2 * this.screenPadding);
					style.top = Math.round((document.documentElement.offsetHeight - h) / 2) + "px";
					style.right = Math.round((document.documentElement.offsetWidth - w) / 2) + "px";
					style.bottom = Math.round((document.documentElement.offsetHeight - h) / 2) + "px";
					style.left = Math.round((document.documentElement.offsetWidth - w) / 2) + "px";
					break;
			}
		};

		_proto.applyAbsolutePositioningPlacementStyles = function applyAbsolutePositioningPlacementStyles(
			style,
			placement,
			contentSize,
			rel,
			el
		) {
			var viewport = getViewportRect(this.screenPadding);
			style.position = "absolute";

			switch (placement) {
				case "down":
				case "down-center":
					style.top = rel.bottom - rel.top + this.offset + "px";
					style.right = "auto";
					style.bottom =
						this.constrain && rel.bottom + this.offset + contentSize.height > viewport.bottom
							? rel.bottom + this.offset - viewport.bottom + "px"
							: "auto";
					style.left = Math.round((rel.right - rel.left - el.offsetWidth) / 2) + "px";
					break;

				case "down-right":
					style.top = rel.bottom - rel.top + this.offset + "px";
					style.right = "auto";
					style.left = "0";
					style.bottom =
						this.constrain && rel.bottom + this.offset + contentSize.height > viewport.bottom
							? rel.bottom + this.offset - viewport.bottom + "px"
							: "auto";
					break;

				case "down-left":
					style.top = rel.bottom - rel.top + this.offset + "px";
					style.right = "0";
					style.bottom =
						this.constrain && rel.bottom + this.offset + contentSize.height > viewport.bottom
							? rel.bottom + this.offset - viewport.bottom + "px"
							: "auto";
					style.left = "auto";
					break;

				case "up":
				case "up-center":
					style.top =
						this.constrain && rel.top - this.offset - contentSize.height < viewport.top
							? this.offset - rel.top + viewport.top + "px"
							: "auto";
					style.right = "auto";
					style.bottom = rel.bottom - rel.top - this.offset + "px";
					style.left = Math.round((rel.right - rel.left - el.offsetWidth) / 2) + "px";
					break;

				case "up-right":
					style.top =
						this.constrain && rel.top - this.offset - contentSize.height < viewport.top
							? this.offset - rel.top + viewport.top + "px"
							: "auto";
					style.right = "auto";
					style.bottom = rel.bottom - rel.top - this.offset + "px";
					style.left = "0";
					break;

				case "up-left":
					style.top =
						this.constrain && rel.top - this.offset - contentSize.height < viewport.top
							? this.offset - rel.top + viewport.top + "px"
							: "auto";
					style.right = "0";
					style.bottom = rel.bottom - rel.top - this.offset + "px";
					style.left = "auto";
					break;

				case "right":
				case "right-center":
					style.top = Math.round((rel.bottom - rel.top - el.offsetHeight) / 2) + "px";
					style.right = "auto";
					style.bottom = "auto";
					style.left = rel.right - rel.left + this.offset + "px";
					break;

				case "right-down":
					style.top = "0";
					style.right = "auto";
					style.bottom = "auto";
					style.left = rel.right - rel.left + this.offset + "px";
					break;

				case "right-up":
					style.top = "auto";
					style.right = "auto";
					style.bottom = "0";
					style.left = rel.right - rel.left + this.offset + "px";
					break;

				case "left":
				case "left-center":
					style.top = Math.round((rel.bottom - rel.top - el.offsetHeight) / 2) + "px";
					style.right = rel.right - rel.left + this.offset + "px";
					style.bottom = "auto";
					style.left = "auto";
					break;

				case "left-down":
					style.top = "0";
					style.right = rel.right - rel.left + this.offset + "px";
					style.bottom = "auto";
					style.left = "auto";
					break;

				case "left-up":
					style.top = "auto";
					style.right = rel.right - rel.left + this.offset + "px";
					style.bottom = "0";
					style.left = "auto";
					break;
			}
		};

		_proto.setDirectionClass = function setDirectionClass(component, placement) {
			var _objectSpread2;

			var state = {
				"place-left": false,
				"place-right": false,
				"place-up": false,
				"place-down": false
			};
			component.lastPlacement = placement;
			component.setCSSState(
				_objectSpread({}, state, ((_objectSpread2 = {}), (_objectSpread2["place-" + placement] = true), _objectSpread2))
			);
		};

		_proto.measureNaturalDropdownSize = function measureNaturalDropdownSize(instance, component) {
			var el = component.el;
			var size = {
				width: el.offsetWidth,
				height: el.offsetHeight
			};

			if (this.firstChildDefinesHeight && el.firstChild) {
				size.height = el.firstChild.offsetHeight;
			}

			if (this.firstChildDefinesWidth && el.firstChild) {
				size.width = el.firstChild.offsetWidth;
			}

			if (this.onMeasureDropdownNaturalSize) {
				var more = instance.invoke("onMeasureDropdownNaturalSize", instance, component);
				Object.assign(size, more);
			}

			return size;
		};

		_proto.findOptimalPlacement = function findOptimalPlacement(contentSize, target, placement, lastPlacement) {
			var placementOrder = this.placementOrder.split(" ");
			var best = lastPlacement || placement;
			var first;
			var score = {};
			var viewport = getViewportRect();

			for (var i = 0; i < placementOrder.length; i++) {
				var p = placementOrder[i];
				if (!first) first = p;
				var parts = p.split("-");
				var primary = parts[0];
				var secondary = parts[1] || "center";
				score[p] = 0;
				var vertical = true;

				switch (primary) {
					case "down":
						score[p] += 3 * Math.min(1, (viewport.bottom - target.bottom - this.offset) / contentSize.height);
						break;

					case "up":
						score[p] += 3 * Math.min(1, (target.top - viewport.top - this.offset) / contentSize.height);
						break;

					case "right":
						score[p] += target.right + contentSize.width + this.offset < viewport.right ? 3 : 0;
						vertical = false;
						break;

					case "left":
						score[p] += target.left - contentSize.width - this.offset >= viewport.left ? 3 : 0;
						vertical = false;
						break;
				}

				switch (secondary) {
					case "center":
						if (vertical) {
							score[p] += (target.right + target.left - contentSize.width) / 2 >= viewport.left ? 1 : 0;
							score[p] += (target.right + target.left + contentSize.width) / 2 < viewport.right ? 1 : 0;
						} else {
							score[p] += (target.bottom + target.top - contentSize.height) / 2 >= viewport.top ? 1 : 0;
							score[p] += (target.bottom + target.top + contentSize.height) / 2 < viewport.bottom ? 1 : 0;
						}

						break;

					case "right":
						score[p] += target.left + contentSize.width < viewport.right ? 2 : 0;
						break;

					case "left":
						score[p] += target.right - contentSize.width >= viewport.left ? 2 : 0;
						break;

					case "up":
						score[p] += target.bottom - contentSize.height >= viewport.top ? 2 : 0;
						break;

					case "down":
						score[p] += target.top + contentSize.height < viewport.bottom ? 2 : 0;
						break;
				}
			}

			if (!(best in score)) best = first;

			for (var k in score) {
				if (score[k] > score[best]) best = k;
			}

			if (this.touchFriendly && isTouchDevice() && score[best] < 5) return "screen-center";
			return best;
		};

		_proto.handleKeyDown = function handleKeyDown(e, instance) {
			switch (e.keyCode) {
				case 27:
					//esc
					var focusable = findFirst(this.relatedElement, isFocusable);
					if (focusable) focusable.focus();
					e.stopPropagation();
					e.preventDefault();
					break;
			}

			if (this.onKeyDown) instance.invoke("onKeyDown", e, instance);
		};

		_proto.renderContents = function renderContents(context, instance) {
			var CSS = this.CSS,
				baseClass = this.baseClass;
			if (!this.arrow) return _Overlay.prototype.renderContents.call(this, context, instance);
			var result = [].concat(_Overlay.prototype.renderContents.call(this, context, instance));
			result.push(
				VDOM$2.createElement("div", {
					key: "arrow-border",
					className: CSS.element(baseClass, "arrow-border")
				}),
				VDOM$2.createElement("div", {
					key: "arrow-back",
					className: CSS.element(baseClass, "arrow-fill")
				})
			);
			return result;
		};

		return Dropdown;
	})(Overlay);
Dropdown.prototype.offset = 0;
Dropdown.prototype.baseClass = "dropdown";
Dropdown.prototype.matchWidth = true;
Dropdown.prototype.placementOrder = "up down right left";
Dropdown.prototype.placement = null; //default placement

Dropdown.prototype.constrain = false;
Dropdown.prototype.positioning = "fixed";
Dropdown.prototype.touchFriendly = false;
Dropdown.prototype.arrow = false;
Dropdown.prototype.pad = false;
Dropdown.prototype.elementExplode = 0;
Dropdown.prototype.screenPadding = 5;
Dropdown.prototype.firstChildDefinesHeight = false;
Dropdown.prototype.firstChildDefinesWidth = false;
Dropdown.prototype.cover = false;
Widget.alias("dropdown", Dropdown);
Localization.registerPrototype("cx/widgets/Dropdown", Dropdown);

function getViewportRect(padding) {
	if (padding === void 0) {
		padding = 0;
	}

	return {
		left: padding,
		top: padding,
		right: document.documentElement.offsetWidth - padding,
		bottom: document.documentElement.offsetHeight - padding
	};
}

var Tooltip =
	/*#__PURE__*/
	(function(_Dropdown) {
		_inheritsLoose(Tooltip, _Dropdown);

		function Tooltip() {
			return _Dropdown.apply(this, arguments) || this;
		}

		var _proto = Tooltip.prototype;

		_proto.declareData = function declareData() {
			var _Dropdown$prototype$d;

			(_Dropdown$prototype$d = _Dropdown.prototype.declareData).call.apply(
				_Dropdown$prototype$d,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						text: undefined,
						title: undefined,
						alwaysVisible: undefined
					}
				])
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			data.stateMods = _objectSpread({}, data.stateMods, {
				"mouse-trap": this.mouseTrap
			});

			_Dropdown.prototype.prepareData.call(this, context, instance);
		};

		_proto.renderContents = function renderContents(context, instance) {
			var data = instance.data;
			var CSS = this.CSS,
				baseClass = this.baseClass;
			return [
				data.title &&
					VDOM$2.createElement(
						"div",
						{
							key: "title",
							className: CSS.element(baseClass, "title")
						},
						data.title
					),
				data.text
			].concat(_Dropdown.prototype.renderContents.call(this, context, instance));
		};

		_proto.initInstance = function initInstance(context, instance) {
			var _this = this;

			_Dropdown.prototype.initInstance.call(this, context, instance);

			if (this.trackMouseX || this.trackMouseY) {
				instance.trackMouse = function(e) {
					var pos = getCursorPos(e);
					instance.mousePosition = {
						x: pos.clientX,
						y: pos.clientY
					};
					if (instance.tooltipComponent) _this.updateDropdownPosition(instance, instance.tooltipComponent);
				};
			}
		};

		_proto.overlayDidMount = function overlayDidMount(instance, component) {
			var _this2 = this;

			instance.tooltipComponent = component;

			_Dropdown.prototype.overlayDidMount.call(this, instance, component);

			instance.parentValidityCheckTimer = setInterval(function() {
				if (!_this2.relatedElement.ownerDocument.body.contains(_this2.relatedElement)) {
					if (instance.dismissTooltip) {
						instance.dismissTooltip();
						instance.dismissTooltip = null;
					}
				} else {
					if (instance.tooltipComponent) _this2.updateDropdownPosition(instance, instance.tooltipComponent);
				}
			}, 500);

			if (instance.widget.globalMouseTracking && instance.trackMouse) {
				document.addEventListener("mousemove", instance.trackMouse);
			}
		};

		_proto.overlayWillUnmount = function overlayWillUnmount(instance, component) {
			clearInterval(instance.parentValidityCheckTimer);

			_Dropdown.prototype.overlayWillUnmount.call(this, instance, component);

			instance.tooltipComponent = null;

			if (instance.widget.globalMouseTracking && instance.trackMouse) {
				document.removeEventListener("mousemove", instance.trackMouse);
			}
		};

		_proto.handleMouseEnter = function handleMouseEnter(instance, component) {
			instance.mouseOverTooltip = true;

			_Dropdown.prototype.handleMouseEnter.call(this, instance, component);
		};

		_proto.handleMouseLeave = function handleMouseLeave(instance, component) {
			instance.mouseOverTooltip = false;
			if (this.mouseTrap) this.handleMouseLeavesParent(instance);

			_Dropdown.prototype.handleMouseLeave.call(this, instance, component);
		};

		_proto.handleMouseLeavesParent = function handleMouseLeavesParent(instance) {
			var _this3 = this;

			var timeout = this.mouseTrap ? 200 : 0;
			setTimeout(function() {
				if (!instance.mouseOverTarget && !(_this3.mouseTrap && instance.mouseOverTooltip))
					_this3.dismissTooltip(instance);
			}, timeout);
		};

		_proto.dismissTooltip = function dismissTooltip(instance) {
			if (instance && instance.dismissTooltip) {
				if (
					instance.data &&
					instance.data.alwaysVisible &&
					this.relatedElement.ownerDocument.body.contains(this.relatedElement)
				)
					return;
				instance.dismissTooltip();
				instance.dismissTooltip = null;
			}
		};

		return Tooltip;
	})(Dropdown);
Widget.alias("tooltip", Tooltip);
Tooltip.prototype.baseClass = "tooltip";
Tooltip.prototype.offset = 8;
Tooltip.prototype.placementOrder =
	"right up down left up-right up-left right-up right-down down-right down-left left-up left-down";
Tooltip.prototype.animate = true;
Tooltip.prototype.destroyDelay = 300;
Tooltip.prototype.createDelay = 200;
Tooltip.prototype.matchWidth = false;
Tooltip.prototype.trackMouse = false;
Tooltip.prototype.trackMouseX = false;
Tooltip.prototype.trackMouseY = false;
Tooltip.prototype.touchFriendly = false; //rename to positioningMode

Tooltip.prototype.touchBehavior = "toggle";
Tooltip.prototype.arrow = true;
Tooltip.prototype.alwaysVisible = false;
Tooltip.prototype.globalMouseTracking = false;
function getTooltipInstance(e, parentInstance, tooltip, options) {
	if (options === void 0) {
		options = {};
	}

	var target = options.target || (e && e.currentTarget) || e;
	debug(tooltipsFlag, "mouse-move", target, parentInstance);
	var name = options.tooltipName || "tooltip";
	if (!parentInstance.tooltips) parentInstance.tooltips = {};
	var tooltipInstance = parentInstance.tooltips[name];

	if (tooltipInstance && (tooltipInstance.widget.relatedElement != target || tooltipInstance.config != tooltip)) {
		if (tooltipInstance.dismissTooltip) tooltipInstance.dismissTooltip();
		delete parentInstance.tooltips[name];
		tooltipInstance = null;
	}

	if (!tooltip || !target) return;

	if (!tooltipInstance) {
		var config = tooltip;

		if (isSelector(tooltip)) {
			config = {
				text: tooltip
			};
		}

		var tooltipWidget = Tooltip.create(
			{
				relatedElement: target
			},
			config
		);
		var store = new ReadOnlyDataView({
			store: parentInstance.store
		});
		tooltipInstance = parentInstance.tooltips[name] = parentInstance.getDetachedChild(tooltipWidget, name, store);
		tooltipInstance.config = tooltip;

		if (tooltip.alwaysVisible || tooltip.trackMouse || tooltip.trackMouseX || tooltip.trackMouseY) {
			tooltipInstance.init();
			tooltipInstance.data = tooltipInstance.dataSelector(store);
		}
	}

	return tooltipInstance;
}

function tooltipMouseMove$1(e, parentInstance, tooltip, options) {
	if (options === void 0) {
		options = {};
	}

	var instance = getTooltipInstance(e, parentInstance, tooltip, options);
	if (!instance) return;
	if (isTouchEvent() && instance.widget.touchBehavior == "ignore") return false;
	var dirty = !shallowEquals(options.data, instance.store.data);
	instance.store.setData(options.data);
	instance.mouseOverTarget = true;

	if (!instance.dismissTooltip) {
		if (!instance.pending) {
			instance.pending = true;
			var parentDestroyed = false;
			var dismiss;
			var unsubscribeDismiss = instance.parent.subscribeOnDestroy(function() {
				parentDestroyed = true;
				if (dismiss) dismiss();
			});

			instance.dismissTooltip = function() {
				unsubscribeDismiss();
				if (dismiss) dismiss();
			};

			setTimeout(function() {
				instance.pending = false;
				var relatedElement = instance.widget.relatedElement;

				if (
					!parentDestroyed &&
					instance.mouseOverTarget &&
					relatedElement.ownerDocument.body.contains(relatedElement)
				) {
					dismiss = instance.widget.open(instance, {
						onPipeUpdate: function onPipeUpdate(cb) {
							instance.update = cb;
						}
					});
				}
			}, instance.widget.createDelay);
		}
	} else {
		if (isTouchEvent() && instance.widget.touchBehavior == "toggle") {
			instance.dismissTooltip();
			instance.dismissTooltip = null;
		} else if (dirty && instance.update) instance.update();
	}

	if (instance.trackMouse && e && e.target) instance.trackMouse(e);
}

function tooltipMouseLeave$1(e, parentInstance, tooltip, options) {
	var instance = getTooltipInstance(e, parentInstance, tooltip, options);

	if (instance) {
		instance.mouseOverTarget = false;
		instance.widget.handleMouseLeavesParent(instance);
	}
}

function tooltipParentDidMount$1(element, parentInstance, tooltip, options) {
	if (tooltip && tooltip.alwaysVisible) {
		var instance = getTooltipInstance(element, parentInstance, tooltip, options);
		if (instance && instance.data.alwaysVisible) tooltipMouseMove$1(element, parentInstance, tooltip, options);
	}
}

function tooltipParentWillReceiveProps$1(element, parentInstance, tooltip, options) {
	var instance = getTooltipInstance(element, parentInstance, tooltip, options);

	if (instance && options) {
		instance.store.setData(options.data);
		if (instance.update) instance.update();
		if (instance.mouseOverTarget || (instance.data && instance.data.alwaysVisible))
			tooltipMouseMove$1(element, parentInstance, tooltip, options);
	}
}

function tooltipParentWillUnmount$1(parentInstance) {
	if (parentInstance.tooltips) {
		for (var name in parentInstance.tooltips) {
			var instance = parentInstance.tooltips[name];
			instance.mouseOverTarget = false;
			if (instance.dismissTooltip) parentInstance.tooltips[name].dismissTooltip();
		}
	}
}

function enableTooltips() {
	wireTooltipOps({
		tooltipMouseMove: tooltipMouseMove$1,
		tooltipMouseLeave: tooltipMouseLeave$1,
		tooltipParentDidMount: tooltipParentDidMount$1,
		tooltipParentWillReceiveProps: tooltipParentWillReceiveProps$1,
		tooltipParentWillUnmount: tooltipParentWillUnmount$1
	});
}

var stopPropagation = function stopPropagation(e) {
	return e.stopPropagation();
};
var preventDefault = function preventDefault(e) {
	return e.preventDefault();
};

var Window =
	/*#__PURE__*/
	(function(_Overlay) {
		_inheritsLoose(Window, _Overlay);

		function Window() {
			return _Overlay.apply(this, arguments) || this;
		}

		var _proto = Window.prototype;

		_proto.init = function init() {
			if (isDefined(this.closeable)) this.closable = this.closeable;
			if (typeof this.headerStyle === "string") this.headerStyle = parseStyle(this.headerStyle);
			if (typeof this.footerStyle === "string") this.footerStyle = parseStyle(this.footerStyle);
			if (typeof this.bodyStyle === "string") this.bodyStyle = parseStyle(this.bodyStyle);

			_Overlay.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Overlay$prototype$de;

			return (_Overlay$prototype$de = _Overlay.prototype.declareData).call.apply(
				_Overlay$prototype$de,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						title: undefined,
						closable: undefined,
						bodyStyle: {
							structured: true
						},
						headerStyle: {
							structured: true
						},
						footerStyle: {
							structured: true
						}
					}
				])
			);
		};

		_proto.initHelpers = function initHelpers() {
			var _Overlay$prototype$in;

			return (_Overlay$prototype$in = _Overlay.prototype.initHelpers).call.apply(
				_Overlay$prototype$in,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						header: Widget.create(
							this.header || {
								type: ContentPlaceholder,
								name: "header",
								scoped: true
							}
						),
						footer: Widget.create(
							this.footer || {
								type: ContentPlaceholder,
								name: "footer",
								scoped: true
							}
						),
						close:
							this.closable &&
							Button.create({
								mod: "hollow",
								dismiss: true,
								icon: "close",
								style: "margin-left: auto",
								onTouchStart: stopPropagation,
								onMouseDown: stopPropagation
							})
					}
				])
			);
		};

		_proto.exploreCleanup = function exploreCleanup(context, instance) {
			_Overlay.prototype.exploreCleanup.call(this, context, instance);

			var helpers = instance.helpers;
			var unregisterHeader = helpers.header && helpers.header.unregisterContentPlaceholder;
			if (unregisterHeader) unregisterHeader();
			var unregisterFooter = helpers.footer && helpers.footer.unregisterContentPlaceholder;
			if (unregisterFooter) unregisterFooter();
		};

		_proto.renderHeader = function renderHeader(context, instance, key) {
			var data = instance.data;
			var result = [];
			if (data.title) result.push(data.title);

			if (instance.helpers) {
				var header = getContent(instance.helpers.header && instance.helpers.header.render(context, key));
				if (header) result.push(header);
				if (data.closable && instance.helpers.close) result.push(getContent(instance.helpers.close.render(context)));
			}

			return result;
		};

		_proto.renderFooter = function renderFooter(context, instance, key) {
			return getContent(instance.helpers && instance.helpers.footer && instance.helpers.footer.render(context, key));
		};

		_proto.render = function render(context, instance, key) {
			var header = this.renderHeader(context, instance, "header");
			var footer = this.renderFooter(context, instance, "footer");
			return VDOM$2.createElement(
				WindowComponent,
				{
					key: key,
					instance: instance,
					header: header,
					footer: footer
				},
				this.renderContents(context, instance)
			);
		};

		_proto.handleKeyDown = function handleKeyDown(event, instance, component) {
			if (_Overlay.prototype.handleKeyDown.call(this, event, instance, component) == false) return;
			if (this.closeOnEscape && event.keyCode == KeyCode.esc && instance.dismiss) instance.dismiss();
		};

		return Window;
	})(Overlay);
Window.prototype.baseClass = "window";
Window.prototype.closable = true;
Window.prototype.resizable = false;
Window.prototype.fixed = false;
Window.prototype.autoFocus = true;
Window.prototype.focusable = true;
Window.prototype.closeOnEscape = false;
Widget.alias("window", Window);
Localization.registerPrototype("cx/widgets/Window", Window);

var WindowComponent =
	/*#__PURE__*/
	(function(_OverlayComponent) {
		_inheritsLoose(WindowComponent, _OverlayComponent);

		function WindowComponent() {
			return _OverlayComponent.apply(this, arguments) || this;
		}

		var _proto2 = WindowComponent.prototype;

		_proto2.renderOverlayBody = function renderOverlayBody() {
			var _this = this;

			var _this$props$instance = this.props.instance,
				widget = _this$props$instance.widget,
				data = _this$props$instance.data;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var header, footer;

			if (this.props.header.length > 0) {
				header = VDOM$2.createElement(
					"header",
					{
						key: "header",
						ref: function ref(c) {
							_this.headerEl = c;
						},
						className: CSS.element(baseClass, "header"),
						style: data.headerStyle,
						onMouseDown: this.onHeaderMouseDown.bind(this),
						onMouseUp: ddMouseUp,
						onMouseMove: this.onHeaderMouseMove.bind(this),
						onTouchStart: this.onHeaderMouseDown.bind(this),
						onTouchEnd: ddMouseUp,
						onTouchMove: this.onHeaderMouseMove.bind(this)
					},
					this.props.header
				);
			}

			if (this.props.footer) {
				footer = VDOM$2.createElement(
					"footer",
					{
						key: "footer",
						ref: function ref(c) {
							_this.footerEl = c;
						},
						className: CSS.element(baseClass, "footer"),
						style: data.footerStyle
					},
					this.props.footer
				);
			}

			var bodyStyle = data.bodyStyle;
			var body = VDOM$2.createElement(
				"div",
				{
					key: "body",
					ref: function ref(c) {
						_this.bodyEl = c;
					},
					className: CSS.element(widget.baseClass, "body"),
					style: bodyStyle
				},
				this.props.children
			);
			return [header, body, footer];
		};

		_proto2.getOverlayCssClass = function getOverlayCssClass() {
			var cls = _OverlayComponent.prototype.getOverlayCssClass.call(this);

			if (this.state.active) cls += " cxs-active";
			return cls;
		};

		_proto2.onFocusIn = function onFocusIn() {
			var _this2 = this;

			_OverlayComponent.prototype.onFocusIn.call(this);

			if (!this.state.active) {
				this.setState(
					{
						active: true
					},
					function() {
						//React portals cause focusin events which may actually belong to another window or a dropdown
						if (_this2.containerEl.contains(document.activeElement)) _this2.setZIndex(ZIndexManager.next());
					}
				);
			}
		};

		_proto2.onFocusOut = function onFocusOut() {
			_OverlayComponent.prototype.onFocusOut.call(this);

			if (this.state.active) {
				this.setState({
					active: false
				});
			}
		};

		_proto2.onHeaderMouseDown = function onHeaderMouseDown(e) {
			e.stopPropagation();
			ddMouseDown(e);
		};

		_proto2.onHeaderMouseMove = function onHeaderMouseMove(e) {
			e.stopPropagation();

			if (!this.props.instance.widget.fixed && ddDetect(e)) {
				this.startMoveOperation(e);
			}
		};

		return WindowComponent;
	})(OverlayComponent);

var MsgBox =
	/*#__PURE__*/
	(function() {
		function MsgBox() {}

		MsgBox.alert = function alert$$1(options) {
			if (isString(options))
				options = {
					message: options
				};
			return new Promise(function(resolve) {
				var callback = function callback(e, instance) {
					if (options.callback && options.callback() === false) return;
					instance.parentOptions.dismiss();
					resolve();
				};

				var w = Widget.create({
					$type: Window,
					title: options.title,
					header: options.header,
					mod: "alert",
					modal: true,
					center: true,
					resizable: false,
					closable: false,
					style: options.style || "max-width: 90vw",
					dismissOnPopState: true,
					jsxAttributes: [
						"title",
						"header",
						"mod",
						"modal",
						"center",
						"resizable",
						"closable",
						"style",
						"dismissOnPopState"
					],
					children: [
						"\n               ",
						options.message || options.items || options.children,
						"\n               ",
						{
							$type: FlexRow,
							putInto: "footer",
							direction: MsgBox.prototype.footerDirection,
							justify: MsgBox.prototype.footerJustify,
							jsxAttributes: ["putInto", "direction", "justify"],
							children: [
								"\n                  ",
								{
									$type: Button,
									mod: MsgBox.prototype.buttonMod,
									onClick: callback,
									jsxAttributes: ["mod", "onClick"],
									children: [options.okText || "OK"]
								},
								"\n               "
							]
						},
						"\n            "
					]
				});
				w.open(options.store);
			});
		};

		MsgBox.yesNo = function yesNo$$1(options) {
			if (isString(options))
				options = {
					message: options
				};
			return new Promise(function(resolve, reject) {
				var callback = function callback(option) {
					return function(e, instance) {
						if (options.callback && options.callback(option) === false) return;
						instance.parentOptions.dismiss();
						if (option == "yes") resolve(option);
						else resolve(option);
					};
				};

				var w = Widget.create({
					$type: Window,
					title: options.title,
					header: options.header,
					mod: "alert",
					modal: true,
					center: true,
					resizable: false,
					closable: false,
					style: options.style || "max-width: 90vw",
					dismissOnPopState: true,
					jsxAttributes: [
						"title",
						"header",
						"mod",
						"modal",
						"center",
						"resizable",
						"closable",
						"style",
						"dismissOnPopState"
					],
					children: [
						"\n               ",
						options.message || options.items || options.children,
						"\n               ",
						{
							$type: FlexRow,
							putInto: "footer",
							direction: MsgBox.prototype.footerDirection,
							justify: MsgBox.prototype.footerJustify,
							hspacing: "small",
							jsxAttributes: ["putInto", "direction", "justify", "hspacing"],
							children: [
								"\n                  ",
								{
									$type: Button,
									mod: MsgBox.prototype.buttonMod,
									onClick: callback("yes"),
									jsxAttributes: ["mod", "onClick"],
									children: [options.yesText || MsgBox.prototype.yesText]
								},
								"\n                  ",
								{
									$type: Button,
									mod: MsgBox.prototype.buttonMod,
									onClick: callback("no"),
									jsxAttributes: ["mod", "onClick"],
									children: [options.noText || MsgBox.prototype.noText]
								},
								"\n               "
							]
						},
						"\n            "
					]
				});
				w.open(options.store);
			});
		};

		return MsgBox;
	})();
MsgBox.prototype.buttonMod = null;
MsgBox.prototype.footerDirection = "row";
MsgBox.prototype.footerJustify = "center";
MsgBox.prototype.yesText = "Yes";
MsgBox.prototype.noText = "No";
Localization.registerPrototype("cx/widgets/MsgBox", MsgBox);
function enableMsgBoxAlerts() {
	registerAlertImpl({
		yesNo: MsgBox.yesNo.bind(MsgBox),
		alert: MsgBox.alert.bind(MsgBox)
	});
}

var Toast =
	/*#__PURE__*/
	(function(_Overlay) {
		_inheritsLoose(Toast, _Overlay);

		function Toast() {
			return _Overlay.apply(this, arguments) || this;
		}

		var _proto = Toast.prototype;

		_proto.init = function init() {
			if (this.message)
				this.items = {
					type: Text,
					value: this.message
				};

			_Overlay.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Overlay$prototype$de;

			return (_Overlay$prototype$de = _Overlay.prototype.declareData).call.apply(
				_Overlay$prototype$de,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						timeout: undefined
					}
				])
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			data.stateMods = _objectSpread({}, data.stateMods, {
				pad: this.pad
			});

			_Overlay.prototype.prepareData.call(this, context, instance);
		};

		_proto.overlayDidUpdate = function overlayDidUpdate(instance, component) {
			var el = component.containerEl || component.props.parentEl;

			if (component.state.animated) {
				el.style.height = component.el.offsetHeight + "px";
				el.classList.add(this.CSS.state("live"));
			}
		};

		_proto.overlayDidMount = function overlayDidMount(instance, component) {
			var data = instance.data;

			if (data.timeout > 0) {
				component.timeoutTimer = setTimeout(function() {
					instance.dismiss();
				}, data.timeout);
			}
		};

		_proto.overlayWillDismiss = function overlayWillDismiss(instance, component) {
			var el = component.containerEl || component.props.parentEl;
			el.style.height = 0;
			el.classList.remove(this.CSS.state("live"));
		};

		_proto.overlayWillUnmount = function overlayWillUnmount(instance, component) {
			var el = component.containerEl || component.props.parentEl;
			el.style.height = 0;
			el.classList.remove(this.CSS.state("live"));
			if (component.timeoutTimer) clearTimeout(component.timeoutTimer);
		};

		_proto.containerFactory = function containerFactory() {
			var _this$CSS$block;

			var el = document.createElement("div");
			el.className = this.CSS.element("toaster", "item");
			var placement = this.placement || "top";
			var toaster = getToaster(placement);
			toaster.el.className = this.CSS.block(
				"toaster",
				null,
				((_this$CSS$block = {}), (_this$CSS$block["placement-" + placement] = true), _this$CSS$block)
			);
			toaster.el.insertBefore(el, toaster.el.firstChild);
			return el;
		};

		return Toast;
	})(Overlay);
var toasters = {};

function getToaster(placement) {
	var t = toasters[placement];

	if (!t) {
		var el = document.createElement("div");
		document.body.appendChild(el);
		t = toasters[placement] = {
			el: el
		};
	}

	return t;
}

Toast.prototype.styled = true;
Toast.prototype.pad = true;
Toast.prototype.animate = true;
Toast.prototype.baseClass = "toast";
Toast.prototype.placement = "top";
Toast.prototype.destroyDelay = 300;

var ContextMenu =
	/*#__PURE__*/
	(function(_Dropdown) {
		_inheritsLoose(ContextMenu, _Dropdown);

		function ContextMenu() {
			return _Dropdown.apply(this, arguments) || this;
		}

		return ContextMenu;
	})(Dropdown);
ContextMenu.prototype.trackMouse = true;
ContextMenu.prototype.dismissOnFocusOut = true;
ContextMenu.prototype.firstChildDefinesWidth = true;
ContextMenu.prototype.matchWidth = false;
ContextMenu.prototype.placementOrder = "down-right right up-right down-left left up-left";
ContextMenu.prototype.offset = 0;
ContextMenu.prototype.autoFocus = true;
ContextMenu.prototype.autoFocusFirstChild = true;
ContextMenu.prototype.focusable = true;
var openContextMenu = function openContextMenu(e, content, store, options) {
	e.preventDefault();
	e.stopPropagation();
	var position = getCursorPos(e);
	var menu = ContextMenu.create({
		relatedElement: e.currentTarget,
		mousePosition: {
			x: position.clientX,
			y: position.clientY
		},
		trackMouse: true,
		items: content
	});
	menu.open(store, options);
};

function routeAppend(base, path) {
	var result = base;

	if (path) {
		if (path[0] == "/") {
			if (result[result.length - 1] == "/") result += path.substring(1);
			else result += path;
		} else if (result[result.length - 1] == "/") result += path;
		else result += "/" + path;
	}

	return result;
}

var Route =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(Route, _PureContainer);

		function Route() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = Route.prototype;

		_proto.init = function init() {
			if (this.path) this.route = this.path;

			_PureContainer.prototype.init.call(this);

			if (this.route && this.route[0] !== "+")
				this.matcher = new RouteMatcher(this.route + (this.prefix ? "(*remainder)" : ""));
		};

		_proto.initInstance = function initInstance(context, instance) {
			_PureContainer.prototype.initInstance.call(this, context, instance);

			instance.store = new ReadOnlyDataView({
				store: instance.store
			});

			instance.setStore = function(store) {
				instance.store.setStore(store);
			};
		};

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			(_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						url: undefined
					}
				])
			);
		};

		_proto.checkVisible = function checkVisible(context, instance, data) {
			if (!data.visible) return false;

			if (data.url !== instance.cached.url) {
				instance.cached.url = data.url;
				var matcher = this.matcher;
				var route = this.route;

				if (this.route[0] === "+") {
					route = routeAppend(context.lastRoute.route, this.route.substring(1));
					if (!instance.cached.matcher || instance.cached.route !== route)
						instance.cached.matcher = new RouteMatcher(route + (this.prefix ? "(*remainder)" : ""));
					matcher = instance.cached.matcher;
				}

				instance.cached.result = matcher.match(data.url);
				instance.cached.matcher = matcher;
				instance.cached.route = data.route = route;
			}

			if (!instance.cached.result) return false;
			return _PureContainer.prototype.checkVisible.call(this, context, instance, data);
		};

		_proto.prepareData = function prepareData(context, _ref) {
			var _store$setData;

			var data = _ref.data,
				store = _ref.store,
				cached = _ref.cached;

			_PureContainer.prototype.prepareData.apply(this, arguments);

			store.setData(((_store$setData = {}), (_store$setData[this.recordName] = cached.result), _store$setData)); //TODO: Replace comparison with deepEquals

			if (this.params && this.params.bind) {
				var params = store.get(this.params.bind);

				if (JSON.stringify(params) != JSON.stringify(cached.result)) {
					store.set(this.params.bind, cached.result);
				}
			}

			if (this.map) {
				for (var key in result) {
					var binding = this.map[key];
					if (binding) store.set(binding, result[key]);
				}
			}
		};

		_proto.explore = function explore(context, instance) {
			context.push("lastRoute", {
				route: instance.cached.route,
				result: instance.cached.result,
				reverse: function reverse(data) {
					return instance.cached.matcher.reverse(
						_objectSpread(
							{},
							instance.cached.result,
							{
								remainder: ""
							},
							data
						)
					);
				}
			});

			_PureContainer.prototype.explore.call(this, context, instance);
		};

		_proto.exploreCleanup = function exploreCleanup(context, instance) {
			context.pop("lastRoute");
		};

		return Route;
	})(PureContainer);
Route.prototype.recordName = "$route";
Route.prototype.prefix = false;
Widget.alias("route", Route);

var last = 0,
	next = 1,
	transitions = {},
	subscribers$2 = null,
	reload = false,
	navigateConfirmationCallback = null,
	permanentNavigateConfirmation = false;
var History =
	/*#__PURE__*/
	(function() {
		function History() {}

		History.connect = function connect(store, urlBinding, hashBinding) {
			var _this = this;

			this.store = store;
			this.urlBinding = urlBinding;
			this.hashBinding = hashBinding;
			this.updateStore();

			window.onpopstate = function() {
				_this.updateStore();
			};
		};

		History.pushState = function pushState(state, title, url) {
			return this.confirmAndNavigate(state, title, url);
		};

		History.replaceState = function replaceState(state, title, url) {
			return this.navigate(state, title, url, true);
		};

		History.reloadOnNextChange = function reloadOnNextChange() {
			reload = true;
		};

		History.addNavigateConfirmation = function addNavigateConfirmation(callback, permanent) {
			if (permanent === void 0) {
				permanent = false;
			}

			navigateConfirmationCallback = callback;
			permanentNavigateConfirmation = permanent;
		};

		History.confirmAndNavigate = function confirmAndNavigate(state, title, url, replace) {
			var _this2 = this;

			if (!navigateConfirmationCallback) return this.navigate(state, title, url, replace);
			var result = navigateConfirmationCallback(url);
			Promise.resolve(result).then(function(value) {
				if (value) {
					if (!permanentNavigateConfirmation) navigateConfirmationCallback = null;

					_this2.navigate(state, title, url, replace);
				}
			});
			return false;
		};

		History.navigate = function navigate(state, title, url, replace) {
			var _this3 = this;

			if (replace === void 0) {
				replace = false;
			}

			url = Url.resolve(url);

			if (!window.history.pushState || reload) {
				window.location[replace ? "replace" : "assign"](url);
				return true;
			}

			var transition,
				changed = false;
			batchUpdatesAndNotify(
				function() {
					changed = _this3.updateStore(url);
					if (changed)
						transitions[++last] = transition = {
							url: url,
							state: state,
							title: title,
							replace: replace
						};
				},
				function() {
					if (transition) transition.completed = true; //update history once the page is rendered and the title is set

					while (transitions[next] && transitions[next].completed) {
						var tr = transitions[next];
						delete transitions[next];
						next++;
						var op = tr.replace ? "replaceState" : "pushState";
						window.history[op](tr.state, tr.title, tr.url);
						if (subscribers$2) subscribers$2.notify(tr.url, op);
					}
				}
			);
			return changed;
		};

		History.updateStore = function updateStore(href) {
			var url = Url.unresolve(href || document.location.href),
				hash = null;
			var hashIndex = url.indexOf("#");

			if (hashIndex !== -1) {
				hash = url.substring(hashIndex);
				url = url.substring(0, hashIndex);
			}

			if (this.hashBinding) this.store.set(this.hashBinding, hash);
			return this.store.set(this.urlBinding, url);
		};

		History.subscribe = function subscribe(callback) {
			if (!subscribers$2) subscribers$2 = new SubscriberList();
			return subscribers$2.subscribe(callback);
		};

		return History;
	})();

var RedirectRoute =
	/*#__PURE__*/
	(function(_Route) {
		_inheritsLoose(RedirectRoute, _Route);

		function RedirectRoute() {
			return _Route.apply(this, arguments) || this;
		}

		var _proto = RedirectRoute.prototype;

		_proto.checkVisible = function checkVisible(context, instance, data) {
			if (!data.visible) return false;
			if (!data.url && !data.route) return true;
			return _Route.prototype.checkVisible.call(this, context, instance, data);
		};

		_proto.declareData = function declareData() {
			var _Route$prototype$decl;

			(_Route$prototype$decl = _Route.prototype.declareData).call.apply(
				_Route$prototype$decl,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						redirect: undefined
					}
				])
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			_Route.prototype.prepareData.apply(this, arguments);

			var data = instance.data;
			if (data.redirect && data.redirect[0] === "+")
				data.redirect = routeAppend(context.lastRoute.reverse(), data.redirect.substring(1));
			if (data.redirect && History.store) History.replaceState({}, null, Url.resolve(data.redirect));
			else instance.set("url", data.redirect);
		};

		return RedirectRoute;
	})(Route);
Widget.alias("redirect-route", RedirectRoute);

var Tab =
	/*#__PURE__*/
	(function(_HtmlElement) {
		_inheritsLoose(Tab, _HtmlElement);

		function Tab() {
			return _HtmlElement.apply(this, arguments) || this;
		}

		var _proto = Tab.prototype;

		_proto.declareData = function declareData() {
			var _HtmlElement$prototyp;

			(_HtmlElement$prototyp = _HtmlElement.prototype.declareData).call.apply(
				_HtmlElement$prototyp,
				[
					this,
					{
						tab: undefined,
						value: undefined,
						disabled: undefined,
						text: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			data.stateMods = {
				active: data.tab == data.value,
				disabled: data.disabled,
				shape: this.shape
			};
			if (this.default && isUndefined(data.value)) instance.set("value", data.tab);

			_HtmlElement.prototype.prepareData.call(this, context, instance);
		};

		_proto.isValidHtmlAttribute = function isValidHtmlAttribute(attrName) {
			switch (attrName) {
				case "value":
				case "tab":
				case "text":
				case "disabled":
				case "default":
					return false;

				default:
					return _HtmlElement.prototype.isValidHtmlAttribute.call(this, attrName);
			}
		};

		_proto.attachProps = function attachProps(context, instance, props) {
			var _this = this;

			_HtmlElement.prototype.attachProps.call(this, context, instance, props);

			var data = instance.data;

			if (!data.disabled) {
				props.href = "#";
				delete props.value;

				props.onMouseDown = function(e) {
					if (_this.onMouseDown) instance.invoke("onMouseDown", e, instance);
					preventFocusOnTouch(e);
				};

				props.onClick = function(e) {
					return _this.handleClick(e, instance);
				};
			}
		};

		_proto.handleClick = function handleClick(e, instance) {
			if (this.onClick) instance.invoke("onClick", e, instance);
			e.preventDefault();
			e.stopPropagation();
			var data = instance.data;
			if (data.disabled) return;
			instance.set("value", data.tab);
		};

		return Tab;
	})(HtmlElement);
Tab.prototype.baseClass = "tab";
Tab.prototype.tag = "a";
Tab.prototype.focusOnMouseDown = false;
Tab.prototype.default = false;
Widget.alias("tab", Tab);

var LinkButton =
	/*#__PURE__*/
	(function(_Button) {
		_inheritsLoose(LinkButton, _Button);

		function LinkButton() {
			return _Button.apply(this, arguments) || this;
		}

		var _proto = LinkButton.prototype;

		_proto.declareData = function declareData() {
			var _Button$prototype$dec;

			(_Button$prototype$dec = _Button.prototype.declareData).call.apply(
				_Button$prototype$dec,
				[
					this,
					{
						href: undefined,
						url: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			data.unresolvedHref = data.href;

			if (typeof data.href === "string") {
				if (data.unresolvedHref[0] === "+")
					data.unresolvedHref = routeAppend(context.lastRoute.reverse(), data.href.substring(1));
				data.href = Url.resolve(data.unresolvedHref);
			}

			data.stateMods = {
				disabled: data.disabled,
				active: this.isActive(data)
			};

			_Button.prototype.prepareData.call(this, context, instance);
		};

		_proto.isActive = function isActive(data) {
			switch (this.match) {
				default:
				case "equal":
					return data.url === data.unresolvedHref;

				case "prefix":
					return data.url && data.unresolvedHref && data.url.indexOf(data.unresolvedHref) === 0;

				case "subroute":
					return (
						data.url &&
						data.unresolvedHref &&
						data.url.indexOf(data.unresolvedHref) === 0 &&
						(data.url === data.unresolvedHref || data.url[data.unresolvedHref.length] === "/")
					);
			}
		};

		_proto.attachProps = function attachProps(context, instance, props) {
			var _this = this;

			props.onClick = function(ev) {
				_this.handleClick(ev, instance);
			};

			_Button.prototype.attachProps.call(this, context, instance, props);

			props.href = instance.data.href;
		};

		_proto.isValidHtmlAttribute = function isValidHtmlAttribute(attr) {
			if (attr === "url" || attr === "match") return false;
			return _Button.prototype.isValidHtmlAttribute.call(this, attr);
		};

		_proto.handleClick = function handleClick(e, instance) {
			var data = instance.data;

			if (data.disabled) {
				e.preventDefault();
				return;
			}

			if (this.onClick && instance.invoke("onClick", e, instance) === false) return;

			if (data.href && Url.isLocal(data.href) && !e.ctrlKey && !e.shiftKey && !e.metaKey) {
				e.preventDefault();
				History.pushState({}, null, data.href);
			}
		};

		return LinkButton;
	})(Button);
LinkButton.prototype.match = "equal";
LinkButton.prototype.tag = "a";
Widget.alias("link-button", LinkButton);

var Link =
	/*#__PURE__*/
	(function(_LinkButton) {
		_inheritsLoose(Link, _LinkButton);

		function Link() {
			return _LinkButton.apply(this, arguments) || this;
		}

		return Link;
	})(LinkButton);
Link.prototype.baseClass = "link";
Widget.alias("link", Link);

var subscribers$3,
	eventBan = 0;
function executeKeyboardShortcuts(e) {
	if (Date.now() < eventBan) return; //Avoid duplicate executions as event.stopPropagation() for React events does not stop native events

	eventBan = Date.now() + 5;
	subscribers$3 && subscribers$3.notify(e);
}
function registerKeyboardShortcut(key, callback) {
	var keyCode = isObject(key) ? key.keyCode : key;
	var shiftKey = isObject(key) ? key.shiftKey : false;
	var ctrlKey = isObject(key) ? key.ctrlKey : false;
	var altKey = isObject(key) ? key.altKey : false;

	if (!subscribers$3) {
		subscribers$3 = new SubscriberList();
		document.addEventListener("keydown", function(e) {
			if (e.target == document.body) executeKeyboardShortcuts(e);
		});
	}

	return subscribers$3.subscribe(function(e) {
		if (e.keyCode == keyCode && (!shiftKey || e.shiftKey) && (!ctrlKey || e.ctrlKey) && (!altKey || e.altKey))
			callback(e);
	});
}

/*
 Functionality:
 - renders dropdown when focused
 - tracks focus and closes if focusElement goes outside the dropdown
 - switches focus to the dropdown when right key pressed
 - listens to dropdown's key events and captures focus back when needed
 - automatically opens the dropdown if mouse is held over for a period of time
 */

var MenuItem =
	/*#__PURE__*/
	(function(_HtmlElement) {
		_inheritsLoose(MenuItem, _HtmlElement);

		function MenuItem() {
			return _HtmlElement.apply(this, arguments) || this;
		}

		var _proto = MenuItem.prototype;

		_proto.init = function init() {
			if (this.hideCursor) this.showCursor = false;

			_HtmlElement.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _HtmlElement$prototyp;

			(_HtmlElement$prototyp = _HtmlElement.prototype.declareData).call.apply(
				_HtmlElement$prototyp,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						icon: undefined,
						disabled: undefined,
						checked: false,
						arrow: undefined
					}
				])
			);
		};

		_proto.explore = function explore(context, instance) {
			instance.horizontal = this.horizontal;
			var lastMenu = context.lastMenu;

			if (lastMenu) {
				instance.horizontal = lastMenu.horizontal;
				instance.padding = lastMenu.itemPadding;
				instance.icons = lastMenu.icons;
			}

			instance.parentPositionChangeEvent = context.parentPositionChangeEvent;
			if (!instance.padding && this.pad == true) instance.padding = "medium";
			if (this.padding) instance.padding = this.padding;
			context.push("lastMenuItem", this);

			_HtmlElement.prototype.explore.call(this, context, instance);
		};

		_proto.exploreCleanup = function exploreCleanup(context, instance) {
			context.pop("lastMenuItem");
		};

		_proto.render = function render(context, instance, key) {
			return VDOM$2.createElement(
				MenuItemComponent,
				{
					key: key,
					instance: instance,
					data: instance.data
				},
				instance.data.text
					? VDOM$2.createElement("span", null, instance.data.text)
					: this.renderChildren(context, instance)
			);
		};

		_proto.add = function add(element) {
			if (element && typeof element == "object" && element.putInto == "dropdown") {
				this.dropdown = _objectSpread({}, element);
				delete this.dropdown.putInto;
			} else _HtmlElement.prototype.add.apply(this, arguments);
		};

		_proto.addText = function addText(text) {
			this.add({
				type: HtmlElement,
				tag: "span",
				text: text
			});
		};

		return MenuItem;
	})(HtmlElement);
MenuItem.prototype.baseClass = "menuitem";
MenuItem.prototype.hoverFocusTimeout = 500;
MenuItem.prototype.hoverToOpen = false;
MenuItem.prototype.clickToOpen = false;
MenuItem.prototype.horizontal = true;
MenuItem.prototype.arrow = false;
MenuItem.prototype.dropdownOptions = null;
MenuItem.prototype.showCursor = true;
MenuItem.prototype.pad = true;
MenuItem.prototype.placement = null; //default dropdown placement

MenuItem.prototype.autoClose = false;
MenuItem.prototype.checkedIcon = "check";
MenuItem.prototype.uncheckedIcon = "dummy";
MenuItem.prototype.keyboardShortcut = false;
Widget.alias("submenu", MenuItem);
Localization.registerPrototype("cx/widgets/MenuItem", MenuItem);

var MenuItemComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(MenuItemComponent, _VDOM$Component);

		function MenuItemComponent(props) {
			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			_this.state = {
				dropdownOpen: false
			};
			return _this;
		}

		var _proto2 = MenuItemComponent.prototype;

		_proto2.getDropdown = function getDropdown() {
			var _this2 = this;

			var _this$props$instance = this.props.instance,
				horizontal = _this$props$instance.horizontal,
				widget = _this$props$instance.widget,
				parentPositionChangeEvent = _this$props$instance.parentPositionChangeEvent;

			if (!this.dropdown && widget.dropdown) {
				this.dropdown = Widget.create(
					Dropdown,
					_objectSpread(
						{
							matchWidth: false,
							placementOrder: horizontal
								? "down-right down down-left up-right up up-left"
								: "right-down right right-up left-down left left-up",
							trackScroll: true,
							inline: true
						},
						widget.dropdownOptions,
						{
							relatedElement: this.el.parentElement,
							placement: widget.placement,
							onKeyDown: this.onDropdownKeyDown.bind(this),
							items: widget.dropdown,
							parentPositionChangeEvent: parentPositionChangeEvent,
							pipeValidateDropdownPosition: function pipeValidateDropdownPosition(cb) {
								_this2.validateDropdownPosition = cb;
							}
						}
					)
				);
			}

			return this.dropdown;
		};

		_proto2.render = function render() {
			var _this3 = this,
				_CSS$state;

			var _this$props = this.props,
				instance = _this$props.instance,
				data = _this$props.data,
				children = _this$props.children;
			var widget = instance.widget;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var dropdown =
				this.state.dropdownOpen &&
				VDOM$2.createElement(Cx, {
					widget: this.getDropdown(),
					options: {
						name: "submenu"
					},
					parentInstance: instance,
					subscribe: true
				});
			var arrow =
				data.arrow &&
				VDOM$2.createElement(DropdownIcon, {
					className: CSS.element(baseClass, "arrow")
				});
			var icon = null;
			var checkbox = widget.checked != null;

			if (checkbox) {
				data.icon = data.checked ? widget.checkedIcon : widget.uncheckedIcon;
			}

			if (data.icon) {
				icon = VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "button"),
						onClick: function onClick(e) {
							e.preventDefault();
							if (!instance.set("checked", !data.checked)) _this3.onClick(e);
						},
						onMouseDown: function onMouseDown(e) {
							if (checkbox) e.stopPropagation();
						}
					},
					Icon.render(data.icon, {
						className: CSS.element(baseClass, "icon")
					})
				);
			}

			var empty = !children || (Array.isArray(children) && children.length == 0);
			var classNames = CSS.expand(
				data.classNames,
				CSS.state(
					((_CSS$state = {
						open: this.state.dropdownOpen,
						horizontal: instance.horizontal,
						vertical: !instance.horizontal,
						arrow: data.arrow,
						cursor: widget.showCursor
					}),
					(_CSS$state[instance.padding + "-padding"] = instance.padding),
					(_CSS$state.icon = !!icon || instance.icons),
					(_CSS$state.disabled = data.disabled),
					(_CSS$state.empty = empty),
					_CSS$state)
				)
			);
			if (empty)
				children = VDOM$2.createElement(
					"span",
					{
						className: CSS.element(baseClass, "baseline")
					},
					"\xA0"
				);
			return VDOM$2.createElement(
				"div",
				{
					className: classNames,
					style: data.style,
					tabIndex: !data.disabled && (widget.dropdown || widget.onClick || widget.checked) ? 0 : null,
					ref: function ref(el) {
						_this3.el = el;
					},
					onKeyDown: this.onKeyDown.bind(this),
					onMouseDown: this.onMouseDown.bind(this),
					onMouseEnter: this.onMouseEnter.bind(this),
					onMouseLeave: this.onMouseLeave.bind(this),
					onFocus: this.onFocus.bind(this),
					onClick: this.onClick.bind(this),
					onBlur: this.onBlur.bind(this)
				},
				children,
				icon,
				arrow,
				dropdown
			);
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			if (this.state.dropdownOpen && this.validateDropdownPosition) {
				this.validateDropdownPosition();
			}
		};

		_proto2.componentDidMount = function componentDidMount() {
			var _this4 = this;

			var widget = this.props.instance.widget;
			if (widget.keyboardShortcut)
				this.unregisterKeyboardShortcut = registerKeyboardShortcut(widget.keyboardShortcut, function(e) {
					_this4.el.focus(); //open the dropdown

					_this4.onClick(e); //execute the onClick handler
				});
			tooltipParentDidMount(this.el, this.props.instance, widget.tooltip);
		};

		_proto2.onDropdownKeyDown = function onDropdownKeyDown(e) {
			debug(menuFlag, "MenuItem", "dropdownKeyDown");
			var horizontal = this.props.instance.horizontal;

			if (e.keyCode == KeyCode.esc || (horizontal ? e.keyCode == KeyCode.up : e.keyCode == KeyCode.left)) {
				FocusManager.focus(this.el);
				e.preventDefault();
				e.stopPropagation();
			}
		};

		_proto2.clearAutoFocusTimer = function clearAutoFocusTimer() {
			if (this.autoFocusTimerId) {
				debug(menuFlag, "MenuItem", "autoFocusCancel");
				clearTimeout(this.autoFocusTimerId);
				delete this.autoFocusTimerId;
			}
		};

		_proto2.onMouseEnter = function onMouseEnter(e) {
			var _this5 = this;

			debug(menuFlag, "MenuItem", "mouseEnter", this.el);
			var widget = this.props.instance.widget;

			if (widget.dropdown && !this.state.dropdownOpen) {
				this.clearAutoFocusTimer();
				if (widget.hoverToOpen) FocusManager.focus(this.el);
				else if (!widget.clickToOpen) {
					// Automatically open the dropdown only if parent menu is focused
					var commonParentMenu = closest(this.el, function(el) {
						return el.tagName == "UL" && el.contains(getActiveElement());
					});
					if (commonParentMenu)
						this.autoFocusTimerId = setTimeout(function() {
							delete _this5.autoFocusTimerId;

							if (!_this5.state.dropdownOpen) {
								debug(menuFlag, "MenuItem", "hoverFocusTimeout:before", _this5.el);
								FocusManager.focus(_this5.el);
								debug(menuFlag, "MenuItem", "hoverFocusTimeout:after", _this5.el, getActiveElement());
							}
						}, widget.hoverFocusTimeout);
				}
				e.stopPropagation();
				e.preventDefault();
			}

			tooltipMouseMove(e, this.props.instance, widget.tooltip);
		};

		_proto2.onMouseLeave = function onMouseLeave(e) {
			var widget = this.props.instance.widget;

			if (widget.dropdown) {
				debug(menuFlag, "MenuItem", "mouseLeave", this.el);
				this.clearAutoFocusTimer();
				if (widget.hoverToOpen && document.activeElement == this.el) this.el.blur();
			}

			tooltipMouseLeave(e, this.props.instance, widget.tooltip);
		};

		_proto2.onKeyDown = function onKeyDown(e) {
			var _this6 = this;

			debug(menuFlag, "MenuItem", "keyDown", this.el);
			var _this$props$instance2 = this.props.instance,
				horizontal = _this$props$instance2.horizontal,
				widget = _this$props$instance2.widget;

			if (widget.dropdown) {
				if (
					e.target == this.el &&
					(e.keyCode == KeyCode.enter || (horizontal ? e.keyCode == KeyCode.down : e.keyCode == KeyCode.right))
				) {
					this.openDropdown(function() {
						var focusableChild = findFirstChild(_this6.el, isFocusable);
						if (focusableChild) FocusManager.focus(focusableChild);
					});
					e.preventDefault();
					e.stopPropagation();
				}

				if (e.keyCode == KeyCode.esc) {
					if (!isFocused(this.el)) {
						FocusManager.focus(this.el);
						e.preventDefault();
						e.stopPropagation();
					}

					this.closeDropdown();
				}
			} else {
				if (e.keyCode == KeyCode.enter && widget.onClick) this.onClick(e);
			}
		};

		_proto2.onMouseDown = function onMouseDown(e) {
			var widget = this.props.instance.widget;

			if (widget.dropdown) {
				e.stopPropagation();
				if (this.state.dropdownOpen && !widget.hoverToOpen) this.closeDropdown();
				else {
					//IE sometimes does not focus parent on child click
					if (!isFocusedDeep(this.el)) FocusManager.focus(this.el);
					this.openDropdown();
				}
			}
		};

		_proto2.openDropdown = function openDropdown(callback) {
			var widget = this.props.instance.widget;

			if (widget.dropdown) {
				if (!this.state.dropdownOpen)
					this.setState(
						{
							dropdownOpen: true
						},
						callback
					);
				else if (callback) callback(this.state);
			}
		};

		_proto2.onClick = function onClick(e) {
			e.stopPropagation();
			var instance = this.props.instance;

			if (instance.data.disabled) {
				e.preventDefault();
				return;
			}

			var widget = instance.widget;
			if (widget.dropdown) e.preventDefault();
			else {
				//prevent navigation
				instance.set("checked", !instance.data.checked);
				if (widget.onClick) instance.invoke("onClick", e, instance);
			}
			if (widget.autoClose) getActiveElement().blur();
		};

		_proto2.onFocus = function onFocus() {
			var widget = this.props.instance.widget;

			if (widget.dropdown) {
				oneFocusOut(this, this.el, this.onFocusOut.bind(this));
				debug(menuFlag, "MenuItem", "focus", this.el, document.activeElement);
				this.clearAutoFocusTimer();
				this.openDropdown();
			}
		};

		_proto2.onBlur = function onBlur() {
			FocusManager.nudge();
		};

		_proto2.closeDropdown = function closeDropdown() {
			this.setState({
				dropdownOpen: false
			});
		};

		_proto2.onFocusOut = function onFocusOut(focusedElement) {
			debug(menuFlag, "MenuItem", "focusout", this.el, focusedElement);
			this.clearAutoFocusTimer();

			if (!isSelfOrDescendant(this.el, focusedElement)) {
				debug(menuFlag, "MenuItem", "closing dropdown", this.el, focusedElement);
				this.closeDropdown();
			}
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			this.clearAutoFocusTimer();
			offFocusOut(this);
			if (this.offParentPositionChange) this.offParentPositionChange();
			if (this.unregisterKeyboardShortcut) this.unregisterKeyboardShortcut();
			tooltipParentWillUnmount(this.props.instance);
		};

		return MenuItemComponent;
	})(VDOM$2.Component);

/*
 Functionality:
 - renders a list of items in a form of horizontal or vertical menu
 - provides cursor with mouse and keyboard nav
 - changes focusElement to the first focusable child when cursor is moved using keyboard
 */

var Menu =
	/*#__PURE__*/
	(function(_HtmlElement) {
		_inheritsLoose(Menu, _HtmlElement);

		function Menu() {
			return _HtmlElement.apply(this, arguments) || this;
		}

		var _proto = Menu.prototype;

		_proto.init = function init() {
			if (this.itemPadding === true) this.itemPadding = "medium";
			if (this.horizontal && isUndefined(this.itemPadding)) this.itemPadding = this.defaultHorizontalItemPadding;
			if (!this.horizontal && isUndefined(this.itemPadding)) this.itemPadding = this.defaultVerticalItemPadding;

			_HtmlElement.prototype.init.call(this);

			if (this.overflow) {
				if (!this.horizontal) throw new Error("Overflow works only on horizontal menus.");
				this.items.push(
					MenuItem.create({
						icon: this.overflowIcon,
						mod: "overflow",
						items: [
							{
								type: Menu,
								putInto: "dropdown",
								items: [].concat(this.items)
							}
						]
					})
				);
			}
		};

		_proto.prepareData = function prepareData(context, instance) {
			var _objectSpread2;

			var data = instance.data;
			data.stateMods = _objectSpread(
				{},
				data.stateMods,
				((_objectSpread2 = {
					horizontal: this.horizontal,
					vertical: !this.horizontal,
					overflow: this.overflow
				}),
				(_objectSpread2[this.itemPadding + "-item-padding"] = this.itemPadding),
				_objectSpread2)
			);

			_HtmlElement.prototype.prepareData.call(this, context, instance);
		};

		_proto.explore = function explore(context, instance) {
			context.push("lastMenu", this);

			_HtmlElement.prototype.explore.call(this, context, instance);
		};

		_proto.exploreCleanup = function exploreCleanup(context, instance) {
			context.pop("lastMenu");
		};

		_proto.render = function render(context, instance, key) {
			return VDOM$2.createElement(
				MenuComponent,
				{
					key: key,
					instance: instance
				},
				this.renderChildren(context, instance)
			);
		};

		_proto.add = function add(item) {
			if (item && item.tag == "a") {
				var mi = {
					type: MenuItem,
					items: item,
					autoClose: true
				};
				if (item.if) mi.if = item.if;
				if (item.visible) mi.visible = item.visible;

				_HtmlElement.prototype.add.call(this, mi);
			} else _HtmlElement.prototype.add.apply(this, arguments);
		};

		return Menu;
	})(HtmlElement);
Menu.prototype.horizontal = false;
Menu.prototype.defaultVerticalItemPadding = "medium";
Menu.prototype.defaultHorizontalItemPadding = "small";
Menu.prototype.icons = false;
Menu.prototype.overflow = false;
Menu.prototype.overflowIcon = "drop-down";
Menu.Item = MenuItem;

var MenuComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(MenuComponent, _VDOM$Component);

		function MenuComponent(props) {
			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			_this.state = {
				cursor: null,
				visibleItemCount: Infinity
			};

			_this.ref = function(el) {
				_this.el = el;
			};

			return _this;
		}

		var _proto2 = MenuComponent.prototype;

		_proto2.render = function render() {
			var _this2 = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				children = _this$props.children;
			var data = instance.data,
				widget = instance.widget;
			var CSS = widget.CSS;
			this.itemInfo = Array.from({
				length: children.length
			});
			return VDOM$2.createElement(
				"ul",
				{
					ref: this.ref,
					className: CSS.expand(
						data.classNames,
						CSS.state({
							pack: this.state.visibleItemCount < children.length - 1
						})
					),
					style: data.style,
					onFocus: this.onFocus.bind(this),
					onBlur: FocusManager.nudge(),
					onKeyDown: this.onKeyDown.bind(this)
				},
				children.map(function(c, i) {
					var key = i;
					if (c && typeof c == "object" && c.key) key = c.key;
					return VDOM$2.createElement(
						MenuItemComponent$1,
						{
							key: key,
							cursor: key === _this2.state.cursor,
							hidden: i >= _this2.state.visibleItemCount && i + 1 != children.length,
							instance: instance,
							itemInfo: _this2.itemInfo,
							itemKey: key,
							itemIndex: i,
							moveCursor: _this2.moveCursor.bind(_this2)
						},
						c
					);
				})
			);
		};

		_proto2.moveCursor = function moveCursor(itemKey) {
			if (itemKey != this.state.cursor) {
				debug(menuFlag, "Menu", "moveCursor", itemKey);
				this.setState({
					cursor: itemKey
				});
			}
		};

		_proto2.onKeyDown = function onKeyDown(e) {
			var _this3 = this;

			var instance = this.props.instance;
			var widget = instance.widget;
			var keyCode = e.keyCode;
			debug(menuFlag, "Menu", "keyDown", this.el, keyCode);
			var horizontal = widget.horizontal;

			if (keyCode == KeyCode.tab) {
				if (horizontal) keyCode = e.shiftKey ? KeyCode.left : KeyCode.up;
				else keyCode = e.shiftKey ? KeyCode.right : KeyCode.down;
			}

			if (this.state.cursor != null) {
				var cursorIndex = this.itemInfo.findIndex(function(a) {
					return a.key == _this3.state.cursor;
				});

				if (horizontal ? keyCode == KeyCode.left : keyCode == KeyCode.up) {
					for (var c = cursorIndex - 1; c >= 0; c--) {
						if (this.itemInfo[c].focusable) {
							FocusManager.focusFirst(this.itemInfo[c].el);
							e.stopPropagation();
							e.preventDefault();
							return;
						}
					}
				}

				if (horizontal ? keyCode == KeyCode.right : keyCode == KeyCode.down) {
					for (var _c = cursorIndex + 1; _c < this.itemInfo.length; _c++) {
						if (this.itemInfo[_c].focusable) {
							FocusManager.focusFirst(this.itemInfo[_c].el);
							e.stopPropagation();
							e.preventDefault();
							return;
						}
					}
				}
			}

			switch (keyCode) {
				case KeyCode.home:
					if (this.itemInfo[0].focusable) {
						FocusManager.focusFirst(this.itemInfo[0].el);
						e.stopPropagation();
						e.preventDefault();
					}

					break;

				case KeyCode.end:
					if (this.itemInfo[this.itemInfo.length - 1].focusable) {
						FocusManager.focusFirst(this.itemInfo[this.itemInfo.length - 1].el);
						e.stopPropagation();
						e.preventDefault();
					}

					break;
			}
		};

		_proto2.onFocusOut = function onFocusOut(elementReceivingFocus) {
			debug(menuFlag, "Menu", "focusout", this.el, elementReceivingFocus);
			if (!isSelfOrDescendant(this.el, elementReceivingFocus)) this.moveCursor(null);
		};

		_proto2.componentDidMount = function componentDidMount() {
			var widget = this.props.instance.widget;
			if (widget.autoFocus && this.itemInfo.length > 0) FocusManager.focusFirst(this.itemInfo[0].el);
			this.measureOverflow();
			if (widget.overflow)
				this.unsubscribeResize = ResizeManager.trackElement(this.el, this.measureOverflow.bind(this));
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			this.measureOverflow();
		};

		_proto2.measureOverflow = function measureOverflow() {
			var instance = this.props.instance;
			var widget = instance.widget;
			if (!widget.overflow) return;
			var visibleItemCount = 0;
			var fitItemsWidth = 0;
			var children = Array.from(this.el.children);
			var widths = children.map(function(c) {
				return c.offsetWidth;
			});
			var clientWidth = this.el.clientWidth;
			var overflowWidth = widths[widths.length - 1];

			for (var i = 0; i < widths.length - 1; i++) {
				if (widths[i] + fitItemsWidth > clientWidth - overflowWidth) break;
				visibleItemCount++;
				fitItemsWidth += widths[i];
			}

			if (this.state.visibleItemCount != visibleItemCount) {
				this.setState({
					visibleItemCount: visibleItemCount
				});
			}

			instance.visibleMenuItemCount = visibleItemCount;
		};

		_proto2.onFocus = function onFocus() {
			oneFocusOut(this, this.el, this.onFocusOut.bind(this));
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			offFocusOut(this);
			this.unsubscribeResize && this.unsubscribeResize();
		};

		return MenuComponent;
	})(VDOM$2.Component);

Menu.prototype.baseClass = "menu";
Menu.prototype.tag = "ul";
Widget.alias("menu", Menu);

var MenuItemComponent$1 =
	/*#__PURE__*/
	(function(_VDOM$Component2) {
		_inheritsLoose(MenuItemComponent, _VDOM$Component2);

		function MenuItemComponent(props) {
			var _this4;

			_this4 = _VDOM$Component2.call(this, props) || this;
			_this4.state = {
				focusable: true
			};
			return _this4;
		}

		var _proto3 = MenuItemComponent.prototype;

		_proto3.render = function render() {
			var _this5 = this;

			var _this$props2 = this.props,
				itemInfo = _this$props2.itemInfo,
				itemIndex = _this$props2.itemIndex,
				itemKey = _this$props2.itemKey,
				instance = _this$props2.instance,
				cursor = _this$props2.cursor,
				hidden = _this$props2.hidden;
			var widget = instance.widget;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var mods = {
				cursor: cursor,
				focusable: this.state.focusable,
				hidden: hidden
			};
			return VDOM$2.createElement(
				"li",
				{
					ref: function ref(c) {
						_this5.el = c;
						itemInfo[itemIndex] = {
							el: c,
							focusable: _this5.state.focusable,
							key: itemKey
						};
					},
					className: CSS.element(baseClass, "item", mods),
					onFocus: this.onFocus.bind(this),
					onMouseDown: this.onMouseDown.bind(this),
					onKeyDown: this.onKeyDown.bind(this)
				},
				this.props.children
			);
		};

		_proto3.onFocus = function onFocus(e) {
			FocusManager.nudge();
			debug(menuFlag, "MenuItem", "focus", this.el, e.target);
			this.props.moveCursor(this.props.itemKey);
		};

		_proto3.onKeyDown = function onKeyDown(e) {
			var instance = this.props.instance;
			var widget = instance.widget;
			if (widget.onKeyDown) instance.invoke("onKeyDown", e, instance);
		};

		_proto3.onMouseDown = function onMouseDown(e) {
			e.stopPropagation();
			e.preventDefault();
			debug(menuFlag, "MenuItem", "mouseDown", this.el);

			if (this.state.focusable) {
				var _this$props3 = this.props,
					itemInfo = _this$props3.itemInfo,
					itemIndex = _this$props3.itemIndex;
				var el = itemInfo[itemIndex].el;
				var focusedEl = getFocusedElement();
				var focusedChild = FocusManager.focusFirst(el);

				if (focusedChild !== focusedEl) {
					debug(menuFlag, "MenuItem", "focusChild", focusedChild, focusedEl);
				}
			}
		};

		_proto3.componentDidMount = function componentDidMount() {
			this.componentDidUpdate();
		};

		_proto3.componentDidUpdate = function componentDidUpdate() {
			var _this$props4 = this.props,
				itemInfo = _this$props4.itemInfo,
				itemIndex = _this$props4.itemIndex,
				hidden = _this$props4.hidden;
			var focusable = !hidden && !!findFirst(this.el, isFocusable);

			if (focusable !== this.state.focusable) {
				itemInfo[itemIndex].focusable = focusable;
				this.setState({
					focusable: focusable
				});
			}
		};

		return MenuItemComponent;
	})(VDOM$2.Component);

var Submenu =
	/*#__PURE__*/
	(function(_MenuItem) {
		_inheritsLoose(Submenu, _MenuItem);

		function Submenu() {
			return _MenuItem.apply(this, arguments) || this;
		}

		return Submenu;
	})(MenuItem);

var Scroller =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(Scroller, _Container);

		function Scroller() {
			return _Container.apply(this, arguments) || this;
		}

		var _proto = Scroller.prototype;

		_proto.init = function init() {
			if (!this.vertical) this.horizontal = true; //default

			_Container.prototype.init.call(this);
		};

		_proto.render = function render(context, instance, key) {
			return VDOM$2.createElement(
				HScrollerComponent,
				{
					key: key,
					widget: this,
					data: instance.data
				},
				this.renderChildren(context, instance)
			);
		};

		return Scroller;
	})(Container);
Scroller.prototype.styled = true;
Scroller.prototype.baseClass = "scroller";
var HScrollerComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(HScrollerComponent, _VDOM$Component);

		function HScrollerComponent(props) {
			var _this;

			_this = _VDOM$Component.call(this, props) || this;

			_this.stopScrolling = function() {
				delete _this.doScroll;
			};

			_this.scrollLeft = function() {
				return _this.scroll("left");
			};

			_this.scrollRight = function() {
				return _this.scroll("right");
			};

			_this.scrollUp = function() {
				return _this.scroll("up");
			};

			_this.scrollDown = function() {
				return _this.scroll("down");
			};

			_this.state = {
				scrollable: false
			};
			return _this;
		}

		var _proto2 = HScrollerComponent.prototype;

		_proto2.render = function render() {
			var _this2 = this;

			var _this$props = this.props,
				data = _this$props.data,
				children = _this$props.children,
				widget = _this$props.widget;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			return VDOM$2.createElement(
				"div",
				{
					className: CSS.expand(
						data.classNames,
						CSS.state({
							scrollable: this.state.scrollable,
							horizontal: widget.horizontal,
							vertical: widget.vertical
						})
					),
					style: data.style
				},
				widget.horizontal &&
					VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "left-arrow"),
							onMouseDown: this.scrollLeft,
							onTouchStart: this.scrollLeft,
							onMouseUp: this.stopScrolling,
							onTouchEnd: this.stopScrolling
						},
						Icon.render("drop-down", {
							className: CSS.element(baseClass, "icon")
						})
					),
				widget.horizontal &&
					VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "right-arrow"),
							onMouseDown: this.scrollRight,
							onTouchStart: this.scrollRight,
							onMouseUp: this.stopScrolling,
							onTouchEnd: this.stopScrolling
						},
						Icon.render("drop-down", {
							className: CSS.element(baseClass, "icon")
						})
					),
				widget.vertical &&
					VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "top-arrow"),
							onMouseDown: this.scrollUp,
							onTouchStart: this.scrollUp,
							onMouseUp: this.stopScrolling,
							onTouchEnd: this.stopScrolling
						},
						Icon.render("drop-down", {
							className: CSS.element(baseClass, "icon")
						})
					),
				widget.vertical &&
					VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "bottom-arrow"),
							onMouseDown: this.scrollDown,
							onTouchStart: this.scrollDown,
							onMouseUp: this.stopScrolling,
							onTouchEnd: this.stopScrolling
						},
						Icon.render("drop-down", {
							className: CSS.element(baseClass, "icon")
						})
					),
				VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "clip"),
						ref: function ref(el) {
							_this2.clip = el;
						}
					},
					VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "scroller"),
							ref: function ref(el) {
								_this2.scroller = el;
							}
						},
						VDOM$2.createElement(
							"div",
							{
								className: CSS.element(baseClass, "content"),
								ref: function ref(el) {
									_this2.content = el;
								}
							},
							children
						)
					)
				)
			);
		};

		_proto2.componentDidMount = function componentDidMount() {
			this.unsubscribeResize = ResizeManager.trackElement(this.clip, this.componentDidUpdate.bind(this));
			this.componentDidUpdate();
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			var widget = this.props.widget;
			var scrollable = false;

			if (widget.horizontal) {
				var scrollSize = this.scroller.offsetHeight - this.scroller.clientHeight;
				this.scroller.style.marginBottom = -scrollSize + "px";
				if (this.content.scrollWidth > this.clip.clientWidth) scrollable = true;
			}

			if (widget.vertical) {
				var _scrollSize = this.scroller.offsetWidth - this.scroller.clientWidth;

				this.scroller.style.marginRight = -_scrollSize + "px";
				if (this.content.scrollHeight > this.clip.clientHeight) scrollable = true;
			}

			if (scrollable != this.state.scrollable)
				this.setState({
					scrollable: scrollable
				});
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			this.unsubscribeResize();
		};

		_proto2.scroll = function scroll(direction) {
			var _this3 = this;

			this.doScroll = function() {
				if (!_this3.scroller) return;

				switch (direction) {
					case "left":
						_this3.scroller.scrollLeft -= 10;
						break;

					case "right":
						_this3.scroller.scrollLeft += 10;
						break;

					case "up":
						_this3.scroller.scrollTop -= 10;
						break;

					case "down":
						_this3.scroller.scrollTop += 10;
						break;
				}

				if (_this3.doScroll) requestAnimationFrame(_this3.doScroll);
			};

			this.doScroll();
		};

		return HScrollerComponent;
	})(VDOM$2.Component);
var HScroller =
	/*#__PURE__*/
	(function(_Scroller) {
		_inheritsLoose(HScroller, _Scroller);

		function HScroller() {
			return _Scroller.apply(this, arguments) || this;
		}

		return HScroller;
	})(Scroller);
HScroller.prototype.horizontal = true;
var VScroller =
	/*#__PURE__*/
	(function(_Scroller2) {
		_inheritsLoose(VScroller, _Scroller2);

		function VScroller() {
			return _Scroller2.apply(this, arguments) || this;
		}

		return VScroller;
	})(Scroller);
VScroller.prototype.vertical = true;

var ValidationError =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(ValidationError, _Widget);

		function ValidationError() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = ValidationError.prototype;

		_proto.checkVisible = function checkVisible(context, instance, data) {
			if (
				data.visible &&
				context.lastFieldId &&
				context.validation &&
				context.validation.errors &&
				context.validation.errors.length > 0
			) {
				var lastError = (instance.lastError = context.validation.errors[context.validation.errors.length - 1]);
				return lastError.fieldId == context.lastFieldId && lastError.visited;
			}

			return false;
		};

		_proto.explore = function explore(context, instance) {
			var data = instance.data,
				lastError = instance.lastError;
			var c1 = instance.cache("lastErrorMessage", lastError.message);
			var c2 = instance.cache("lastErrorFieldId", lastError.fieldId);

			if (c1 || c2) {
				data.errorMessage = lastError.message;
				data.fieldId = lastError.fieldId;
				instance.markShouldUpdate(context);
			}

			_Widget.prototype.explore.call(this, context, instance);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			return VDOM$2.createElement(
				"label",
				{
					key: key,
					className: data.classNames,
					htmlFor: data.fieldId
				},
				data.errorMessage
			);
		};

		return ValidationError;
	})(Widget);
ValidationError.prototype.baseClass = "validationerror";
ValidationError.prototype.styled = true;
Widget.alias("validation-error", ValidationError);

var HelpText =
	/*#__PURE__*/
	(function(_HtmlElement) {
		_inheritsLoose(HelpText, _HtmlElement);

		function HelpText() {
			return _HtmlElement.apply(this, arguments) || this;
		}

		return HelpText;
	})(HtmlElement);
HelpText.prototype.tag = "span";
HelpText.prototype.baseClass = "helptext";
Widget.alias("help-text", HelpText);

var Label =
	/*#__PURE__*/
	(function(_HtmlElement) {
		_inheritsLoose(Label, _HtmlElement);

		function Label() {
			return _HtmlElement.apply(this, arguments) || this;
		}

		var _proto = Label.prototype;

		_proto.declareData = function declareData() {
			var _HtmlElement$prototyp;

			(_HtmlElement$prototyp = _HtmlElement.prototype.declareData).call.apply(
				_HtmlElement$prototyp,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						required: undefined,
						disabled: undefined,
						htmlFor: undefined
					}
				])
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			data.stateMods = _objectSpread({}, data.stateMods, {
				disabled: data.disabled
			});

			_HtmlElement.prototype.prepareData.call(this, context, instance);
		};

		_proto.explore = function explore(context, instance) {
			if (!instance.data.htmlFor) instance.data.htmlFor = context.lastFieldId;

			_HtmlElement.prototype.explore.call(this, context, instance);
		};

		_proto.isValidHtmlAttribute = function isValidHtmlAttribute(attrName) {
			switch (attrName) {
				case "asterisk":
				case "required":
					return false;
			}

			return _HtmlElement.prototype.isValidHtmlAttribute.call(this, attrName);
		};

		_proto.attachProps = function attachProps(context, instance, props) {
			_HtmlElement.prototype.attachProps.call(this, context, instance, props);

			if (instance.data.htmlFor) {
				props.htmlFor = instance.data.htmlFor;
				if (!props.onClick)
					props.onClick = function() {
						//additional focus for LookupFields which are not input based
						var el = document.getElementById(instance.data.htmlFor);
						if (el) FocusManager.focusFirst(el);
					};
			}

			var data = instance.data;

			if (this.asterisk && data.required) {
				if (!isArray(props.children)) props.children = [props.children];
				props.children.push(" ");
				props.children.push(
					VDOM$2.createElement(
						"span",
						{
							key: "asterisk",
							className: this.CSS.element(this.baseClass, "asterisk")
						},
						"*"
					)
				);
			}
		};

		return Label;
	})(HtmlElement);
Label.prototype.baseClass = "label";
Label.prototype.tag = "label";
Label.prototype.asterisk = false;

var Field =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(Field, _PureContainer);

		function Field() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = Field.prototype;

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			(_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[
					this,
					{
						label: undefined,
						labelWidth: undefined,
						mode: undefined,
						viewMode: undefined,
						id: undefined,
						error: undefined,
						inputStyle: {
							structured: true
						},
						inputAttrs: {
							structured: true
						},
						emptyText: undefined,
						visited: undefined,
						autoFocus: undefined,
						tabOnEnterKey: undefined,
						tabIndex: undefined,
						validationParams: {
							structured: true
						}
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.init = function init() {
			switch (this.validationMode) {
				case "tooltip":
					this.errorTooltip = _objectSpread(
						{
							text: {
								bind: "$error"
							},
							mod: "error"
						},
						this.errorTooltip
					);
					break;

				case "help":
				case "help-inline":
					this.help = ValidationError;
					break;

				case "help-block":
					this.help = {
						type: ValidationError,
						mod: "block"
					};
					break;
			}

			if (this.help != null) {
				var helpConfig = {};
				if (this.help.isComponentType) helpConfig = this.help;
				else if (isSelector(this.help)) helpConfig.text = this.help;
				else Object.assign(helpConfig, this.help);
				this.help = HelpText.create(helpConfig);
			}

			if (this.label != null) {
				var labelConfig = {
					mod: this.mod,
					disabled: this.disabled,
					required: this.required,
					asterisk: this.asterisk
				};
				if (this.label.isComponentType) labelConfig = this.label;
				else if (isSelector(this.label)) labelConfig.text = this.label;
				else Object.assign(labelConfig, this.label);
				this.label = Label.create(labelConfig);
			}

			this.inputStyle = parseStyle(this.inputStyle);

			_PureContainer.prototype.init.call(this);
		};

		_proto.initComponents = function initComponents(context, instance) {
			var _PureContainer$protot2;

			return (_PureContainer$protot2 = _PureContainer.prototype.initComponents).call.apply(
				_PureContainer$protot2,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						label: this.label,
						help: this.help
					}
				])
			);
		};

		_proto.initState = function initState(context, instance) {
			instance.state = {
				inputError: false,
				visited: this.visited === true
			};
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data,
				state = instance.state;
			if (!data.id) data.id = "fld-" + instance.id;
			data._disabled = data.disabled;
			data._readOnly = data.readOnly;
			data._viewMode = data.viewMode || data.mode === "view";
			data._tabOnEnterKey = data.tabOnEnterKey;
			instance.parentDisabled = context.parentDisabled;
			instance.parentReadOnly = context.parentReadOnly;
			instance.parentViewMode = context.parentViewMode;
			instance.parentTabOnEnterKey = context.parentTabOnEnterKey;
			if (typeof data.enabled !== "undefined") data._disabled = !data.enabled;
			this.disableOrValidate(context, instance);
			data.inputStyle = parseStyle(data.inputStyle);
			if (this.labelPlacement && this.label) data.mod = [data.mod, "label-placement-" + this.labelPlacement];
			if (this.helpPlacement && this.help) data.mod = [data.mod, "help-placement-" + this.helpPlacement];
			data.empty = this.isEmpty(data);

			if (data.visited && !state.visited) {
				//feels hacky but it should be ok since we're in the middle of a new render cycle
				state.visited = true;
			}

			_PureContainer.prototype.prepareData.apply(this, arguments);
		};

		_proto.disableOrValidate = function disableOrValidate(context, instance) {
			var data = instance.data;
			data.disabled = data._disabled || context.parentDisabled;
			data.readOnly = data._readOnly || context.parentReadOnly;
			data.viewMode = data._viewMode || context.parentViewMode;
			data.tabOnEnterKey = data._tabOnEnterKey || context.parentTabOnEnterKey;
			if (!data.error && !data.disabled && !data.viewMode) this.validate(context, instance);
			data.stateMods = _objectSpread({}, data.stateMods, {
				disabled: data.disabled,
				"edit-mode": !data.viewMode,
				"view-mode": data.viewMode
			});
		};

		_proto.explore = function explore(context, instance) {
			var data = instance.data,
				state = instance.state;
			instance.parentDisabled = context.parentDisabled;
			instance.parentReadOnly = context.parentReadOnly;
			instance.parentViewMode = context.parentViewMode;
			instance.parentTabOnEnterKey = context.parentTabOnEnterKey;

			if (
				instance.cache("parentDisabled", context.parentDisabled) ||
				instance.cache("parentReadOnly", context.parentReadOnly) ||
				instance.cache("parentViewMode", context.parentViewMode) ||
				instance.cache("parentTabOnEnterKey", context.parentTabOnEnterKey)
			) {
				instance.markShouldUpdate(context);
				this.disableOrValidate(context, instance);
				this.prepareCSS(context, instance);
			}

			if (!context.validation)
				context.validation = {
					errors: []
				};

			if (data.error) {
				context.validation.errors.push({
					fieldId: data.id,
					message: data.error,
					visited: state.visited,
					type: "error"
				});
			}

			context.push("lastFieldId", data.id);

			_PureContainer.prototype.explore.call(this, context, instance);
		};

		_proto.exploreCleanup = function exploreCleanup(context, instance) {
			context.pop("lastFieldId");
		};

		_proto.isEmpty = function isEmpty(data) {
			return data.value == null;
		};

		_proto.validateRequired = function validateRequired(context, instance) {
			var data = instance.data;
			if (this.isEmpty(data)) return this.requiredText;
		};

		_proto.validate = function validate(context, instance) {
			var _this = this;

			var data = instance.data,
				state = instance.state;
			state = state || {};

			if (!data.error) {
				if (state.validating) data.error = this.validatingText;
				else if (data.required) {
					var required = this.validateRequired(context, instance);
					if (required) data.error = state.inputError || required;
				}
			}

			if (
				!data.error &&
				!this.isEmpty(data) &&
				this.onValidate &&
				!state.validating &&
				(!state.previouslyValidated || data.value != state.lastValidatedValue)
			) {
				var result = instance.invoke("onValidate", data.value, instance, data.validationParams);

				if (isPromise(result)) {
					data.error = this.validatingText;
					instance.setState({
						validating: true,
						lastValidatedValue: data.value,
						previouslyValidated: true
					});
					result
						.then(function(r) {
							instance.setState({
								validating: false,
								inputError: r
							});
						})
						.catch(function(e) {
							instance.setState({
								validating: false,
								inputError: _this.validationExceptionText
							});
							if (_this.onValidationException) instance.invoke("onValidationException", e, instance);
							else {
								Console.warn("Unhandled validation exception:", e);
							}
						});
				} else {
					data.error = result;
				}
			}

			if (!data.error && state.inputError) data.error = state.inputError;
		};

		_proto.renderLabel = function renderLabel(context, instance, key) {
			if (instance.components.label) return getContent(instance.components.label.vdom);
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			throw new Error("Not implemented.");
		};

		_proto.renderHelp = function renderHelp(context, instance, key) {
			if (instance.components.help) return getContent(instance.components.help.render(context, key));
		};

		_proto.formatValue = function formatValue(context, _ref) {
			var data = _ref.data;
			return data.text || data.value;
		};

		_proto.renderValue = function renderValue(context, instance, key) {
			var text = this.formatValue(context, instance);

			if (text) {
				return VDOM$2.createElement(
					"span",
					{
						key: key,
						onMouseMove: function onMouseMove(e) {
							return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
						},
						onMouseLeave: function onMouseLeave(e) {
							return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
						}
					},
					text
				);
			}
		};

		_proto.renderContent = function renderContent(context, instance, key) {
			var content = this.renderValue.apply(this, arguments) || this.renderEmptyText.apply(this, arguments);
			return this.renderWrap(context, instance, key, content);
		};

		_proto.renderWrap = function renderWrap(context, instance, key, content) {
			var data = instance.data;
			var interactive = !data.viewMode && !data.disabled;
			return VDOM$2.createElement(
				"div",
				{
					key: key,
					className: data.classNames,
					style: data.style,
					onMouseDown: interactive ? stopPropagation : null,
					onTouchStart: interactive ? stopPropagation : null
				},
				content,
				this.labelPlacement && this.renderLabel(context, instance, "label")
			);
		};

		_proto.renderEmptyText = function renderEmptyText(context, _ref2, key) {
			var data = _ref2.data;
			return VDOM$2.createElement(
				"span",
				{
					key: key,
					className: this.CSS.element(this.baseClass, "empty-text")
				},
				data.emptyText || VDOM$2.createElement("span", null, "\xA0")
			);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			var content = !data.viewMode
				? this.renderInput(context, instance, key)
				: this.renderContent(context, instance, key);
			return {
				label: !this.labelPlacement && this.renderLabel(context, instance, key),
				content: content,
				helpSpacer: this.helpSpacer && instance.components.help ? " " : null,
				help: !this.helpPlacement && this.renderHelp(context, instance, key)
			};
		};

		_proto.handleKeyDown = function handleKeyDown(e, instance) {
			if (this.onKeyDown && instance.invoke("onKeyDown", e, instance) === false) return false;

			if (instance.data.tabOnEnterKey && e.keyCode === 13) {
				var target = e.target;
				setTimeout(function() {
					if (!instance.state.inputError) FocusManager.focusNext(target);
				}, 10);
			}
		};

		return Field;
	})(PureContainer);
Field.prototype.validationMode = "tooltip";
Field.prototype.visited = false;
Field.prototype.suppressErrorsUntilVisited = false;
Field.prototype.requiredText = "This field is required.";
Field.prototype.autoFocus = false;
Field.prototype.asterisk = false;
Field.prototype.validatingText = "Validation is in progress...";
Field.prototype.validationExceptionText = "Something went wrong during input validation. Check log for more details.";
Field.prototype.helpSpacer = true;
Field.prototype.trackFocus = false; //add cxs-focus on parent element

Field.prototype.labelPlacement = false;
Field.prototype.helpPlacement = false;
Field.prototype.styled = true;
Localization.registerPrototype("cx/widgets/Field", Field);
function getFieldTooltip(instance) {
	var widget = instance.widget,
		data = instance.data,
		state = instance.state;
	if (widget.errorTooltip && data.error && (!state || state.visited || !widget.suppressErrorsUntilVisited))
		return [
			instance,
			widget.errorTooltip,
			{
				data: {
					$error: data.error
				}
			}
		];
	return [instance, widget.tooltip];
}
function autoFocus(el, component) {
	var data = component.props.data || component.props.instance.data;
	if (el && el !== component.autoFocusEl && data.autoFocus && !isTouchEvent()) FocusManager.focus(el);
	component.autoFocusEl = el;
}

var TextField =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(TextField, _Field);

		function TextField() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = TextField.prototype;

		_proto.init = function init() {
			if (typeof this.hideClear !== "undefined") this.showClear = !this.hideClear;
			if (this.alwaysShowClear) this.showClear = true;

			_Field.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[
					this,
					{
						value: null,
						disabled: undefined,
						readOnly: undefined,
						enabled: undefined,
						placeholder: undefined,
						required: undefined,
						minLength: undefined,
						maxLength: undefined,
						icon: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			return VDOM$2.createElement(Input, {
				key: key,
				instance: instance,
				data: instance.data,
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help"))
			});
		};

		_proto.validate = function validate(context, instance) {
			_Field.prototype.validate.call(this, context, instance);

			var data = instance.data;

			if (!data.error && data.value) {
				if (this.validationRegExp && !this.validationRegExp.test(data.value)) data.error = this.validationErrorText;
				else if (typeof data.value === "string" && data.minLength != null && data.value.length < data.minLength)
					data.error = StringTemplate.format(this.minLengthValidationErrorText, data.minLength, data.value.length);
				else if (typeof data.value === "string" && data.maxLength != null && data.value.length > data.maxLength)
					data.error = StringTemplate.format(this.maxLengthValidationErrorText, data.maxLength, data.value.length);
			}
		};

		return TextField;
	})(Field);
TextField.prototype.baseClass = "textfield";
TextField.prototype.reactOn = "change input blur";
TextField.prototype.inputType = "text";
TextField.prototype.validationErrorText = "The entered value is not valid.";
TextField.prototype.minLengthValidationErrorText = "Enter {[{0}-{1}]} more character(s).";
TextField.prototype.maxLengthValidationErrorText = "Use {0} characters or fewer.";
TextField.prototype.suppressErrorsUntilVisited = true;
TextField.prototype.icon = null;
TextField.prototype.showClear = false;
TextField.prototype.alwaysShowClear = false;
TextField.prototype.keyboardShortcut = false;
Localization.registerPrototype("cx/widgets/TextField", TextField);

var Input =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(Input, _VDOM$Component);

		function Input(props) {
			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			_this.state = {
				focus: false
			};
			return _this;
		}

		var _proto2 = Input.prototype;

		_proto2.render = function render() {
			var _this2 = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				data = _this$props.data,
				label = _this$props.label,
				help = _this$props.help;
			var widget = instance.widget,
				state = instance.state;
			var CSS = widget.CSS,
				baseClass = widget.baseClass,
				suppressErrorsUntilVisited = widget.suppressErrorsUntilVisited;
			var icon =
				data.icon &&
				VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "left-icon"),
						onMouseDown: preventDefault,
						onClick: function onClick(e) {
							return _this2.onChange(e, "enter");
						}
					},
					Icon.render(data.icon, {
						className: CSS.element(baseClass, "icon")
					})
				);
			var insideButton;

			if (!data.readOnly && !data.disabled) {
				if (widget.showClear && (widget.alwaysShowClear || !data.required) && data.value != null)
					insideButton = VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "clear"),
							onMouseDown: function onMouseDown(e) {
								return e.preventDefault();
							},
							onClick: function onClick(e) {
								return _this2.onClearClick(e);
							}
						},
						VDOM$2.createElement(ClearIcon, {
							className: CSS.element(baseClass, "icon")
						})
					);
			}

			var empty = this.input ? !this.input.value : data.empty;
			return VDOM$2.createElement(
				"div",
				{
					className: CSS.expand(
						data.classNames,
						CSS.state({
							visited: state.visited,
							focus: this.state.focus,
							icon: !!icon,
							clear: insideButton != null,
							empty: empty && !data.placeholder,
							error: data.error && (state.visited || !suppressErrorsUntilVisited || !empty)
						})
					),
					style: data.style,
					onMouseDown: stopPropagation,
					onTouchStart: stopPropagation
				},
				VDOM$2.createElement(
					"input",
					_extends(
						{
							ref: function ref(el) {
								_this2.input = el;
							},
							className: CSS.element(baseClass, "input"),
							defaultValue: data.value,
							id: data.id,
							style: data.inputStyle,
							type: widget.inputType,
							disabled: data.disabled,
							readOnly: data.readOnly,
							tabIndex: data.tabIndex,
							placeholder: data.placeholder
						},
						data.inputAttrs,
						{
							onMouseMove: this.onMouseMove.bind(this),
							onMouseLeave: this.onMouseLeave.bind(this),
							onInput: function onInput(e) {
								return _this2.onChange(e, "input");
							},
							onChange: function onChange(e) {
								return _this2.onChange(e, "change");
							},
							onKeyDown: this.onKeyDown.bind(this),
							onFocus: this.onFocus.bind(this),
							onBlur: this.onBlur.bind(this),
							onClick: stopPropagation
						}
					)
				),
				insideButton,
				icon,
				label,
				help
			);
		};

		_proto2.onFocus = function onFocus() {
			var instance = this.props.instance;
			var widget = instance.widget;

			if (widget.trackFocus) {
				this.setState({
					focus: true
				});
			}
		};

		_proto2.onBlur = function onBlur(e) {
			if (this.state.focus)
				this.setState({
					focus: false
				});
			this.onChange(e, "blur");
		};

		_proto2.onClearClick = function onClearClick(e) {
			this.props.instance.set("value", null);
		};

		_proto2.onMouseMove = function onMouseMove(e) {
			tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(this.props.instance)));
		};

		_proto2.onMouseLeave = function onMouseLeave(e) {
			tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(this.props.instance)));
		};

		_proto2.componentDidMount = function componentDidMount() {
			tooltipParentDidMount.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
			autoFocus(this.input, this);
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			autoFocus(this.input, this);
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			tooltipParentWillUnmount(this.props.instance);
		};

		_proto2.onKeyDown = function onKeyDown(e) {
			var instance = this.props.instance;
			if (instance.widget.handleKeyDown(e, instance) === false) return;

			switch (e.keyCode) {
				case KeyCode.enter:
					this.onChange(e, "enter");
					break;

				case KeyCode.left:
				case KeyCode.right:
					e.stopPropagation();
					break;
			}
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			var data = props.instance.data;
			if (data.value != this.input.value) this.input.value = data.value || "";
			tooltipParentWillReceiveProps.apply(void 0, [this.input].concat(getFieldTooltip(props.instance)));
		};

		_proto2.onChange = function onChange(e, change) {
			var _this$props2 = this.props,
				instance = _this$props2.instance,
				data = _this$props2.data;

			if (change == "blur" || change == "enter") {
				instance.setState({
					visited: true
				});
			}

			var widget = instance.widget;

			if (widget.reactOn.indexOf(change) != -1) {
				var text = e.target.value;

				if (data.maxLength != null && text.length > data.maxLength) {
					text = text.substring(0, data.maxLength);
					this.input.value = text;
				} //it's important not to set the old value as it causes weird behavior if debounce is used

				var value = text || null;

				if (value !== data.value) {
					instance.set("value", value);
					if (value)
						instance.setState({
							visited: true
						});
				}
			}
		};

		return Input;
	})(VDOM$2.Component);

Widget.alias("textfield", TextField);

var SquareIcon = registerIcon(
	"square",
	function(props) {
		return VDOM$2.createElement(
			"svg",
			_extends({}, props, {
				viewBox: "0 0 64 64"
			}),
			VDOM$2.createElement("rect", {
				x: "12",
				y: "12",
				width: "40",
				height: "40",
				fill: "currentColor"
			})
		);
	},
	true
);

var Checkbox =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(Checkbox, _Field);

		function Checkbox() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = Checkbox.prototype;

		_proto.init = function init() {
			if (this.checked) this.value = this.checked;

			_Field.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[
					this,
					{
						value: !this.indeterminate ? false : undefined,
						text: undefined,
						readOnly: undefined,
						disabled: undefined,
						required: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.renderWrap = function renderWrap(context, instance, key, content) {
			var _this = this;

			var data = instance.data;
			return VDOM$2.createElement(
				"label",
				{
					key: key,
					className: data.classNames,
					onMouseDown: stopPropagation,
					onMouseMove: function onMouseMove(e) {
						return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
					},
					onMouseLeave: function onMouseLeave(e) {
						return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
					},
					onClick: function onClick(e) {
						_this.handleClick(e, instance);
					},
					style: data.style
				},
				content,
				this.labelPlacement && getContent(this.renderLabel(context, instance, "label"))
			);
		};

		_proto.validateRequired = function validateRequired(context, instance) {
			var data = instance.data;
			if (!data.value) return this.requiredText;
		};

		_proto.renderNativeCheck = function renderNativeCheck(context, instance) {
			var _this2 = this;

			var CSS = this.CSS,
				baseClass = this.baseClass;
			var data = instance.data;
			return VDOM$2.createElement(
				"input",
				_extends(
					{
						key: "input",
						className: CSS.element(baseClass, "checkbox"),
						id: data.id,
						type: "checkbox",
						checked: data.value || false,
						disabled: data.disabled
					},
					data.inputAttrs,
					{
						onClick: stopPropagation,
						onChange: function onChange(e) {
							_this2.handleChange(e, instance);
						}
					}
				)
			);
		};

		_proto.renderCheck = function renderCheck(context, instance) {
			return VDOM$2.createElement(CheckboxCmp, {
				key: "check",
				instance: instance,
				data: instance.data
			});
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			var data = instance.data;
			var text = data.text || this.renderChildren(context, instance);
			var CSS = this.CSS,
				baseClass = this.baseClass;
			return this.renderWrap(context, instance, key, [
				this.native ? this.renderNativeCheck(context, instance) : this.renderCheck(context, instance),
				text
					? VDOM$2.createElement(
							"div",
							{
								key: "text",
								className: CSS.element(baseClass, "text")
							},
							text
						)
					: VDOM$2.createElement(
							"span",
							{
								key: "baseline",
								className: CSS.element(baseClass, "baseline")
							},
							"\xA0"
						)
			]);
		};

		_proto.formatValue = function formatValue(context, instance) {
			var data = instance.data;
			return data.value && (data.text || this.renderChildren(context, instance));
		};

		_proto.handleClick = function handleClick(e, instance) {
			if (this.native) e.stopPropagation();
			else {
				var el = document.getElementById(instance.data.id);
				if (el) el.focus();

				if (!instance.data.viewMode) {
					e.preventDefault();
					e.stopPropagation();
					this.handleChange(e, instance, !instance.data.value);
				}
			}
		};

		_proto.handleChange = function handleChange(e, instance, checked) {
			var data = instance.data;
			if (data.readOnly || data.disabled || data.viewMode) return;
			instance.set("value", checked != null ? checked : e.target.checked);
		};

		return Checkbox;
	})(Field);
Checkbox.prototype.baseClass = "checkbox";
Checkbox.prototype.native = false;
Checkbox.prototype.indeterminate = false;
Checkbox.prototype.unfocusable = false;
Widget.alias("checkbox", Checkbox);

var CheckboxCmp =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(CheckboxCmp, _VDOM$Component);

		function CheckboxCmp(props) {
			var _this3;

			_this3 = _VDOM$Component.call(this, props) || this;
			_this3.state = {
				value: props.data.value
			};
			return _this3;
		}

		var _proto2 = CheckboxCmp.prototype;

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			this.setState({
				value: props.data.value
			});
		};

		_proto2.render = function render() {
			var _this$props = this.props,
				instance = _this$props.instance,
				data = _this$props.data;
			var widget = instance.widget;
			var baseClass = widget.baseClass,
				CSS = widget.CSS;
			var check = false;
			if (this.state.value == null && widget.indeterminate) check = "indeterminate";
			else if (this.state.value) check = "check";
			return VDOM$2.createElement(
				"span",
				{
					key: "check",
					tabIndex: widget.unfocusable || data.disabled ? null : data.tabIndex || 0,
					className: CSS.element(baseClass, "input", {
						checked: check
					}),
					style: CSS.parseStyle(data.inputStyle),
					id: data.id,
					onClick: this.onClick.bind(this),
					onKeyDown: this.onKeyDown.bind(this)
				},
				check == "check" &&
					VDOM$2.createElement(CheckIcon, {
						className: CSS.element(baseClass, "input-check")
					}),
				check == "indeterminate" &&
					VDOM$2.createElement(SquareIcon, {
						className: CSS.element(baseClass, "input-check")
					})
			);
		};

		_proto2.onClick = function onClick(e) {
			var _this$props2 = this.props,
				instance = _this$props2.instance,
				data = _this$props2.data;
			var widget = instance.widget;

			if (!data.disabled && !data.readOnly) {
				e.stopPropagation();
				e.preventDefault();
				this.setState({
					value: !this.state.value
				});
				widget.handleChange(e, instance, !this.state.value);
			}
		};

		_proto2.onKeyDown = function onKeyDown(e) {
			var instance = this.props.instance;
			if (instance.widget.handleKeyDown(e, instance) === false) return;

			switch (e.keyCode) {
				case KeyCode.space:
					this.onClick(e);
					break;
			}
		};

		return CheckboxCmp;
	})(VDOM$2.Component);

var Radio =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(Radio, _Field);

		function Radio() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = Radio.prototype;

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[
					this,
					{
						value: undefined,
						selection: undefined,
						option: undefined,
						disabled: undefined,
						readOnly: undefined,
						required: undefined,
						text: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.init = function init() {
			if (this.selection) this.value = this.selection;

			_Field.prototype.init.call(this);
		};

		_proto.formatValue = function formatValue(context, _ref) {
			var data = _ref.data;
			return data.text;
		};

		_proto.prepareData = function prepareData(context, instance) {
			_Field.prototype.prepareData.apply(this, arguments);

			var data = instance.data;
			data.checked = data.value === data.option;
			if (this.default && isUndefined(data.value)) instance.set("value", data.option);
		};

		_proto.renderValue = function renderValue(context, _ref2) {
			var data = _ref2.data;
			if (data.value === data.option) return _Field.prototype.renderValue.apply(this, arguments);
			return null;
		};

		_proto.renderWrap = function renderWrap(context, instance, key, content) {
			var _this = this;

			var data = instance.data;
			return VDOM$2.createElement(
				"label",
				{
					key: key,
					className: data.classNames,
					style: data.style,
					onMouseDown: stopPropagation,
					onTouchStart: stopPropagation,
					onMouseMove: function onMouseMove(e) {
						return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
					},
					onMouseLeave: function onMouseLeave(e) {
						return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
					},
					onClick: function onClick(e) {
						_this.handleClick(e, instance);
					},
					htmlFor: data.id
				},
				content,
				this.labelPlacement && getContent(this.renderLabel(context, instance, "label"))
			);
		};

		_proto.renderNativeCheck = function renderNativeCheck(context, instance) {
			var _this2 = this;

			var CSS = this.CSS,
				baseClass = this.baseClass;
			var data = instance.data;
			return VDOM$2.createElement(
				"input",
				_extends(
					{
						key: "input",
						className: CSS.element(baseClass, "radio"),
						id: data.id,
						type: "radio",
						checked: data.checked,
						disabled: data.disabled
					},
					data.inputAttrs,
					{
						onClick: stopPropagation,
						onChange: function onChange(e) {
							_this2.handleChange(e, instance);
						}
					}
				)
			);
		};

		_proto.renderCheck = function renderCheck(context, instance) {
			return VDOM$2.createElement(RadioCmp, {
				key: "check",
				instance: instance,
				data: instance.data
			});
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			var data = instance.data;
			var text = data.text || this.renderChildren(context, instance);
			var CSS = this.CSS,
				baseClass = this.baseClass;
			return this.renderWrap(context, instance, key, [
				this.native ? this.renderNativeCheck(context, instance) : this.renderCheck(context, instance),
				text
					? VDOM$2.createElement(
							"div",
							{
								key: "text",
								className: CSS.element(baseClass, "text")
							},
							text
						)
					: VDOM$2.createElement(
							"span",
							{
								key: "baseline",
								className: CSS.element(baseClass, "baseline")
							},
							"\xA0"
						)
			]);
		};

		_proto.handleClick = function handleClick(e, instance) {
			if (this.native) e.stopPropagation();
			else {
				var el = document.getElementById(instance.data.id);
				if (el) el.focus();
				e.preventDefault();
				this.handleChange(e, instance);
			}
		};

		_proto.handleChange = function handleChange(e, instance) {
			var data = instance.data;
			if (data.disabled || data.readOnly || data.viewMode) return;
			instance.set("value", data.option);
		};

		return Radio;
	})(Field);
Radio.prototype.baseClass = "radio";
Radio.prototype.native = false;
Radio.prototype.default = false;
Widget.alias("radio", Radio);

var RadioCmp =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(RadioCmp, _VDOM$Component);

		function RadioCmp(props) {
			var _this3;

			_this3 = _VDOM$Component.call(this, props) || this;
			_this3.state = {
				value: props.data.checked
			};
			return _this3;
		}

		var _proto2 = RadioCmp.prototype;

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			this.setState({
				value: props.data.checked
			});
		};

		_proto2.render = function render() {
			var _this$props = this.props,
				instance = _this$props.instance,
				data = _this$props.data;
			var widget = instance.widget;
			var baseClass = widget.baseClass,
				CSS = widget.CSS;
			return VDOM$2.createElement("span", {
				key: "check",
				tabIndex: data.disabled ? null : data.tabIndex || 0,
				className: CSS.element(baseClass, "input", {
					checked: this.state.value
				}),
				style: CSS.parseStyle(data.inputStyle),
				id: data.id,
				onClick: this.onClick.bind(this),
				onKeyDown: this.onKeyDown.bind(this)
			});
		};

		_proto2.onClick = function onClick(e) {
			var _this$props2 = this.props,
				instance = _this$props2.instance,
				data = _this$props2.data;
			var widget = instance.widget;

			if (!data.disabled && !data.readOnly) {
				e.stopPropagation();
				e.preventDefault();
				widget.handleChange(e, instance);
			}
		};

		_proto2.onKeyDown = function onKeyDown(e) {
			var instance = this.props.instance;
			if (instance.widget.handleKeyDown(e, instance) === false) return;

			switch (e.keyCode) {
				case KeyCode.space:
					this.onClick(e);
					break;
			}
		};

		return RadioCmp;
	})(VDOM$2.Component);

var Select =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(Select, _Field);

		function Select() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = Select.prototype;

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[
					this,
					{
						value: undefined,
						disabled: undefined,
						enabled: undefined,
						required: undefined,
						placeholder: undefined,
						icon: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.init = function init() {
			if (isDefined(this.hideClear)) this.showClear = !this.hideClear;
			if (this.alwaysShowClear) this.showClear = true;

			_Field.prototype.init.call(this);
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			var _this = this;

			return VDOM$2.createElement(
				SelectComponent,
				{
					key: key,
					instance: instance,
					multiple: this.multiple,
					select: function select(v) {
						return _this.select(v, instance);
					},
					label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
					help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help"))
				},
				this.renderChildren(context, instance)
			);
		};

		_proto.convert = function convert(value) {
			if (value == this.nullString) return null;
			if (value == "true") return true;
			if (value == "false") return false;
			if (value.match(/^\d+(\.\d+)?$/)) return Number(value);
			return value;
		};

		_proto.select = function select(value, instance) {
			if (this.convertValues && value != null) value = this.convert(value);
			instance.set("value", value);
		};

		_proto.add = function add(item) {
			if (isString(item)) return;

			_Field.prototype.add.call(this, item);
		};

		return Select;
	})(Field);
Select.prototype.baseClass = "select";
Select.prototype.multiple = false;
Select.prototype.convertValues = true;
Select.prototype.nullString = "";
Select.prototype.suppressErrorsUntilVisited = true;
Select.prototype.showClear = true;
Select.prototype.alwaysShowClear = false;
Select.prototype.icon = null;
Widget.alias("select", Select);
Localization.registerPrototype("cx/widgets/Select", Select);

var SelectComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(SelectComponent, _VDOM$Component);

		function SelectComponent(props) {
			var _this2;

			_this2 = _VDOM$Component.call(this, props) || this;
			_this2.state = {
				visited: false,
				focus: false
			};
			return _this2;
		}

		var _proto2 = SelectComponent.prototype;

		_proto2.render = function render() {
			var _this3 = this;

			var _this$props = this.props,
				multiple = _this$props.multiple,
				select = _this$props.select,
				instance = _this$props.instance,
				label = _this$props.label,
				help = _this$props.help;
			var data = instance.data,
				widget = instance.widget,
				state = instance.state;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var icon =
				data.icon &&
				VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "left-icon")
					},
					Icon.render(data.icon, {
						className: CSS.element(baseClass, "icon")
					})
				);
			var insideButton,
				readOnly = data.disabled || data.readOnly;

			if (
				widget.showClear &&
				!readOnly &&
				!this.props.multiple &&
				(widget.alwaysShowClear || !data.required) &&
				data.placeholder &&
				data.value != null
			) {
				insideButton = VDOM$2.createElement(
					"div",
					{
						onMouseDown: preventDefault,
						onClick: function onClick(e) {
							return _this3.onClearClick(e);
						},
						className: CSS.element(baseClass, "clear")
					},
					VDOM$2.createElement(ClearIcon, {
						className: CSS.element(baseClass, "icon")
					})
				);
			} else {
				insideButton = VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "tool")
					},
					VDOM$2.createElement(DropdownIcon, {
						className: CSS.element(baseClass, "icon")
					})
				);
			}

			var placeholder;

			if (data.placeholder) {
				placeholder = VDOM$2.createElement(
					"option",
					{
						value: widget.nullString,
						className: CSS.element(baseClass, "placeholder"),
						disabled: true,
						hidden: true
					},
					data.placeholder
				);
			}

			return VDOM$2.createElement(
				"div",
				{
					className: CSS.expand(
						data.classNames,
						CSS.state({
							visited: state.visited,
							icon: data.icon,
							focus: this.state.focus,
							error: state.visited && data.error,
							empty: data.empty && !data.placeholder
						})
					),
					style: data.style,
					onMouseDown: stopPropagation,
					onTouchStart: stopPropagation
				},
				VDOM$2.createElement(
					"select",
					_extends(
						{
							id: data.id,
							ref: function ref(el) {
								_this3.select = el;
							},
							className: CSS.element(baseClass, "select"),
							style: data.inputStyle,
							value: data.value == null ? widget.nullString : String(data.value),
							multiple: multiple,
							disabled: data.disabled,
							tabIndex: data.tabIndex
						},
						data.inputAttrs,
						{
							onBlur: this.onBlur.bind(this),
							onFocus: function onFocus(e) {
								return _this3.onFocus();
							},
							onKeyDown: this.onKeyDown.bind(this),
							onChange: function onChange(e) {
								e.preventDefault();
								select(e.target.value);
							},
							onMouseMove: function onMouseMove(e) {
								return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
							},
							onMouseLeave: function onMouseLeave(e) {
								return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
							}
						}
					),
					placeholder,
					this.props.children
				),
				insideButton,
				icon,
				label,
				help
			);
		};

		_proto2.onBlur = function onBlur() {
			this.props.instance.setState({
				visited: true
			});
			if (this.state.focus)
				this.setState({
					focus: false
				});
		};

		_proto2.onFocus = function onFocus() {
			var instance = this.props.instance;
			var widget = instance.widget;

			if (widget.trackFocus) {
				this.setState({
					focus: true
				});
			}
		};

		_proto2.onClearClick = function onClearClick(e) {
			e.preventDefault();
			e.stopPropagation();
			var instance = this.props.instance;
			var widget = instance.widget;
			instance.set("value", widget.emptyValue);
		};

		_proto2.onKeyDown = function onKeyDown(e) {
			switch (e.keyCode) {
				case KeyCode.up:
				case KeyCode.down:
					e.stopPropagation();
					break;
			}
		};

		_proto2.componentDidMount = function componentDidMount() {
			var select = this.props.select;
			select(this.select.value);
			tooltipParentDidMount.apply(void 0, [this.select].concat(getFieldTooltip(this.props.instance)));
			autoFocus(this.select, this);
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			autoFocus(this.select, this);
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			tooltipParentWillReceiveProps.apply(void 0, [this.select].concat(getFieldTooltip(props.instance)));
		};

		return SelectComponent;
	})(VDOM$2.Component);

var Option =
	/*#__PURE__*/
	(function(_HtmlElement) {
		_inheritsLoose(Option, _HtmlElement);

		function Option() {
			return _HtmlElement.apply(this, arguments) || this;
		}

		var _proto3 = Option.prototype;

		_proto3.declareData = function declareData() {
			var _HtmlElement$prototyp;

			(_HtmlElement$prototyp = _HtmlElement.prototype.declareData).call.apply(
				_HtmlElement$prototyp,
				[
					this,
					{
						value: undefined,
						disabled: undefined,
						enabled: undefined,
						selected: undefined,
						text: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto3.prepareData = function prepareData(context, _ref) {
			var data = _ref.data;

			_HtmlElement.prototype.prepareData.apply(this, arguments);

			if (data.value != null) data.value = data.value.toString();
		};

		_proto3.render = function render(context, instance, key) {
			var data = instance.data;
			return VDOM$2.createElement(
				"option",
				{
					key: key,
					value: data.value
				},
				data.text || this.renderChildren(context, instance)
			);
		};

		return Option;
	})(HtmlElement);
Widget.alias("option", Option);

var culture = "en";
var cultureCache = {};
var defaultCurrency = "USD";

var dateEncoding = function dateEncoding(date) {
	return date.toISOString();
};

var Culture =
	/*#__PURE__*/
	(function() {
		function Culture() {}

		Culture.setCulture = function setCulture(cultureCode) {
			culture = cultureCode;
			cultureCache = {};
			Localization.setCulture(cultureCode);
			this.invalidateCache();
		};

		Culture.setDefaultCurrency = function setDefaultCurrency(currencyCode) {
			defaultCurrency = currencyCode;
			this.invalidateCache();
		};

		Culture.invalidateCache = function invalidateCache() {
			GlobalCacheIdentifier.change();
			invalidateExpressionCache();
			invalidateStringTemplateCache();
		};

		Culture.getNumberCulture = function getNumberCulture() {
			if (!cultureCache.numberCulture) cultureCache.numberCulture = new NumberCulture(culture);
			return cultureCache.numberCulture;
		};

		Culture.getDateTimeCulture = function getDateTimeCulture() {
			if (!cultureCache.dateCulture) cultureCache.dateCulture = new DateTimeCulture(culture);
			return cultureCache.dateCulture;
		};

		Culture.getDefaultDateEncoding = function getDefaultDateEncoding() {
			return dateEncoding;
		};

		Culture.setDefaultDateEncoding = function setDefaultDateEncoding(encoding) {
			dateEncoding = encoding;
		};

		_createClass(Culture, null, [
			{
				key: "defaultCurrency",
				get: function get() {
					return defaultCurrency;
				}
			},
			{
				key: "culture",
				get: function get() {
					return culture;
				}
			}
		]);

		return Culture;
	})();

function zeroTime(d) {
	return new Date(d.getFullYear(), d.getMonth(), d.getDate());
}

function dateDiff(d1, d2) {
	return d1.getTime() - d2.getTime();
}

function lowerBoundCheck(date, minDate, exclusive) {
	if (exclusive === void 0) {
		exclusive = false;
	}

	var d = dateDiff(date, minDate);
	return d > 0 || (d == 0 && !exclusive);
}

function upperBoundCheck(date, maxDate, exclusive) {
	if (exclusive === void 0) {
		exclusive = false;
	}

	var d = dateDiff(date, maxDate);
	return d < 0 || (d == 0 && !exclusive);
}

function sameDate(d1, d2) {
	return d1.getDate() == d2.getDate() && d1.getMonth() == d2.getMonth() && d1.getYear() == d2.getYear();
}

var ForwardIcon = registerIcon(
	"forward",
	function(props) {
		return VDOM$2.createElement(
			"svg",
			_extends({}, props, {
				viewBox: "0 0 20 20"
			}),
			VDOM$2.createElement("path", {
				fill: "currentColor",
				strokeWidth: "0",
				stroke: "currentColor",
				d: "M10.15 15.5L14.5 10l-4.33-5.47-.65.47 3.98 5-4 5z"
			}),
			VDOM$2.createElement("path", {
				fill: "currentColor",
				strokeWidth: "0",
				stroke: "currentColor",
				d: "M6.15 15.5L10.5 10 6.17 4.53 5.52 5l3.98 5-4 5z"
			})
		);
	},
	true
);

var Format$1 = Format;
var cultureSensitiveFormatsRegistered = false;
function enableCultureSensitiveFormatting() {
	if (cultureSensitiveFormatsRegistered) return;
	cultureSensitiveFormatsRegistered = true;
	Format.registerFactory(["number", "n"], function(format, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();
		var formatter = culture.getFormatter(resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits));
		return function(value) {
			return formatter.format(value);
		};
	});
	Format.registerFactory("currency", function(format, currency, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();
		currency = currency || Culture.defaultCurrency;
		var formatter = culture.getFormatter(
			_objectSpread(
				{
					style: "currency",
					currency: currency
				},
				resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits)
			)
		);
		return function(value) {
			return formatter.format(value);
		};
	});
	Format.registerFactory(["percentage", "p", "%"], function(format, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();
		var formatter = culture.getFormatter(
			_objectSpread(
				{
					style: "percent"
				},
				resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits)
			)
		);
		return function(value) {
			return formatter.format(value);
		};
	});
	Format.registerFactory(["percentSign", "ps"], function(format, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();
		var formatter = culture.getFormatter(
			_objectSpread(
				{
					style: "percent"
				},
				resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits)
			)
		);
		return function(value) {
			return formatter.format(value / 100);
		};
	});
	Format.registerFactory(["date", "d"], function() {
		var culture = Culture.getDateTimeCulture();
		var formatter = culture.getFormatter();
		return function(value) {
			return formatter.format(new Date(value));
		};
	});
	Format.registerFactory(["time", "t"], function() {
		var culture = Culture.getDateTimeCulture();
		var formatter = culture.getFormatter({
			hour: "numeric",
			minute: "numeric",
			second: "numeric"
		});
		return function(value) {
			return formatter.format(new Date(value));
		};
	});
	Format.registerFactory(["datetime", "dt"], function(fmt, format) {
		if (format === void 0) {
			format = "yyyyMd hhmm";
		}

		var culture = Culture.getDateTimeCulture();
		var formatter = culture.getFormatter(format);
		return function(value) {
			return formatter.format(new Date(value));
		};
	});
	GlobalCacheIdentifier.change();
}

function monthStart(d) {
	return new Date(d.getFullYear(), d.getMonth(), 1);
}

var Calendar =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(Calendar, _Field);

		function Calendar() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = Calendar.prototype;

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[
					this,
					{
						value: undefined,
						refDate: undefined,
						disabled: undefined,
						minValue: undefined,
						minExclusive: undefined,
						maxValue: undefined,
						maxExclusive: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.prepareData = function prepareData(context, _ref) {
			var data = _ref.data;
			data.stateMods = {
				disabled: data.disabled
			};

			if (data.value) {
				var d = new Date(data.value);

				if (!isNaN(d.getTime())) {
					data.date = zeroTime(d);
				}
			}

			if (data.refDate) data.refDate = zeroTime(new Date(data.refDate));
			if (data.maxValue) data.maxValue = zeroTime(new Date(data.maxValue));
			if (data.minValue) data.minValue = zeroTime(new Date(data.minValue));

			_Field.prototype.prepareData.apply(this, arguments);
		};

		_proto.validate = function validate(context, instance) {
			_Field.prototype.validate.call(this, context, instance);

			var data = instance.data;

			if (!data.error && data.date) {
				var d;

				if (data.maxValue) {
					d = dateDiff(data.date, data.maxValue);
					if (d > 0) data.error = StringTemplate.format(this.maxValueErrorText, data.maxValue);
					else if (d == 0 && data.maxExclusive)
						data.error = StringTemplate.format(this.maxExclusiveErrorText, data.maxValue);
				}

				if (data.minValue) {
					d = dateDiff(data.date, data.minValue);
					if (d < 0) data.error = StringTemplate.format(this.minValueErrorText, data.minValue);
					else if (d == 0 && data.minExclusive)
						data.error = StringTemplate.format(this.minExclusiveErrorText, data.minValue);
				}
			}
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			var _this = this;

			return VDOM$2.createElement(CalendarCmp, {
				key: key,
				instance: instance,
				handleSelect: function handleSelect(e, date) {
					return _this.handleSelect(e, instance, date);
				}
			});
		};

		_proto.handleSelect = function handleSelect(e, instance, date) {
			var store = instance.store,
				data = instance.data,
				widget = instance.widget;
			e.stopPropagation();
			if (data.disabled) return;
			if (!validationCheck(date, data)) return;
			if (this.onBeforeSelect && instance.invoke("onBeforeSelect", e, instance, date) === false) return;

			if (widget.partial) {
				var mixed = new Date(data.value);

				if (data.value && !isNaN(mixed)) {
					mixed.setFullYear(date.getFullYear());
					mixed.setMonth(date.getMonth());
					mixed.setDate(date.getDate());
					date = mixed;
				}
			}

			var encode = widget.encoding || Culture.getDefaultDateEncoding();
			instance.set("value", encode(date));
			if (this.onSelect) instance.invoke("onSelect", e, instance, date);
		};

		return Calendar;
	})(Field);
Calendar.prototype.baseClass = "calendar";
Calendar.prototype.highlightToday = true;
Calendar.prototype.maxValueErrorText = "Select a date not after {0:d}.";
Calendar.prototype.maxExclusiveErrorText = "Select a date before {0:d}.";
Calendar.prototype.minValueErrorText = "Select a date not before {0:d}.";
Calendar.prototype.minExclusiveErrorText = "Select a date after {0:d}.";
Calendar.prototype.suppressErrorsUntilVisited = false;
Localization.registerPrototype("cx/widgets/Calendar", Calendar);

var validationCheck = function validationCheck(date, data) {
	if (data.maxValue && !upperBoundCheck(date, data.maxValue, data.maxExclusive)) return false;
	if (data.minValue && !lowerBoundCheck(date, data.minValue, data.minExclusive)) return false;
	return true;
};

var CalendarCmp =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(CalendarCmp, _VDOM$Component);

		function CalendarCmp(props) {
			var _this2;

			_this2 = _VDOM$Component.call(this, props) || this;
			var data = props.instance.data;
			var refDate = data.refDate ? data.refDate : data.date || zeroTime(new Date());
			_this2.state = Object.assign(
				{
					hover: false,
					focus: false,
					cursor: zeroTime(data.date || refDate)
				},
				_this2.getPage(refDate)
			);
			_this2.handleMouseMove = _this2.handleMouseMove.bind(_assertThisInitialized(_assertThisInitialized(_this2)));
			_this2.handleMouseDown = _this2.handleMouseDown.bind(_assertThisInitialized(_assertThisInitialized(_this2)));
			return _this2;
		}

		var _proto2 = CalendarCmp.prototype;

		_proto2.getPage = function getPage(refDate) {
			refDate = monthStart(refDate); //make a copy

			var startDate = new Date(refDate);
			startDate.setDate(1 - startDate.getDay());
			var endDate = new Date(refDate);
			endDate.setMonth(refDate.getMonth() + 1);
			endDate.setDate(endDate.getDate() - 1);
			endDate.setDate(endDate.getDate() + 6 - endDate.getDay());
			return {
				refDate: refDate,
				startDate: startDate,
				endDate: endDate
			};
		};

		_proto2.moveCursor = function moveCursor(e, date, options) {
			if (options === void 0) {
				options = {};
			}

			e.preventDefault();
			e.stopPropagation();
			date = zeroTime(date);
			if (date.getTime() == this.state.cursor.getTime()) return;
			var refDate = this.state.refDate;
			if (options.movePage || date < this.state.startDate || date > this.state.endDate) refDate = date;
			this.setState(
				_objectSpread({}, this.getPage(refDate), {
					cursor: date
				})
			);
		};

		_proto2.move = function move(e, period, delta) {
			e.preventDefault();
			e.stopPropagation();
			var refDate = this.state.refDate;

			switch (period) {
				case "y":
					refDate.setFullYear(refDate.getFullYear() + delta);
					break;

				case "m":
					refDate.setMonth(refDate.getMonth() + delta);
					break;
			}

			var page = this.getPage(refDate);
			if (this.state.cursor < page.startDate) page.cursor = page.startDate;
			else if (this.state.cursor > page.endDate) page.cursor = page.endDate;
			this.setState(page);
		};

		_proto2.handleKeyPress = function handleKeyPress(e) {
			var cursor = new Date(this.state.cursor);

			switch (e.keyCode) {
				case KeyCode.enter:
					this.props.handleSelect(e, this.state.cursor);
					break;

				case KeyCode.left:
					cursor.setDate(cursor.getDate() - 1);
					this.moveCursor(e, cursor);
					break;

				case KeyCode.right:
					cursor.setDate(cursor.getDate() + 1);
					this.moveCursor(e, cursor);
					break;

				case KeyCode.up:
					cursor.setDate(cursor.getDate() - 7);
					this.moveCursor(e, cursor);
					break;

				case KeyCode.down:
					cursor.setDate(cursor.getDate() + 7);
					this.moveCursor(e, cursor);
					break;

				case KeyCode.pageUp:
					cursor.setMonth(cursor.getMonth() - 1);
					this.moveCursor(e, cursor, {
						movePage: true
					});
					break;

				case KeyCode.pageDown:
					cursor.setMonth(cursor.getMonth() + 1);
					this.moveCursor(e, cursor, {
						movePage: true
					});
					break;

				case KeyCode.home:
					cursor.setDate(1);
					this.moveCursor(e, cursor, {
						movePage: true
					});
					break;

				case KeyCode.end:
					cursor.setMonth(cursor.getMonth() + 1);
					cursor.setDate(0);
					this.moveCursor(e, cursor, {
						movePage: true
					});
					break;

				default:
					var instance = this.props.instance;
					var widget = instance.widget;
					if (widget.onKeyDown) instance.invoke("onKeyDown", e, instance);
					break;
			}
		};

		_proto2.handleWheel = function handleWheel(e) {
			e.preventDefault();
			e.stopPropagation();
			var cursor = new Date(this.state.cursor);

			if (e.deltaY < 0) {
				cursor.setMonth(cursor.getMonth() - 1);
				this.moveCursor(e, cursor, {
					movePage: true
				});
			} else if (e.deltaY > 0) {
				cursor.setMonth(cursor.getMonth() + 1);
				this.moveCursor(e, cursor, {
					movePage: true
				});
			}
		};

		_proto2.handleBlur = function handleBlur(e) {
			FocusManager.nudge();
			var instance = this.props.instance;
			var widget = instance.widget;
			if (widget.onBlur) instance.invoke("onBlur", e, instance);
			this.setState({
				focus: false
			});
		};

		_proto2.handleFocus = function handleFocus(e) {
			oneFocusOut(this, this.el, this.handleFocusOut.bind(this));
			this.setState({
				focus: true
			});
		};

		_proto2.handleFocusOut = function handleFocusOut() {
			var instance = this.props.instance;
			var widget = instance.widget;
			if (widget.onFocusOut) instance.invoke("onFocusOut", null, instance);
		};

		_proto2.handleMouseLeave = function handleMouseLeave(e) {
			tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(this.props.instance)));
			this.setState({
				hover: false
			});
		};

		_proto2.handleMouseEnter = function handleMouseEnter(e) {
			this.setState({
				hover: true
			});
		};

		_proto2.handleMouseMove = function handleMouseMove(e) {
			this.moveCursor(e, readDate(e.target.dataset));
		};

		_proto2.handleMouseDown = function handleMouseDown(e) {
			this.props.handleSelect(e, readDate(e.target.dataset));
		};

		_proto2.componentDidMount = function componentDidMount() {
			//calendar doesn't bring up keyboard so it's ok to focus it even on mobile
			if (this.props.instance.widget.autoFocus) this.el.focus();
			tooltipParentDidMount.apply(void 0, [this.el].concat(getFieldTooltip(this.props.instance)));
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			var data = props.instance.data;
			if (data.date)
				this.setState(
					_objectSpread({}, this.getPage(data.date), {
						value: data.date
					})
				);
			tooltipParentWillReceiveProps.apply(void 0, [this.el].concat(getFieldTooltip(props.instance)));
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			offFocusOut(this);
			tooltipParentWillUnmount(this.props.instance);
		};

		_proto2.render = function render() {
			var _this3 = this;

			var _this$props$instance = this.props.instance,
				data = _this$props$instance.data,
				widget = _this$props$instance.widget;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var refDate = this.state.refDate;
			var month = refDate.getMonth();
			var year = refDate.getFullYear();
			var startDate = new Date(year, month, 1);
			startDate.setDate(1 - startDate.getDay());
			var weeks = [];
			var date = startDate;
			var today = zeroTime(new Date());

			while (date < refDate || date.getMonth() == month) {
				var days = [];

				for (var i = 0; i < 7; i++) {
					var unselectable = !validationCheck(date, data);
					var classNames = CSS.state({
						outside: month != date.getMonth(),
						unselectable: unselectable,
						selected: data.date && sameDate(data.date, date),
						cursor: (this.state.hover || this.state.focus) && this.state.cursor && sameDate(this.state.cursor, date),
						today: widget.highlightToday && sameDate(date, today)
					});
					var dateInst = new Date(date);
					days.push(
						VDOM$2.createElement(
							"td",
							{
								key: i,
								className: classNames,
								"data-year": dateInst.getFullYear(),
								"data-month": dateInst.getMonth() + 1,
								"data-date": dateInst.getDate(),
								onMouseMove: unselectable ? null : this.handleMouseMove,
								onMouseDown: unselectable ? null : this.handleMouseDown
							},
							date.getDate()
						)
					);
					date.setDate(date.getDate() + 1);
				}

				weeks.push(
					VDOM$2.createElement(
						"tr",
						{
							key: weeks.length,
							className: CSS.element(baseClass, "week")
						},
						VDOM$2.createElement("td", null),
						days,
						VDOM$2.createElement("td", null)
					)
				);
			}

			var culture = Culture.getDateTimeCulture();
			var monthNames = culture.getMonthNames("long");
			var dayNames = culture.getWeekdayNames("short").map(function(x) {
				return x.substr(0, 2);
			});
			return VDOM$2.createElement(
				"div",
				{
					className: data.classNames,
					tabIndex: data.disabled ? null : data.tabIndex || 0,
					onKeyDown: function onKeyDown(e) {
						return _this3.handleKeyPress(e);
					},
					onMouseDown: function onMouseDown(e) {
						return e.stopPropagation();
					},
					ref: function ref(el) {
						_this3.el = el;
					},
					onMouseMove: function onMouseMove(e) {
						return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(_this3.props.instance)));
					},
					onMouseLeave: function onMouseLeave(e) {
						return _this3.handleMouseLeave(e);
					},
					onMouseEnter: function onMouseEnter(e) {
						return _this3.handleMouseEnter(e);
					},
					onWheel: function onWheel(e) {
						return _this3.handleWheel(e);
					},
					onFocus: function onFocus(e) {
						return _this3.handleFocus(e);
					},
					onBlur: function onBlur(e) {
						return _this3.handleBlur(e);
					}
				},
				VDOM$2.createElement(
					"table",
					null,
					VDOM$2.createElement(
						"thead",
						null,
						VDOM$2.createElement(
							"tr",
							{
								key: "h",
								className: CSS.element(baseClass, "header")
							},
							VDOM$2.createElement("td", null),
							VDOM$2.createElement(
								"td",
								{
									onClick: function onClick(e) {
										return _this3.move(e, "y", -1);
									}
								},
								VDOM$2.createElement(ForwardIcon, {
									className: CSS.element(baseClass, "icon-prev-year")
								})
							),
							VDOM$2.createElement(
								"td",
								{
									onClick: function onClick(e) {
										return _this3.move(e, "m", -1);
									}
								},
								VDOM$2.createElement(DropdownIcon, {
									className: CSS.element(baseClass, "icon-prev-month")
								})
							),
							VDOM$2.createElement(
								"th",
								{
									className: CSS.element(baseClass, "display"),
									colSpan: "3"
								},
								monthNames[month],
								VDOM$2.createElement("br", null),
								year
							),
							VDOM$2.createElement(
								"td",
								{
									onClick: function onClick(e) {
										return _this3.move(e, "m", +1);
									}
								},
								VDOM$2.createElement(DropdownIcon, {
									className: CSS.element(baseClass, "icon-next-month")
								})
							),
							VDOM$2.createElement(
								"td",
								{
									onClick: function onClick(e) {
										return _this3.move(e, "y", +1);
									}
								},
								VDOM$2.createElement(ForwardIcon, {
									className: CSS.element(baseClass, "icon-next-year")
								})
							),
							VDOM$2.createElement("td", null)
						),
						VDOM$2.createElement(
							"tr",
							{
								key: "d",
								className: CSS.element(baseClass, "day-names")
							},
							VDOM$2.createElement("td", null),
							dayNames.map(function(name, i) {
								return VDOM$2.createElement(
									"th",
									{
										key: i
									},
									name
								);
							}),
							VDOM$2.createElement("td", null)
						)
					),
					VDOM$2.createElement("tbody", null, weeks)
				)
			);
		};

		return CalendarCmp;
	})(VDOM$2.Component);

var readDate = function readDate(ds) {
	return new Date(Number(ds.year), Number(ds.month) - 1, Number(ds.date));
};

Widget.alias("calendar", Calendar);

function escapeSpecialRegexCharacters(s) {
	return s.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}

function getSearchQueryPredicate(query, options) {
	if (!query)
		return function() {
			return true;
		};
	var terms = query.split(" ").filter(Boolean);
	if (terms.length == 0)
		return function() {
			return true;
		};
	var regexes = terms.map(function(w) {
		return new RegExp(escapeSpecialRegexCharacters(w), "gi");
	});

	if (regexes.length == 1) {
		var regex = regexes[0];
		return function(text) {
			return text.match(regex);
		};
	}

	return function(text) {
		return regexes.every(function(re) {
			return text.match(re);
		});
	};
}

var LookupField =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(LookupField, _Field);

		function LookupField() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = LookupField.prototype;

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			var additionalAttributes = this.multiple
				? {
						values: undefined,
						records: undefined
					}
				: {
						value: undefined,
						text: undefined
					};

			(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[
					this,
					{
						disabled: undefined,
						enabled: undefined,
						placeholder: undefined,
						required: undefined,
						options: undefined,
						icon: undefined,
						autoOpen: undefined,
						readOnly: undefined
					},
					additionalAttributes
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.init = function init() {
			if (isDefined(this.hideClear)) this.showClear = !this.hideClear;
			if (this.alwaysShowClear) this.showClear = true;

			if (!this.bindings) {
				var b = [];
				if (this.value && this.value.bind)
					b.push({
						key: true,
						local: this.value.bind,
						remote: "$option." + this.optionIdField,
						set: this.value.set
					});
				if (this.text && this.text.bind)
					b.push({
						local: this.text.bind,
						remote: "$option." + this.optionTextField,
						set: this.text.set
					});
				this.bindings = b;
			}

			if (this.bindings.length == 0 && this.multiple)
				this.bindings = [
					{
						key: true,
						local: "$value." + this.valueIdField,
						remote: "$option." + this.optionIdField
					},
					{
						local: "$value." + this.valueTextField,
						remote: "$option." + this.optionTextField
					}
				];
			this.keyBindings = this.bindings.filter(function(b) {
				return b.key;
			});
			if (!this.items && !this.children)
				this.items = {
					$type: Text,
					bind: "$option." + this.optionTextField
				};
			this.itemConfig = this.children || this.items;
			delete this.items;
			delete this.children;

			_Field.prototype.init.call(this);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var _this = this;

			var data = instance.data,
				store = instance.store;
			data.stateMods = {
				multiple: this.multiple,
				disabled: data.disabled,
				readonly: data.readOnly
			};
			data.selectedKeys = [];

			if (this.multiple) {
				var _data$selectedKeys;

				if (isArray(data.values) && isArray(data.options)) {
					data.selectedKeys = data.values.map(function(v) {
						return _this.keyBindings.length == 1 ? [v] : v;
					});
					var map = {};
					data.options.filter(function($option) {
						var optionKey = getOptionKey(_this.keyBindings, {
							$option: $option
						});

						for (var i = 0; i < data.selectedKeys.length; i++) {
							if (areKeysEqual(optionKey, data.selectedKeys[i])) {
								map[i] = convertOption(_this.bindings, {
									$option: $option
								});
								break;
							}
						}
					});
					data.records = [];

					for (var i = 0; i < data.selectedKeys.length; i++) {
						if (map[i]) data.records.push(map[i]);
					}
				} else if (isArray(data.records))
					(_data$selectedKeys = data.selectedKeys).push.apply(
						_data$selectedKeys,
						data.records.map(function($value) {
							return _this.keyBindings.map(function(b) {
								return Binding.get(b.local).value({
									$value: $value
								});
							});
						})
					);
			} else {
				var dataViewData = store.getData();
				data.selectedKeys.push(
					this.keyBindings.map(function(b) {
						return Binding.get(b.local).value(dataViewData);
					})
				);

				if (!this.text && isArray(data.options)) {
					var option = data.options.find(function($option) {
						return areKeysEqual(
							getOptionKey(_this.keyBindings, {
								$option: $option
							}),
							data.selectedKeys[0]
						);
					});
					data.text = (option && option[this.optionTextField]) || "";
				}
			}

			if (data.autoOpen) data.autoFocus = true;
			instance.lastDropdown = context.lastDropdown;

			_Field.prototype.prepareData.call(this, context, instance);
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			return VDOM$2.createElement(LookupComponent, {
				key: key,
				multiple: this.multiple,
				instance: instance,
				itemConfig: this.itemConfig,
				bindings: this.bindings,
				baseClass: this.baseClass,
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help"))
			});
		};

		_proto.filterOptions = function filterOptions(instance, options, query) {
			var _this2 = this;

			if (!query) return options;
			var textPredicate = getSearchQueryPredicate(query);
			return options.filter(function(o) {
				return isString(o[_this2.optionTextField]) && textPredicate(o[_this2.optionTextField]);
			});
		};

		_proto.isEmpty = function isEmpty(data) {
			if (this.multiple) {
				if ((isArray(data.values) && data.values.length > 0) || (isArray(data.records) && data.records.length > 0))
					return false;
			}

			return data.value == null;
		};

		return LookupField;
	})(Field);
LookupField.prototype.baseClass = "lookupfield"; //LookupField.prototype.memoize = false;

LookupField.prototype.multiple = false;
LookupField.prototype.queryDelay = 150;
LookupField.prototype.minQueryLength = 0;
LookupField.prototype.hideSearchField = false;
LookupField.prototype.minOptionsForSearchField = 7;
LookupField.prototype.loadingText = "Loading...";
LookupField.prototype.queryErrorText = "Error occurred while querying for lookup data.";
LookupField.prototype.noResultsText = "No results found.";
LookupField.prototype.optionIdField = "id";
LookupField.prototype.optionTextField = "text";
LookupField.prototype.valueIdField = "id";
LookupField.prototype.valueTextField = "text";
LookupField.prototype.suppressErrorsUntilVisited = true;
LookupField.prototype.fetchAll = false;
LookupField.prototype.cacheAll = false;
LookupField.prototype.showClear = true;
LookupField.prototype.alwaysShowClear = false;
LookupField.prototype.closeOnSelect = true;
LookupField.prototype.minQueryLengthMessageText = "Type in at least {0} character(s).";
LookupField.prototype.icon = null;
LookupField.prototype.sort = false;
LookupField.prototype.listOptions = null;
LookupField.prototype.autoOpen = false;
LookupField.prototype.submitOnEnterKey = false;
Localization.registerPrototype("cx/widgets/LookupField", LookupField);
Widget.alias("lookupfield", LookupField);

function getOptionKey(bindings, data) {
	return bindings
		.filter(function(a) {
			return a.key;
		})
		.map(function(b) {
			return Binding.get(b.remote).value(data);
		});
}

function areKeysEqual(key1, key2) {
	if (!key1 || !key2 || key1.length != key2.length) return false;

	for (var i = 0; i < key1.length; i++) {
		if (key1[i] != key2[i]) return false;
	}

	return true;
}

function convertOption(bindings, data) {
	var result = {
		$value: {}
	};
	bindings.forEach(function(b) {
		var value = Binding.get(b.remote).value(data);
		result = Binding.get(b.local).set(result, value);
	});
	return result.$value;
}

var SelectionDelegate =
	/*#__PURE__*/
	(function(_Selection) {
		_inheritsLoose(SelectionDelegate, _Selection);

		function SelectionDelegate(_ref) {
			var _this3;

			var delegate = _ref.delegate;
			_this3 = _Selection.call(this) || this;
			_this3.delegate = delegate;
			return _this3;
		}

		var _proto2 = SelectionDelegate.prototype;

		_proto2.getIsSelectedDelegate = function getIsSelectedDelegate(store) {
			var _this4 = this;

			return function(record, index) {
				return _this4.delegate(record, index);
			};
		};

		_proto2.select = function select() {
			return false;
		};

		return SelectionDelegate;
	})(Selection);

var LookupComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(LookupComponent, _VDOM$Component);

		function LookupComponent(props) {
			var _this5;

			_this5 = _VDOM$Component.call(this, props) || this;
			var _this5$props$instance = _this5.props.instance,
				data = _this5$props$instance.data,
				store = _this5$props$instance.store;
			_this5.dom = {};
			_this5.state = {
				options: [],
				formatted: data.formatted,
				value: data.formatted,
				dropdownOpen: false,
				cursorKey: null,
				focus: false
			};
			_this5.itemStore = new ReadOnlyDataView({
				store: store
			});
			return _this5;
		}

		var _proto3 = LookupComponent.prototype;

		_proto3.getOptionKey = function getOptionKey(data) {
			return this.props.bindings
				.filter(function(a) {
					return a.key;
				})
				.map(function(b) {
					return Binding.get(b.remote).value(data);
				});
		};

		_proto3.getLocalKey = function getLocalKey(data) {
			return this.props.bindings
				.filter(function(a) {
					return a.key;
				})
				.map(function(b) {
					return Binding.get(b.local).value(data);
				});
		};

		_proto3.findOption = function findOption(options, key) {
			if (!key) return -1;

			for (var i = 0; i < options.length; i++) {
				var optionKey = this.getOptionKey({
					$option: options[i]
				});
				if (areKeysEqual(key, optionKey)) return i;
			}

			return -1;
		};

		_proto3.getDropdown = function getDropdown() {
			var _this6 = this;

			if (this.dropdown) return this.dropdown;
			var _this$props$instance = this.props.instance,
				widget = _this$props$instance.widget,
				lastDropdown = _this$props$instance.lastDropdown;
			this.list = Widget.create({
				$type: List,
				sortField: widget.sort && widget.optionTextField,
				sortDirection: "ASC",
				mod: "dropdown",
				scrollSelectionIntoView: true,
				records: {
					bind: "$options"
				},
				recordName: "$option",
				onItemClick: function onItemClick(e, inst) {
					return _this6.onItemClick(e, inst);
				},
				pipeKeyDown: function pipeKeyDown(kd) {
					_this6.listKeyDown = kd;
				},
				selection: {
					type: SelectionDelegate,
					delegate: function delegate(data) {
						return (
							_this6.props.instance.data.selectedKeys.find(function(x) {
								return areKeysEqual(
									x,
									_this6.getOptionKey({
										$option: data
									})
								);
							}) != null
						);
					}
				},
				jsxSpread: [widget.listOptions],
				jsxAttributes: [
					"sortField",
					"sortDirection",
					"mod",
					"scrollSelectionIntoView",
					"records",
					"recordName",
					"onItemClick",
					"pipeKeyDown",
					"selection"
				],
				children: ["\n            ", this.props.itemConfig, "\n         "]
			});

			var dropdown = _objectSpread(
				{
					constrain: true,
					scrollTracking: true,
					inline: !isTouchDevice() || !!lastDropdown,
					placementOrder: "down-right down-left up-right up-left"
				},
				widget.dropdownOptions,
				{
					type: Dropdown,
					relatedElement: this.dom.input,
					renderChildren: this.renderDropdownContents.bind(this),
					onFocusOut: this.closeDropdown.bind(this),
					memoize: false,
					touchFriendly: isTouchDevice(),
					onMeasureDropdownNaturalSize: function onMeasureDropdownNaturalSize() {
						if (_this6.dom.dropdown && _this6.dom.list) {
							return {
								height: _this6.dom.dropdown.offsetHeight + _this6.dom.list.scrollHeight - _this6.dom.list.offsetHeight
							};
						}
					}
				}
			);

			return (this.dropdown = Widget.create(dropdown));
		};

		_proto3.renderDropdownContents = function renderDropdownContents() {
			var _this7 = this;

			var content;
			var instance = this.props.instance;
			var data = instance.data,
				widget = instance.widget;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var searchVisible =
				!widget.hideSearchField &&
				(!isArray(data.options) ||
					(widget.minOptionsForSearchField && data.options.length >= widget.minOptionsForSearchField));

			if (this.state.status == "loading") {
				content = VDOM$2.createElement(
					"div",
					{
						key: "msg",
						className: CSS.element(baseClass, "message", "loading")
					},
					widget.loadingText
				);
			} else if (this.state.status == "error") {
				content = VDOM$2.createElement(
					"div",
					{
						key: "msg",
						className: CSS.element(baseClass, "message", "error")
					},
					widget.queryErrorText
				);
			} else if (this.state.status == "info") {
				content = VDOM$2.createElement(
					"div",
					{
						key: "msg",
						className: CSS.element(baseClass, "message", "info")
					},
					this.state.message
				);
			} else if (this.state.options.length == 0) {
				content = VDOM$2.createElement(
					"div",
					{
						key: "msg",
						className: CSS.element(baseClass, "message", "no-results")
					},
					widget.noResultsText
				);
			} else {
				content = VDOM$2.createElement(
					"div",
					{
						key: "msg",
						ref: function ref(el) {
							_this7.dom.list = el;
						},
						className: CSS.element(baseClass, "scroll-container"),
						onWheel: this.onListWheel.bind(this)
					},
					VDOM$2.createElement(Cx, {
						widget: this.list,
						store: this.itemStore,
						options: {
							name: "lookupfield-list"
						}
					})
				);
			}

			return VDOM$2.createElement(
				"div",
				{
					key: "dropdown",
					ref: function ref(el) {
						_this7.dom.dropdown = el;
					},
					className: CSS.element(baseClass, "dropdown"),
					tabIndex: 0,
					onFocus: this.onDropdownFocus.bind(this),
					onKeyDown: function onKeyDown(e) {
						return _this7.onDropdownKeyPress(e);
					}
				},
				searchVisible &&
					VDOM$2.createElement("input", {
						key: "query",
						ref: function ref(el) {
							_this7.dom.query = el;
						},
						type: "text",
						className: CSS.element(baseClass, "query"),
						onClick: function onClick(e) {
							e.preventDefault();
							e.stopPropagation();
						},
						onChange: function onChange(e) {
							return _this7.query(e.target.value);
						},
						onBlur: function onBlur(e) {
							return _this7.onQueryBlur(e);
						}
					}),
				content
			);
		};

		_proto3.onListWheel = function onListWheel(e) {
			var list = this.dom.list;

			if (
				(list.scrollTop + list.offsetHeight == list.scrollHeight && e.deltaY > 0) ||
				(list.scrollTop == 0 && e.deltaY < 0)
			) {
				e.preventDefault();
				e.stopPropagation();
			}
		};

		_proto3.onDropdownFocus = function onDropdownFocus(e) {
			if (this.dom.query && !isFocused(this.dom.query) && !isTouchDevice()) FocusManager.focus(this.dom.query);
		};

		_proto3.getPlaceholder = function getPlaceholder(text) {
			var _this$props$instance$ = this.props.instance.widget,
				CSS = _this$props$instance$.CSS,
				baseClass = _this$props$instance$.baseClass;
			if (text)
				return VDOM$2.createElement(
					"span",
					{
						className: CSS.element(baseClass, "placeholder")
					},
					text
				);
			return VDOM$2.createElement(
				"span",
				{
					className: CSS.element(baseClass, "placeholder")
				},
				"\xA0"
			);
		};

		_proto3.render = function render() {
			var _this8 = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				label = _this$props.label,
				help = _this$props.help;
			var data = instance.data,
				widget = instance.widget,
				state = instance.state;
			var CSS = widget.CSS,
				baseClass = widget.baseClass,
				suppressErrorsUntilVisited = widget.suppressErrorsUntilVisited;
			var icon =
				data.icon &&
				VDOM$2.createElement(
					"div",
					{
						key: "icon",
						className: CSS.element(baseClass, "left-icon"),
						onMouseDown: preventDefault,
						onClick: function onClick(e) {
							_this8.openDropdown(e);

							e.stopPropagation();
							e.preventDefault();
						}
					},
					Icon.render(data.icon, {
						className: CSS.element(baseClass, "icon")
					})
				);
			var dropdown;

			if (this.state.dropdownOpen) {
				this.itemStore.setData({
					$options: this.state.options
				});
				dropdown = VDOM$2.createElement(Cx, {
					widget: this.getDropdown(),
					store: this.itemStore,
					options: {
						name: "lookupfield-dropdown"
					}
				});
			}

			var insideButton = null;

			if (!data.readOnly) {
				if (
					widget.showClear &&
					!data.disabled &&
					!this.props.multiple &&
					(widget.alwaysShowClear || !data.required) &&
					data.value != null
				) {
					insideButton = VDOM$2.createElement(
						"div",
						{
							key: "ib",
							onMouseDown: preventDefault,
							onClick: function onClick(e) {
								return _this8.onClearClick(e);
							},
							className: CSS.element(baseClass, "clear")
						},
						VDOM$2.createElement(ClearIcon, {
							className: CSS.element(baseClass, "icon")
						})
					);
				} else {
					insideButton = VDOM$2.createElement(
						"div",
						{
							key: "ib",
							className: CSS.element(baseClass, "tool"),
							onMouseDown: preventDefault,
							onClick: function onClick(e) {
								_this8.openDropdown(e);

								e.stopPropagation();
								e.preventDefault();
							}
						},
						VDOM$2.createElement(DropdownIcon, {
							className: CSS.element(baseClass, "icon")
						})
					);
				}
			}

			var text;

			if (this.props.multiple) {
				var readOnly = data.disabled || data.readOnly;

				if (isArray(data.records) && data.records.length > 0) {
					text = data.records.map(function(v, i) {
						return VDOM$2.createElement(
							"div",
							{
								key: i,
								className: CSS.element(baseClass, "tag", {
									readonly: readOnly
								})
							},
							VDOM$2.createElement(
								"span",
								{
									className: CSS.element(baseClass, "tag-value")
								},
								v[widget.valueTextField]
							),
							!readOnly &&
								VDOM$2.createElement(
									"div",
									{
										className: CSS.element(baseClass, "tag-clear"),
										onMouseDown: function onMouseDown(e) {
											e.preventDefault();
											e.stopPropagation();
										},
										onClick: function onClick(e) {
											return _this8.onClearClick(e, v);
										}
									},
									VDOM$2.createElement(ClearIcon, {
										className: CSS.element(baseClass, "icon")
									})
								)
						);
					});
				} else {
					text = this.getPlaceholder(data.placeholder);
				}
			} else {
				text = data.value != null ? data.text || this.getPlaceholder() : this.getPlaceholder(data.placeholder);
			}

			var states = {
				visited: state.visited,
				focus: this.state.focus || this.state.dropdownOpen,
				icon: !!data.icon,
				empty: !data.placeholder && data.empty,
				error: data.error && (state.visited || !suppressErrorsUntilVisited || !data.empty)
			};
			return VDOM$2.createElement(
				"div",
				{
					className: CSS.expand(data.classNames, CSS.state(states)),
					style: data.style,
					onMouseDown: stopPropagation,
					onTouchStart: stopPropagation,
					onKeyDown: function onKeyDown(e) {
						return _this8.onKeyDown(e);
					}
				},
				VDOM$2.createElement(
					"div",
					{
						id: data.id,
						className: CSS.element(widget.baseClass, "input"),
						tabIndex: data.disabled ? null : data.tabIndex || 0,
						ref: function ref(el) {
							_this8.dom.input = el;
						},
						onMouseMove: function onMouseMove(e) {
							return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(_this8.props.instance)));
						},
						onMouseLeave: function onMouseLeave(e) {
							return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(_this8.props.instance)));
						},
						onClick: function onClick(e) {
							return _this8.onClick(e);
						},
						onInput: function onInput(e) {
							return _this8.onChange(e, "input");
						},
						onChange: function onChange(e) {
							return _this8.onChange(e, "change");
						},
						onKeyDown: function onKeyDown(e) {
							return _this8.onInputKeyDown(e);
						},
						onMouseDown: function onMouseDown(e) {
							return _this8.onMouseDown(e);
						},
						onBlur: function onBlur(e) {
							return _this8.onBlur(e);
						},
						onFocus: function onFocus(e) {
							return _this8.onFocus(e);
						}
					},
					text
				),
				insideButton,
				icon,
				dropdown,
				label,
				help
			);
		};

		_proto3.onClick = function onClick(e) {
			e.stopPropagation();
			e.preventDefault();
			this.openDropdown(e);
		};

		_proto3.onItemClick = function onItemClick(e, _ref2) {
			var store = _ref2.store;
			this.select(e, store.getData());
			if (!this.props.instance.widget.submitOnEnterKey || e.type != "keydown") e.stopPropagation();
			e.preventDefault();
		};

		_proto3.onClearClick = function onClearClick(e, value) {
			var _this9 = this;

			var instance = this.props.instance;
			var data = instance.data,
				store = instance.store,
				widget = instance.widget;
			var keyBindings = widget.keyBindings;
			e.stopPropagation();
			e.preventDefault();

			if (widget.multiple) {
				if (isArray(data.records)) {
					var itemKey = this.getLocalKey({
						$value: value
					});
					var newRecords = data.records.filter(function(v) {
						return !areKeysEqual(
							_this9.getLocalKey({
								$value: v
							}),
							itemKey
						);
					});
					instance.set("records", newRecords);
					var newValues = newRecords
						.map(function(rec) {
							return _this9.getLocalKey({
								$value: rec
							});
						})
						.map(function(k) {
							return keyBindings.length == 1 ? k[0] : k;
						});
					instance.set("values", newValues);
				}
			} else {
				this.props.bindings.forEach(function(b) {
					store.set(b.local, null);
				});
			}

			if (!isTouchEvent(e)) this.dom.input.focus();
		};

		_proto3.select = function select(e, itemData) {
			var _this10 = this;

			var instance = this.props.instance;
			var store = instance.store,
				data = instance.data,
				widget = instance.widget;
			var bindings = widget.bindings,
				keyBindings = widget.keyBindings;

			if (widget.multiple) {
				var selectedKeys = data.selectedKeys,
					records = data.records;
				var optionKey = this.getOptionKey(itemData);
				var newRecords = records;

				if (
					!selectedKeys.find(function(k) {
						return areKeysEqual(optionKey, k);
					})
				) {
					var valueData = {
						$value: {}
					};
					bindings.forEach(function(b) {
						valueData = Binding.get(b.local).set(valueData, Binding.get(b.remote).value(itemData));
					});
					newRecords = [].concat(records || [], [valueData.$value]);
				} else {
					newRecords = records.filter(function(v) {
						return !areKeysEqual(
							optionKey,
							_this10.getLocalKey({
								$value: v
							})
						);
					});
				}

				instance.set("records", newRecords);
				var newValues = newRecords
					.map(function(rec) {
						return _this10.getLocalKey({
							$value: rec
						});
					})
					.map(function(k) {
						return keyBindings.length == 1 ? k[0] : k;
					});
				instance.set("values", newValues);
			} else {
				bindings.forEach(function(b) {
					var v = Binding.get(b.remote).value(itemData);
					if (b.set) b.set(v, instance);
					else store.set(b.local, v);
				});
			}

			if (widget.closeOnSelect) {
				this.closeDropdown(e);
				if (!isTouchEvent(e)) this.dom.input.focus();
			}
		};

		_proto3.onDropdownKeyPress = function onDropdownKeyPress(e) {
			if (e.keyCode == KeyCode.enter) {
				var index = this.findOption(this.state.options, this.state.cursorKey);

				if (index != -1) {
					var itemData = {
						$option: this.state.options[index]
					};
					this.select(e, itemData);
				}
			}

			if (e.keyCode == KeyCode.esc) {
				this.closeDropdown(e);
				this.dom.input.focus();
			}

			if (this.listKeyDown) this.listKeyDown(e);
		};

		_proto3.onKeyDown = function onKeyDown(e) {
			// switch (e.keyCode) {
			//    case KeyCode.enter:
			//       if ( this.state.dropdownOpen)
			//          e.stopPropagation();
			//       return;
			// }
		};

		_proto3.onInputKeyDown = function onInputKeyDown(e) {
			var instance = this.props.instance;
			if (instance.widget.handleKeyDown(e, instance) === false) return;

			switch (e.keyCode) {
				case KeyCode.delete:
					this.onClearClick(e);
					return;

				case KeyCode.shift:
				case KeyCode.ctrl:
				case KeyCode.tab:
				case KeyCode.left:
				case KeyCode.right:
					break;

				case KeyCode.down:
					this.openDropdown(e);
					e.stopPropagation();
					break;

				default:
					this.openDropdown(e);
					break;
			}
		};

		_proto3.onMouseDown = function onMouseDown(e) {
			e.preventDefault();
			e.stopPropagation();
			this.openDropdown(e);
		};

		_proto3.onQueryBlur = function onQueryBlur(e) {
			FocusManager.nudge();
		};

		_proto3.onFocus = function onFocus(e) {
			var instance = this.props.instance;
			var widget = instance.widget;

			if (widget.trackFocus) {
				this.setState({
					focus: true
				});
			}
		};

		_proto3.onBlur = function onBlur(e) {
			if (!this.state.dropdownOpen)
				this.props.instance.setState({
					visited: true
				});
			if (this.state.focus)
				this.setState({
					focus: false
				});
		};

		_proto3.closeDropdown = function closeDropdown(e) {
			if (this.state.dropdownOpen) {
				this.setState({
					dropdownOpen: false,
					cursorKey: null
				});
				this.props.instance.setState({
					visited: true
				});
			} //delete results valid only while dropdown is open

			delete this.tmpCachedResult;
		};

		_proto3.openDropdown = function openDropdown(e) {
			var _this11 = this;

			var data = this.props.instance.data;

			if (!this.state.dropdownOpen && !data.disabled && !data.readOnly) {
				this.query("");
				this.setState(
					{
						dropdownOpen: true
					},
					function() {
						if (_this11.dom.dropdown) _this11.dom.dropdown.focus();
					}
				);
			}
		};

		_proto3.query = function query(q) {
			var _this12 = this;

			/*
     In fetchAll mode onQuery should fetch all data and after
     that everything is done filtering is done client-side.
     If cacheAll is set results are cached for the lifetime of the
     widget, otherwise cache is invalidated when dropdown closes.
     */
			var instance = this.props.instance;
			var widget = instance.widget,
				data = instance.data;
			if (this.queryTimeoutId) clearTimeout(this.queryTimeoutId);

			if (q.length < widget.minQueryLength) {
				this.setState({
					status: "info",
					message: StringTemplate.format(widget.minQueryLengthMessageText, widget.minQueryLength)
				});
				return;
			}

			if (isArray(data.options)) {
				var results = widget.filterOptions(this.props.instance, data.options, q);
				this.setState({
					options: results,
					status: "loaded"
				});
			}

			if (widget.onQuery) {
				var queryDelay = widget.queryDelay,
					fetchAll = widget.fetchAll,
					cacheAll = widget.cacheAll;
				if (fetchAll) queryDelay = 0;

				if (!this.state.dropdownOpen && !this.cachedResult) {
					this.setState({
						status: "loading"
					});
				}

				this.queryTimeoutId = setTimeout(function() {
					delete _this12.queryTimeoutId;
					var result = _this12.tmpCachedResult || _this12.cachedResult;
					if (!result) result = instance.invoke("onQuery", fetchAll ? "" : q, instance);
					Promise.resolve(result)
						.then(function(results) {
							if (!isArray(results)) results = [];

							if (fetchAll) {
								if (cacheAll) _this12.cachedResult = results;
								else _this12.tmpCachedResult = results;
								results = widget.filterOptions(_this12.props.instance, results, q);
							}

							_this12.setState({
								options: results,
								status: "loaded"
							});
						})
						.catch(function(err) {
							_this12.setState({
								status: "error"
							});

							debug("Lookup query error:", err);
						});
				}, queryDelay);
			}
		};

		_proto3.componentWillReceiveProps = function componentWillReceiveProps(props) {
			tooltipParentWillReceiveProps.apply(void 0, [this.dom.input].concat(getFieldTooltip(props.instance)));
		};

		_proto3.componentDidMount = function componentDidMount() {
			tooltipParentDidMount.apply(void 0, [this.dom.input].concat(getFieldTooltip(this.props.instance)));
			autoFocus(this.dom.input, this);
			if (this.props.instance.data.autoOpen) this.openDropdown(null);
		};

		_proto3.componentDidUpdate = function componentDidUpdate() {
			autoFocus(this.dom.input, this);
		};

		_proto3.componentWillUnmount = function componentWillUnmount() {
			if (this.queryTimeoutId) clearTimeout(this.queryTimeoutId);
			tooltipParentWillUnmount(this.props.instance);
		};

		return LookupComponent;
	})(VDOM$2.Component);

enableCultureSensitiveFormatting();
var NumberField =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(NumberField, _Field);

		function NumberField() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = NumberField.prototype;

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[
					this,
					{
						value: null,
						disabled: undefined,
						readOnly: undefined,
						enabled: undefined,
						placeholder: undefined,
						required: undefined,
						format: undefined,
						minValue: undefined,
						maxValue: undefined,
						minExclusive: undefined,
						maxExclusive: undefined,
						incrementPercentage: undefined,
						increment: undefined,
						icon: undefined,
						scale: undefined,
						offset: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.init = function init() {
			if (isDefined(this.step)) this.increment = this.step;
			if (isDefined(this.hideClear)) this.showClear = !this.hideClear;
			if (this.alwaysShowClear) this.showClear = true;

			_Field.prototype.init.call(this);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data,
				state = instance.state,
				cached = instance.cached;
			data.formatted = Format$1.value(data.value, data.format);
			if (!cached.data || data.value != cached.data.value) state.empty = data.value == null;

			_Field.prototype.prepareData.call(this, context, instance);
		};

		_proto.formatValue = function formatValue(context, _ref) {
			var data = _ref.data;
			return data.formatted;
		};

		_proto.validate = function validate(context, instance) {
			_Field.prototype.validate.call(this, context, instance);

			var data = instance.data;

			if (isNumber(data.value) && !data.error) {
				if (isNumber(data.minValue)) {
					if (data.value < data.minValue) data.error = StringTemplate.format(this.minValueErrorText, data.minValue);
					else if (data.value == data.minValue && data.minExclusive)
						data.error = StringTemplate.format(this.minExclusiveErrorText, data.minValue);
				}

				if (isNumber(data.maxValue)) {
					if (data.value > data.maxValue) data.error = StringTemplate.format(this.maxValueErrorText, data.maxValue);
					else if (data.value == data.maxValue && data.maxExclusive)
						data.error = StringTemplate.format(this.maxExclusiveErrorText, data.maxValue);
				}
			}
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			return VDOM$2.createElement(Input$1, {
				key: key,
				data: instance.data,
				instance: instance,
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help"))
			});
		};

		_proto.validateRequired = function validateRequired(context, instance) {
			return instance.state.empty && this.requiredText;
		};

		return NumberField;
	})(Field);
NumberField.prototype.baseClass = "numberfield";
NumberField.prototype.reactOn = "enter blur";
NumberField.prototype.format = "n";
NumberField.prototype.inputType = "text";
NumberField.prototype.maxValueErrorText = "Enter {0:n} or less.";
NumberField.prototype.maxExclusiveErrorText = "Enter a number less than {0:n}.";
NumberField.prototype.minValueErrorText = "Enter {0:n} or more.";
NumberField.prototype.minExclusiveErrorText = "Enter a number greater than {0:n}.";
NumberField.prototype.inputErrorText = "Invalid number entered.";
NumberField.prototype.suppressErrorsUntilVisited = true;
NumberField.prototype.incrementPercentage = 0.1;
NumberField.prototype.scale = 1;
NumberField.prototype.offset = 0;
NumberField.prototype.snapToIncrement = true;
NumberField.prototype.icon = null;
NumberField.prototype.showClear = false;
NumberField.prototype.alwaysShowClear = false;
Widget.alias("numberfield", NumberField);
Localization.registerPrototype("cx/widgets/NumberField", NumberField);

var Input$1 =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(Input, _VDOM$Component);

		function Input(props) {
			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			_this.state = {
				focus: false
			};
			return _this;
		}

		var _proto2 = Input.prototype;

		_proto2.render = function render() {
			var _this2 = this;

			var _this$props = this.props,
				data = _this$props.data,
				instance = _this$props.instance,
				label = _this$props.label,
				help = _this$props.help;
			var widget = instance.widget,
				state = instance.state;
			var CSS = widget.CSS,
				baseClass = widget.baseClass,
				suppressErrorsUntilVisited = widget.suppressErrorsUntilVisited;
			var icon =
				data.icon &&
				VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "left-icon")
					},
					Icon.render(data.icon, {
						className: CSS.element(baseClass, "icon")
					})
				);
			var insideButton;

			if (!data.readOnly && !data.disabled) {
				if (
					widget.showClear &&
					(((widget.alwaysShowClear || !data.required) && data.value != null) || instance.state.inputError)
				)
					insideButton = VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "clear"),
							onMouseDown: function onMouseDown(e) {
								return e.preventDefault();
							},
							onClick: function onClick(e) {
								return _this2.onClearClick(e);
							}
						},
						VDOM$2.createElement(ClearIcon, {
							className: CSS.element(baseClass, "icon")
						})
					);
			}

			var empty = this.input ? !this.input.value : data.empty;
			return VDOM$2.createElement(
				"div",
				{
					className: CSS.expand(
						data.classNames,
						CSS.state({
							visited: state.visited,
							focus: this.state.focus,
							icon: !!icon,
							empty: empty && !data.placeholder,
							error: data.error && (state.visited || !suppressErrorsUntilVisited || !empty)
						})
					),
					style: data.style,
					onMouseDown: stopPropagation,
					onTouchStart: stopPropagation
				},
				VDOM$2.createElement(
					"input",
					_extends(
						{
							id: data.id,
							type: widget.inputType,
							className: CSS.element(baseClass, "input"),
							defaultValue: data.formatted,
							ref: function ref(el) {
								_this2.input = el;
							},
							style: data.inputStyle,
							disabled: data.disabled,
							readOnly: data.readOnly,
							tabIndex: data.tabIndex,
							placeholder: data.placeholder
						},
						data.inputAttrs,
						{
							onMouseMove: function onMouseMove(e) {
								return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(_this2.props.instance)));
							},
							onMouseLeave: function onMouseLeave(e) {
								return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(_this2.props.instance)));
							},
							onChange: function onChange(e) {
								return _this2.onChange(e, "change");
							},
							onKeyDown: this.onKeyDown.bind(this),
							onBlur: function onBlur(e) {
								_this2.onChange(e, "blur");
							},
							onFocus: function onFocus(e) {
								return _this2.onFocus();
							},
							onWheel: function onWheel(e) {
								_this2.onChange(e, "wheel");
							},
							onClick: stopPropagation
						}
					)
				),
				insideButton,
				icon,
				label,
				help
			);
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			var _props$instance = props.instance,
				data = _props$instance.data,
				state = _props$instance.state;

			if (this.props.data.formatted != data.formatted && !state.inputError) {
				this.input.value = props.data.formatted || "";
				props.instance.setState({
					inputError: false
				});
			}

			tooltipParentWillReceiveProps.apply(void 0, [this.input].concat(getFieldTooltip(props.instance)));
		};

		_proto2.componentDidMount = function componentDidMount() {
			tooltipParentDidMount.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
			autoFocus(this.input, this);
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			autoFocus(this.input, this);
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			tooltipParentWillUnmount(this.props.instance);
		};

		_proto2.getPreCursorDigits = function getPreCursorDigits(text, cursor) {
			var res = "";
			var culture = Culture.getNumberCulture();
			var decimalSeparator = culture.decimalSeparator || ".";

			for (var i = 0; i < cursor; i++) {
				if ("0" <= text[i] && text[i] <= "9") res += text[i];
				else if (text[i] == decimalSeparator) res += ".";
				else if (text[i] == "-") res += "-";
			}

			return res;
		};

		_proto2.updateCursorPosition = function updateCursorPosition(preCursorText) {
			if (isString(preCursorText)) {
				var cursor = 0;
				var preCursor = 0;
				var text = this.input.value || "";

				while (preCursor < preCursorText.length && cursor < text.length) {
					if (text[cursor] == preCursorText[preCursor]) {
						cursor++;
						preCursor++;
					} else {
						cursor++;
					}
				}

				this.input.setSelectionRange(cursor, cursor);
			}
		};

		_proto2.calculateIncrement = function calculateIncrement(value, strength) {
			if (value == 0) return 0.1;
			var absValue = Math.abs(value * strength);
			var log10 = Math.floor(Math.log10(absValue) + 0.001);
			var size = Math.pow(10, log10);
			if (absValue / size > 4.999) return 5 * size;
			if (absValue / size > 1.999) return 2 * size;
			return size;
		};

		_proto2.onClearClick = function onClearClick(e) {
			this.input.value = "";
			this.props.instance.set("value", null);
		};

		_proto2.onKeyDown = function onKeyDown(e) {
			var instance = this.props.instance;
			if (instance.widget.handleKeyDown(e, instance) === false) return;

			switch (e.keyCode) {
				case KeyCode.enter:
					this.onChange(e, "enter");
					break;

				case KeyCode.left:
				case KeyCode.right:
					e.stopPropagation();
					break;
			}
		};

		_proto2.onChange = function onChange(e, change) {
			var _this$props2 = this.props,
				instance = _this$props2.instance,
				data = _this$props2.data;
			var widget = instance.widget;

			if (data.required) {
				instance.setState({
					empty: !e.target.value
				});
			}

			if (widget.reactOn.indexOf(change) == -1 || data.disabled || data.readOnly) return;
			if (change == "blur" || change == "enter")
				instance.setState({
					visited: true
				});

			if (change == "blur") {
				if (this.state.focus)
					this.setState({
						focus: false
					});
			}

			var value = null;

			if (e.target.value) {
				var displayValue = Culture.getNumberCulture().parse(e.target.value);

				if (isNaN(displayValue)) {
					instance.setState({
						inputError: instance.widget.inputErrorText
					});
					return;
				}

				value = displayValue * data.scale + data.offset;

				if (change == "wheel") {
					e.preventDefault();
					var increment =
						data.increment != null ? data.increment : this.calculateIncrement(value, data.incrementPercentage);
					value = value + (e.deltaY < 0 ? increment : -increment);

					if (widget.snapToIncrement) {
						value = Math.round(value / increment) * increment;
					}

					if (data.minValue != null) {
						if (data.minExclusive) {
							if (value <= data.minValue) return;
						} else {
							value = Math.max(value, data.minValue);
						}
					}

					if (data.maxValue != null) {
						if (data.maxExclusive) {
							if (value >= data.maxValue) return;
						} else {
							value = Math.min(value, data.maxValue);
						}
					}
				}

				var fmt = data.format;
				var formatted = Format$1.value(value, fmt); //re-parse to avoid differences between formatted value and value in the store

				var culture = Culture.getNumberCulture();
				value = culture.parse(formatted) * data.scale + data.offset;
				if (
					change == "change" &&
					this.input.selectionStart == this.input.selectionEnd &&
					e.target.value[this.input.selectionEnd - 1] == culture.decimalSeparator
				)
					return;

				if (
					change != "blur" &&
					e.target.value[e.target.value.length - 1] != "." &&
					e.target.value[e.target.value.length - 1] != "," &&
					(e.target.value[e.target.value.length - 1] != "0" ||
						e.target.value.indexOf(culture.decimalSeparator) == -1 ||
						(this.input.selectionStart == this.input.selectionEnd &&
							this.input.selectionStart != e.target.value.length))
				) {
					var preCursorText = this.getPreCursorDigits(this.input.value, this.input.selectionStart);
					this.input.value = formatted;
					this.updateCursorPosition(preCursorText);
				} else {
					this.input.value = formatted;
				}
			} //it's important not to set the old value as it causes weird behavior if debounce is used

			if (value !== data.value) instance.set("value", value);
			instance.setState({
				inputError: false,
				visited: true
			});
		};

		_proto2.onFocus = function onFocus() {
			var instance = this.props.instance;
			var widget = instance.widget;

			if (widget.trackFocus) {
				this.setState({
					focus: true
				});
			}
		};

		return Input;
	})(VDOM$2.Component);

var TextArea =
	/*#__PURE__*/
	(function(_TextField) {
		_inheritsLoose(TextArea, _TextField);

		function TextArea() {
			return _TextField.apply(this, arguments) || this;
		}

		var _proto = TextArea.prototype;

		_proto.declareData = function declareData() {
			var _TextField$prototype$;

			(_TextField$prototype$ = _TextField.prototype.declareData).call.apply(
				_TextField$prototype$,
				[
					this,
					{
						rows: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var state = instance.state,
				data = instance.data,
				cached = instance.cached;
			if (!cached.data || data.value != cached.data.value) state.empty = !data.value;

			_TextField.prototype.prepareData.call(this, context, instance);
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			return VDOM$2.createElement(Input$2, {
				key: key,
				data: instance.data,
				instance: instance,
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help"))
			});
		};

		_proto.validateRequired = function validateRequired(context, instance) {
			return instance.state.empty && this.requiredText;
		};

		return TextArea;
	})(TextField);
TextArea.prototype.baseClass = "textarea";
TextArea.prototype.reactOn = "blur";
TextArea.prototype.suppressErrorsUntilVisited = true;

var Input$2 =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(Input, _VDOM$Component);

		function Input(props) {
			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			_this.state = {
				focus: false
			};
			return _this;
		}

		var _proto2 = Input.prototype;

		_proto2.render = function render() {
			var _this2 = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				label = _this$props.label,
				help = _this$props.help;
			var widget = instance.widget,
				data = instance.data,
				state = instance.state;
			var CSS = widget.CSS,
				baseClass = widget.baseClass,
				suppressErrorsUntilVisited = widget.suppressErrorsUntilVisited;
			var empty = this.input ? !this.input.value : data.empty;
			return VDOM$2.createElement(
				"div",
				{
					className: CSS.expand(
						data.classNames,
						CSS.state({
							visited: state.visited,
							focus: this.state.focus,
							empty: empty && !data.placeholder,
							error: data.error && (state.visited || !suppressErrorsUntilVisited || !empty)
						})
					),
					style: data.style,
					onMouseDown: stopPropagation,
					onTouchStart: stopPropagation
				},
				VDOM$2.createElement(
					"textarea",
					_extends(
						{
							className: CSS.element(baseClass, "input"),
							ref: function ref(el) {
								_this2.input = el;
							},
							id: data.id,
							rows: data.rows,
							style: data.inputStyle,
							defaultValue: data.value,
							disabled: data.disabled,
							readOnly: data.readOnly,
							tabIndex: data.tabIndex,
							placeholder: data.placeholder
						},
						data.inputAttrs,
						{
							onInput: function onInput(e) {
								return _this2.onChange(e, "input");
							},
							onChange: function onChange(e) {
								return _this2.onChange(e, "change");
							},
							onBlur: function onBlur(e) {
								_this2.onChange(e, "blur");
							},
							onFocus: function onFocus(e) {
								return _this2.onFocus();
							},
							onClick: stopPropagation,
							onMouseMove: function onMouseMove(e) {
								return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
							},
							onMouseLeave: function onMouseLeave(e) {
								return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
							}
						}
					)
				),
				label,
				help
			);
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			tooltipParentWillUnmount(this.props.instance);
		};

		_proto2.componentDidMount = function componentDidMount() {
			tooltipParentDidMount.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
			autoFocus(this.input, this);
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			autoFocus(this.input, this);
		};

		_proto2.onKeyDown = function onKeyDown(e) {
			var instance = this.props.instance;
			if (instance.widget.handleKeyDown(e, instance) === false) return;

			switch (e.keyCode) {
				case KeyCode.enter:
					this.onChange(e, "enter");
					break;

				case KeyCode.left:
				case KeyCode.right:
					e.stopPropagation();
					break;
			}
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(_ref) {
			var data = _ref.data,
				instance = _ref.instance;

			if (data.value != this.props.data.value) {
				this.input.value = data.value || "";
			}

			tooltipParentWillReceiveProps.apply(void 0, [this.input].concat(getFieldTooltip(instance)));
		};

		_proto2.onChange = function onChange(e, change) {
			var _this$props2 = this.props,
				instance = _this$props2.instance,
				data = _this$props2.data;

			if (change == "blur") {
				instance.setState({
					visited: true
				});
				if (this.state.focus)
					this.setState({
						focus: false
					});
			}

			if (data.required) {
				instance.setState({
					empty: !e.target.value
				});
			}

			if (instance.widget.reactOn.indexOf(change) != -1) {
				var value = e.target.value || null; //it's important not to set the old value as it causes weird behavior if debounce is used

				if (value !== data.value) instance.set("value", value);
			}
		};

		_proto2.onFocus = function onFocus() {
			var instance = this.props.instance;
			var widget = instance.widget;

			if (widget.trackFocus) {
				this.setState({
					focus: true
				});
			}
		};

		return Input;
	})(VDOM$2.Component);

Widget.alias("textarea", TextArea);

var ValidationGroup =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(ValidationGroup, _PureContainer);

		function ValidationGroup() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = ValidationGroup.prototype;

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						errors: undefined,
						valid: undefined,
						invalid: undefined,
						disabled: undefined,
						enabled: undefined,
						readOnly: undefined,
						viewMode: undefined,
						tabOnEnterKey: undefined,
						isolated: undefined
					}
				])
			);
		};

		_proto.explore = function explore(context, instance) {
			if (isDefined(instance.data.enabled)) instance.data.disabled = !instance.data.enabled;
			instance.validation = {
				errors: []
			};
			context.push("parentDisabled", context.parentDisabled || instance.data.disabled);
			context.push("parentReadOnly", context.parentReadOnly || instance.data.readOnly);
			context.push("parentViewMode", context.parentViewMode || instance.data.viewMode);
			context.push("parentTabOnEnterKey", context.parentTabOnEnterKey || instance.data.tabOnEnterKey);
			context.push("validation", instance.validation);

			_PureContainer.prototype.explore.call(this, context, instance);
		};

		_proto.exploreCleanup = function exploreCleanup(context, instance) {
			var _context$validation$e;

			context.pop("validation");
			instance.valid = instance.validation.errors.length == 0;
			if (!instance.valid && !this.isolated && context.validation)
				(_context$validation$e = context.validation.errors).push.apply(
					_context$validation$e,
					instance.validation.errors
				);
			instance.set("valid", instance.valid);
			instance.set("invalid", !instance.valid);
			if (this.errors && !shallowEquals(instance.data.errors, instance.validation.errors))
				instance.set("errors", instance.validation.errors);
			context.pop("parentDisabled");
			context.pop("parentReadOnly");
			context.pop("parentViewMode");
			context.pop("parentTabOnEnterKey");
		};

		return ValidationGroup;
	})(PureContainer);
ValidationGroup.prototype.isolated = false;
Widget.alias("validation-group", ValidationGroup);

var FieldGroup =
	/*#__PURE__*/
	(function(_ValidationGroup) {
		_inheritsLoose(FieldGroup, _ValidationGroup);

		function FieldGroup() {
			return _ValidationGroup.apply(this, arguments) || this;
		}

		return FieldGroup;
	})(ValidationGroup);
Widget.alias("field-group", FieldGroup);

var LabeledContainer =
	/*#__PURE__*/
	(function(_FieldGroup) {
		_inheritsLoose(LabeledContainer, _FieldGroup);

		function LabeledContainer() {
			return _FieldGroup.apply(this, arguments) || this;
		}

		var _proto = LabeledContainer.prototype;

		_proto.declareData = function declareData() {
			var _FieldGroup$prototype;

			(_FieldGroup$prototype = _FieldGroup.prototype.declareData).call.apply(
				_FieldGroup$prototype,
				[
					this,
					{
						label: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.init = function init() {
			if (this.label != null) {
				var labelConfig = {
					type: Label,
					disabled: this.disabled,
					mod: this.mod,
					asterisk: this.asterisk,
					required: true
				};
				if (this.label.isComponentType) labelConfig = this.label;
				else if (isSelector(this.label)) labelConfig.text = this.label;
				else Object.assign(labelConfig, this.label);
				this.label = Widget.create(labelConfig);
			}

			_FieldGroup.prototype.init.call(this);
		};

		_proto.initComponents = function initComponents(context, instance) {
			var _FieldGroup$prototype2;

			return (_FieldGroup$prototype2 = _FieldGroup.prototype.initComponents).call.apply(
				_FieldGroup$prototype2,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						label: this.label
					}
				])
			);
		};

		_proto.renderLabel = function renderLabel(context, instance, key) {
			if (instance.components.label) return instance.components.label.render(context, key);
		};

		_proto.render = function render(context, instance, key) {
			return {
				label: this.renderLabel(context, instance),
				content: this.renderChildren(context, instance)
			};
		};

		return LabeledContainer;
	})(FieldGroup);
Widget.alias("labeled-container", LabeledContainer);

function minDate() {
	var min = arguments[0];

	for (var i = 1; i < arguments.length; i++) {
		if (dateDiff(min, arguments[i]) > 0) min = arguments[i];
	}

	return min;
}

function maxDate() {
	var max = arguments[0];

	for (var i = 1; i < arguments.length; i++) {
		if (dateDiff(max, arguments[i]) < 0) max = arguments[i];
	}

	return max;
}

enableCultureSensitiveFormatting();
var MonthPicker =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(MonthPicker, _Field);

		function MonthPicker() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = MonthPicker.prototype;

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			var values = {};

			if (this.mode == "range") {
				this.range = true;
				this.mode = "edit";
				Console.warn('Please use the range flag on MonthPickers. Syntax mode="range" is deprecated.', this);
			}

			if (this.range) {
				values = {
					from: null,
					to: null
				};
			} else {
				values = {
					value: null
				};
			}

			(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[
					this,
					values,
					{
						refDate: undefined,
						disabled: undefined,
						minValue: undefined,
						minExclusive: undefined,
						maxValue: undefined,
						maxExclusive: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.init = function init() {
			_Field.prototype.init.call(this);
		};

		_proto.prepareData = function prepareData(context, _ref) {
			var data = _ref.data;
			data.stateMods = {
				disabled: data.disabled
			};
			if (!this.range && data.value) data.date = monthStart(new Date(data.value));

			if (this.range) {
				if (data.from) data.from = monthStart(new Date(data.from));
				if (data.to) data.to = monthStart(new Date(data.to));
			}

			if (data.refDate) data.refDate = monthStart(new Date(data.refDate));
			if (data.maxValue) data.maxValue = monthStart(new Date(data.maxValue));
			if (data.minValue) data.minValue = monthStart(new Date(data.minValue));

			_Field.prototype.prepareData.apply(this, arguments);
		};

		_proto.validate = function validate(context, instance) {
			_Field.prototype.validate.call(this, context, instance);

			var data = instance.data;

			if (!data.error && data.date) {
				var d;

				if (data.maxValue) {
					d = dateDiff(data.date, data.maxValue);
					if (d > 0) data.error = StringTemplate.format(this.maxValueErrorText, data.maxValue);
					else if (d == 0 && data.maxExclusive)
						data.error = StringTemplate.format(this.maxExclusiveErrorText, data.maxValue);
				}

				if (data.minValue) {
					d = dateDiff(data.date, data.minValue);
					if (d < 0) data.error = StringTemplate.format(this.minValueErrorText, data.minValue);
					else if (d == 0 && data.minExclusive)
						data.error = StringTemplate.format(this.minExclusiveErrorText, data.minValue);
				}
			}
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			return VDOM$2.createElement(MonthPickerComponent, {
				key: key,
				instance: instance,
				onBlur: this.onBlur,
				onFocusOut: this.onFocusOut,
				onKeyDown: this.onKeyDown,
				autoFocus: this.autoFocus
			});
		};

		_proto.handleSelect = function handleSelect(e, instance, date1, date2) {
			var data = instance.data;
			if (data.disabled) return;
			if (!validationCheck$1(date1, data)) return;
			if (this.onBeforeSelect && instance.invoke("onBeforeSelect", e, instance, date1, date2) === false) return;

			if (this.range) {
				instance.set("from", date1.toISOString());
				instance.set("to", date2.toISOString());
			} else instance.set("value", date1.toISOString());

			if (this.onSelect) instance.invoke("onSelect", instance, date1, date2);
		};

		return MonthPicker;
	})(Field);
MonthPicker.prototype.baseClass = "monthpicker";
MonthPicker.prototype.range = false;
MonthPicker.prototype.startYear = 1980;
MonthPicker.prototype.endYear = 2030;
MonthPicker.prototype.bufferSize = 15; // Localization

MonthPicker.prototype.maxValueErrorText = "Select {0:d} or before.";
MonthPicker.prototype.maxExclusiveErrorText = "Select a date before {0:d}.";
MonthPicker.prototype.minValueErrorText = "Select {0:d} or later.";
MonthPicker.prototype.minExclusiveErrorText = "Select a date after {0:d}.";
Localization.registerPrototype("cx/widgets/MonthPicker", MonthPicker);
Widget.alias("month-picker", MonthPicker);

var validationCheck$1 = function validationCheck(date, data) {
	if (data.maxValue && !upperBoundCheck(date, data.maxValue, data.maxExclusive)) return false;
	if (data.minValue && !lowerBoundCheck(date, data.minValue, data.minExclusive)) return false;
	return true;
};

var monthNumber = function monthNumber(date) {
	return date.getFullYear() * 12 + date.getMonth();
};

var MonthPickerComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(MonthPickerComponent, _VDOM$Component);

		function MonthPickerComponent(props) {
			var _context;

			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			var _props$instance = props.instance,
				data = _props$instance.data,
				widget = _props$instance.widget;
			var cursor = monthStart(data.refDate ? data.refDate : data.date || data.from || new Date());
			_this.dom = {};
			_this.state = {
				cursorYear: cursor.getFullYear(),
				cursorMonth: cursor.getMonth() + 1,
				cursorQuarter: cursor.getMonth() / 3,
				column: "M",
				start: widget.startYear,
				end: widget.startYear + widget.bufferSize
			};
			_this.handleMouseDown = (_context = _this).handleMouseDown.bind(_context);
			_this.handleMouseUp = (_context = _this).handleMouseUp.bind(_context);
			_this.handleMouseEnter = (_context = _this).handleMouseEnter.bind(_context);
			_this.handleKeyPress = (_context = _this).handleKeyPress.bind(_context);
			_this.handleTouchMove = (_context = _this).handleTouchMove.bind(_context);
			_this.handleTouchEnd = (_context = _this).handleTouchEnd.bind(_context);
			return _this;
		}

		var _proto2 = MonthPickerComponent.prototype;

		_proto2.extractCursorInfo = function extractCursorInfo(el) {
			if (!el.attributes["data-point"].value) return false;
			var parts = el.attributes["data-point"].value.split("-");
			if (parts[0] != "Y") return false;
			var cursor = {
				column: "Y",
				cursorYear: Number(parts[1])
			};

			if (parts.length == 4) {
				cursor.column = parts[2];
				if (cursor.column == "M") cursor.cursorMonth = Number(parts[3]);
				else cursor.cursorQuarter = Number(parts[3]);
			}

			return cursor;
		};

		_proto2.moveCursor = function moveCursor(e, data, options) {
			var _this2 = this;

			if (options === void 0) {
				options = {};
			}

			e.preventDefault();
			e.stopPropagation();

			if (data.cursorYear) {
				var _this$props$instance$ = this.props.instance.widget,
					startYear = _this$props$instance$.startYear,
					endYear = _this$props$instance$.endYear;
				data.cursorYear = Math.max(startYear, Math.min(endYear, data.cursorYear));
			}

			if (
				Object.keys(data).every(function(k) {
					return _this2.state[k] == data[k];
				})
			)
				return;
			this.setState(data, function() {
				if (options.ensureVisible) {
					var index = _this2.state.cursorYear - _this2.state.start;
					var tbody = _this2.dom.table.children[index];
					if (tbody) scrollElementIntoView(tbody);
				}
			});
		};

		_proto2.handleKeyPress = function handleKeyPress(e) {
			var widget = this.props.instance.widget;
			var _this$state = this.state,
				cursorMonth = _this$state.cursorMonth,
				cursorYear = _this$state.cursorYear,
				cursorQuarter = _this$state.cursorQuarter,
				column = _this$state.column;

			switch (e.keyCode) {
				case KeyCode.enter:
					// if (widget.range && e.shiftKey && !this.dragStartDates) {
					//    this.handleMouseDown(e, {}, false);
					// } else {
					//    this.handleMouseUp(e);
					// }
					this.handleMouseUp(e);
					e.preventDefault();
					e.stopPropagation();
					break;

				case KeyCode.left:
					if (column == "Y")
						this.moveCursor(e, {
							cursorQuarter: 3,
							cursorYear: cursorYear - 1,
							column: "Q"
						});
					else if (column == "Q")
						this.moveCursor(e, {
							cursorMonth: cursorQuarter * 4,
							column: "M"
						});
					else if (column == "M" && (cursorMonth - 1) % 3 == 0)
						this.moveCursor(e, {
							column: "Y"
						});
					else
						this.moveCursor(e, {
							cursorMonth: cursorMonth - 1
						});
					break;

				case KeyCode.right:
					if (column == "Y")
						this.moveCursor(e, {
							cursorMonth: 1,
							column: "M"
						});
					else if (column == "Q")
						this.moveCursor(e, {
							column: "Y",
							cursorYear: cursorQuarter == 3 ? cursorYear + 1 : cursorYear
						});
					else if (column == "M" && (cursorMonth - 1) % 3 == 2)
						this.moveCursor(e, {
							column: "Q",
							cursorQuarter: Math.floor((cursorMonth - 1) / 3)
						});
					else
						this.moveCursor(e, {
							cursorMonth: cursorMonth + 1
						});
					break;

				case KeyCode.up:
					if (column == "Y")
						this.moveCursor(
							e,
							{
								cursorYear: cursorYear - 1
							},
							{
								ensureVisible: true
							}
						);
					else if (column == "Q")
						this.moveCursor(
							e,
							{
								cursorQuarter: (cursorQuarter + 3) % 4,
								cursorYear: cursorQuarter == 0 ? cursorYear - 1 : cursorYear
							},
							{
								ensureVisible: true
							}
						);
					else if (column == "M")
						if (cursorMonth > 3)
							this.moveCursor(
								e,
								{
									cursorMonth: cursorMonth - 3
								},
								{
									ensureVisible: true
								}
							);
						else
							this.moveCursor(
								e,
								{
									cursorMonth: cursorMonth + 9,
									cursorYear: cursorYear - 1
								},
								{
									ensureVisible: true
								}
							);
					break;

				case KeyCode.down:
					if (column == "Y")
						this.moveCursor(
							e,
							{
								cursorYear: cursorYear + 1
							},
							{
								ensureVisible: true
							}
						);
					else if (column == "Q")
						this.moveCursor(
							e,
							{
								cursorQuarter: (cursorQuarter + 1) % 4,
								cursorYear: cursorQuarter == 3 ? cursorYear + 1 : cursorYear
							},
							{
								ensureVisible: true
							}
						);
					else if (column == "M")
						if (cursorMonth < 10)
							this.moveCursor(
								e,
								{
									cursorMonth: cursorMonth + 3
								},
								{
									ensureVisible: true
								}
							);
						else
							this.moveCursor(
								e,
								{
									cursorMonth: cursorMonth - 9,
									cursorYear: cursorYear + 1
								},
								{
									ensureVisible: true
								}
							);
					break;

				case KeyCode.pageUp:
					this.moveCursor(e, {
						cursorYear: this.state.cursorYear - 1
					});
					break;

				case KeyCode.pageDown:
					this.moveCursor(e, {
						cursorYear: this.state.cursorYear + 1
					});
					break;

				default:
					if (this.props.onKeyDown) this.props.onKeyDown(e, this.props.instance);
					break;
			}
		};

		_proto2.handleBlur = function handleBlur(e) {
			FocusManager.nudge();
			if (this.props.onBlur) this.props.onBlur();
			this.setState({
				focused: false
			});
		};

		_proto2.handleFocus = function handleFocus(e) {
			this.setState({
				focused: true
			});
			if (this.props.onFocusOut) oneFocusOut(this, this.dom.el, this.handleFocusOut.bind(this));
		};

		_proto2.handleFocusOut = function handleFocusOut() {
			if (this.props.onFocusOut) this.props.onFocusOut();
		};

		_proto2.getCursorDates = function getCursorDates(cursor) {
			var _ref2 = cursor || this.state,
				cursorMonth = _ref2.cursorMonth,
				cursorYear = _ref2.cursorYear,
				cursorQuarter = _ref2.cursorQuarter,
				column = _ref2.column;

			switch (column) {
				case "M":
					return [new Date(cursorYear, cursorMonth - 1, 1), new Date(cursorYear, cursorMonth, 1)];

				case "Q":
					return [new Date(cursorYear, cursorQuarter * 3, 1), new Date(cursorYear, cursorQuarter * 3 + 3, 1)];

				case "Y":
					return [new Date(cursorYear, 0, 1), new Date(cursorYear + 1, 0, 1)];
			}
		};

		_proto2.handleTouchMove = function handleTouchMove(e) {
			var cursor = getCursorPos(e);
			var el = document.elementFromPoint(cursor.clientX, cursor.clientY);

			if (this.dom.table.contains(el) && isString(el.dataset.point)) {
				var _cursor = this.extractCursorInfo(el);

				this.moveCursor(e, _cursor);
			}
		};

		_proto2.handleTouchEnd = function handleTouchEnd(e) {
			if (this.state.state == "drag") this.handleMouseUp(e);
		};

		_proto2.handleMouseEnter = function handleMouseEnter(e) {
			var cursor = this.extractCursorInfo(e.target);
			cursor.hover = !isTouchEvent();
			this.moveCursor(e, cursor);
		};

		_proto2.handleMouseDown = function handleMouseDown(e, cursor, drag) {
			if (drag === void 0) {
				drag = true;
			}

			var instance = this.props.instance;
			var widget = instance.widget;

			if (!cursor) {
				cursor = this.extractCursorInfo(e.currentTarget);
				this.moveCursor(e, cursor);
			}

			e.stopPropagation();
			preventFocusOnTouch(e);
			this.dragStartDates = this.getCursorDates(cursor);

			if (drag) {
				this.setState(
					_objectSpread(
						{
							state: "drag"
						},
						cursor
					)
				);
			}
		};

		_proto2.handleMouseUp = function handleMouseUp(e) {
			var instance = this.props.instance;
			var widget = instance.widget,
				data = instance.data;
			e.stopPropagation();
			e.preventDefault();

			var _this$getCursorDates = this.getCursorDates(),
				cursorFromDate = _this$getCursorDates[0],
				cursorToDate = _this$getCursorDates[1];

			var originFromDate = cursorFromDate,
				originToDate = cursorToDate;

			if (widget.range && e.shiftKey) {
				if (data.from) originFromDate = data.from;
				if (data.to) originToDate = data.to;
			} else if (this.state.state == "drag") {
				if (widget.range) {
					var _this$dragStartDates = this.dragStartDates;
					originFromDate = _this$dragStartDates[0];
					originToDate = _this$dragStartDates[1];
				}

				this.setState({
					state: "normal"
				});
			} else {
				//skip mouse events originated somewhere else
				if (e.type != "keydown") return;
			}

			widget.handleSelect(e, instance, minDate(originFromDate, cursorFromDate), maxDate(originToDate, cursorToDate));
		};

		_proto2.render = function render() {
			var _this3 = this;

			var _this$props$instance = this.props.instance,
				data = _this$props$instance.data,
				widget = _this$props$instance.widget;
			var CSS = widget.CSS,
				baseClass = widget.baseClass,
				startYear = widget.startYear,
				endYear = widget.endYear;
			var years = [];
			var _this$state2 = this.state,
				start = _this$state2.start,
				end = _this$state2.end;
			var from = 10000,
				to = 0,
				a,
				b;

			if (data.date && !widget.range) {
				from = monthNumber(data.date);
				to = from + 0.1;
			} else if (widget.range) {
				if (this.state.state == "drag") {
					var _this$dragStartDates2 = this.dragStartDates,
						originFromDate = _this$dragStartDates2[0],
						originToDate = _this$dragStartDates2[1];

					var _this$getCursorDates2 = this.getCursorDates(),
						cursorFromDate = _this$getCursorDates2[0],
						cursorToDate = _this$getCursorDates2[1];

					a = Math.min(monthNumber(originFromDate), monthNumber(cursorFromDate));
					b = Math.max(monthNumber(originToDate), monthNumber(cursorToDate));
					from = Math.min(a, b);
					to = Math.max(a, b);
				} else if (data.from && data.to) {
					a = monthNumber(data.from);
					b = monthNumber(data.to);
					from = Math.min(a, b);
					to = Math.max(a, b);
				}
			}

			var monthNames = Culture.getDateTimeCulture().getMonthNames("short");
			var showCursor = this.state.hover || this.state.focused;

			for (var y = start; y <= end; y++) {
				var rows = [];

				for (var q = 0; q < 4; q++) {
					var row = [];
					if (q == 0)
						row.push(
							VDOM$2.createElement(
								"th",
								{
									key: "year",
									rowSpan: 4,
									"data-point": "Y-" + y,
									className: CSS.element(baseClass, "year", {
										cursor: showCursor && this.state.column == "Y" && y == this.state.cursorYear
									}),
									onMouseEnter: this.handleMouseEnter,
									onMouseDown: this.handleMouseDown,
									onMouseUp: this.handleMouseUp
								},
								y
							)
						);

					for (var i = 0; i < 3; i++) {
						var m = q * 3 + i + 1;
						var unselectable = !validationCheck$1(new Date(y, m - 1, 1), data);
						var mno = y * 12 + m - 1;
						var handle = true; //isTouchDevice(); //mno === from || mno === to - 1;

						row.push(
							VDOM$2.createElement(
								"td",
								{
									key: "M" + m,
									className: CSS.state({
										cursor:
											showCursor &&
											this.state.column == "M" &&
											y == this.state.cursorYear &&
											m == this.state.cursorMonth,
										handle: handle,
										selected: mno >= from && mno < to,
										unselectable: unselectable
									}),
									"data-point": "Y-" + y + "-M-" + m,
									onMouseEnter: unselectable ? null : this.handleMouseEnter,
									onMouseDown: unselectable ? null : this.handleMouseDown,
									onMouseUp: unselectable ? null : this.handleMouseUp,
									onTouchStart: unselectable ? null : this.handleMouseDown,
									onTouchMove: unselectable ? null : this.handleTouchMove,
									onTouchEnd: this.handleMouseUp
								},
								monthNames[m - 1].substr(0, 3)
							)
						);
					}

					row.push(
						VDOM$2.createElement(
							"th",
							{
								key: "q" + q,
								className: CSS.state({
									cursor:
										showCursor &&
										this.state.column == "Q" &&
										y == this.state.cursorYear &&
										q == this.state.cursorQuarter
								}),
								"data-point": "Y-" + y + "-Q-" + q,
								onMouseEnter: this.handleMouseEnter,
								onMouseDown: this.handleMouseDown,
								onMouseUp: this.handleMouseUp
							},
							"Q" + (q + 1)
						)
					);
					rows.push(row);
				}

				years.push(rows);
			}

			return VDOM$2.createElement(
				"div",
				{
					ref: function ref(el) {
						_this3.dom.el = el;
					},
					className: data.classNames,
					style: data.style,
					tabIndex: data.disabled ? null : data.tabIndex || 0,
					onKeyDown: this.handleKeyPress,
					onMouseDown: stopPropagation,
					onMouseMove: function onMouseMove(e) {
						return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(_this3.props.instance)));
					},
					onMouseLeave: this.handleMouseLeave.bind(this),
					onFocus: function onFocus(e) {
						return _this3.handleFocus(e);
					},
					onBlur: this.handleBlur.bind(this),
					onScroll: this.onScroll.bind(this)
				},
				this.state.yearHeight &&
					VDOM$2.createElement("div", {
						style: {
							height: (start - startYear) * this.state.yearHeight + "px"
						}
					}),
				VDOM$2.createElement(
					"table",
					{
						ref: function ref(el) {
							_this3.dom.table = el;
						}
					},
					years.map(function(rows, y) {
						return VDOM$2.createElement(
							"tbody",
							{
								key: start + y
							},
							rows.map(function(cells, i) {
								return VDOM$2.createElement(
									"tr",
									{
										key: i
									},
									cells
								);
							})
						);
					})
				),
				this.state.yearHeight &&
					VDOM$2.createElement("div", {
						style: {
							height: Math.max(0, endYear - end) * this.state.yearHeight + "px"
						}
					})
			);
		};

		_proto2.onScroll = function onScroll() {
			var _this$props$instance$2 = this.props.instance.widget,
				startYear = _this$props$instance$2.startYear,
				endYear = _this$props$instance$2.endYear,
				bufferSize = _this$props$instance$2.bufferSize;
			var visibleItems = ceil5(Math.ceil(this.dom.el.offsetHeight / this.state.yearHeight));
			var start = Math.max(
				startYear,
				startYear + floor5(Math.floor(this.dom.el.scrollTop / this.state.yearHeight)) - visibleItems
			);

			if (start != this.state.start && start + bufferSize <= endYear) {
				this.setState({
					start: start,
					end: start + 15
				});
			}
		};

		_proto2.handleMouseLeave = function handleMouseLeave(e) {
			tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(this.props.instance)));
			this.moveCursor(e, {
				hover: false
			});
		};

		_proto2.componentDidMount = function componentDidMount() {
			var _this4 = this;

			//non-input, ok to focus on mobile
			if (this.props.autoFocus) this.dom.el.focus();
			tooltipParentDidMount.apply(void 0, [this.dom.el].concat(getFieldTooltip(this.props.instance)));
			var yearHeight = this.dom.table.scrollHeight / (this.props.instance.widget.bufferSize + 1);
			this.setState(
				{
					yearHeight: yearHeight
				},
				function() {
					var _this4$props$instance = _this4.props.instance,
						widget = _this4$props$instance.widget,
						data = _this4$props$instance.data;
					var startYear = widget.startYear;
					var yearCount = 1;

					if (widget.range && data.from && data.to) {
						yearCount = data.to.getFullYear() - data.from.getFullYear() + 1;
						if (data.to.getMonth() == 0 && data.to.getDate() == 1) yearCount--;
					}

					_this4.dom.el.scrollTop =
						(_this4.state.cursorYear - startYear + yearCount / 2) * _this4.state.yearHeight -
						_this4.dom.el.offsetHeight / 2;
				}
			);
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			this.setState({
				state: "normal"
			});
			tooltipParentWillReceiveProps.apply(void 0, [this.dom.el].concat(getFieldTooltip(props.instance)));
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			offFocusOut(this);
			tooltipParentWillUnmount(this.props.instance);
		};

		return MonthPickerComponent;
	})(VDOM$2.Component);

function ceil5(x) {
	return Math.ceil(x / 5) * 5;
}

function floor5(x) {
	return Math.floor(x / 5) * 5;
}

function hue2rgb(p, q, t) {
	if (t < 0) t += 1;
	if (t > 1) t -= 1;
	if (t < 1 / 6) return p + (q - p) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	return p;
}
function hslToRgb(h, s, l) {
	h /= 360;
	s /= 100;
	l /= 100;
	var r, g, b;

	if (s == 0) {
		r = g = b = l; // achromatic
	} else {
		var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		var p = 2 * l - q;
		r = hue2rgb(p, q, h + 1 / 3);
		g = hue2rgb(p, q, h);
		b = hue2rgb(p, q, h - 1 / 3);
	}

	return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function rgbToHsl(r, g, b) {
	r /= 255;
	g /= 255;
	b /= 255;
	var max = Math.max(r, g, b),
		min = Math.min(r, g, b);
	var h,
		s,
		l = (max + min) / 2;

	if (max == min) {
		h = s = 0; // achromatic
	} else {
		var d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

		switch (max) {
			case r:
				h = (g - b) / d + (g < b ? 6 : 0);
				break;

			case g:
				h = (b - r) / d + 2;
				break;

			case b:
				h = (r - g) / d + 4;
				break;
		}

		h /= 6;
	}

	return [h * 360, s * 100, l * 100];
}

function componentToHex(c) {
	var hex = c.toString(16);
	return hex.length == 1 ? "0" + hex : hex;
}

function rgbToHex(r, g, b) {
	return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

function parseColor(color) {
	if (!color) return null;
	if (color[0] == "#") return parseHexColor(color);
	if (color.indexOf("rgb") == 0) return parseRgbColor(color);
	if (color.indexOf("hsl") == 0) return parseHslColor(color);
	throw new Error("Unknown color format: " + color + ".");
}
function parseHexColor(color) {
	if (!color) return null;
	if (color[0] != "#") throw new Error("Invalid color " + color + ".");
	if (color.length == 4)
		return {
			type: "rgba",
			r: parseInt(color.charAt(1), 16) * 0x11,
			g: parseInt(color.charAt(2), 16) * 0x11,
			b: parseInt(color.charAt(3), 16) * 0x11,
			a: 1
		};
	if (color.length != 7) throw new Error("Invalid color " + color + ".");
	return {
		type: "rgba",
		r: parseInt(color.substr(1, 2), 16),
		g: parseInt(color.substr(3, 2), 16),
		b: parseInt(color.substr(5, 2), 16),
		a: 1
	};
}
function parseRgbColor(color) {
	if (!color) return null;
	color = color.trim();
	var values;

	if (color.indexOf("rgba(") == 0) {
		values = color
			.substring(5, color.length - 1)
			.split(",")
			.map(function(x) {
				return parseFloat(x.trim());
			});
		if (values.length != 4) throw new Error("Invalid color " + color + ".");
		return {
			type: "rgba",
			r: values[0],
			g: values[1],
			b: values[2],
			a: values[3]
		};
	}

	if (color.indexOf("rgb(") != 0) throw new Error("Invalid color " + color + ".");
	values = color
		.substring(5, color.length - 1)
		.split(",")
		.map(function(x) {
			return parseFloat(x.trim());
		});
	if (values.length != 3) throw new Error("Invalid color " + color + ".");
	return {
		type: "rgba",
		r: values[0],
		g: values[1],
		b: values[2],
		a: 1
	};
}
function parseHslColor(color) {
	if (!color) return null;
	color = color.trim();
	var values;

	if (color.indexOf("hsla(") == 0) {
		values = color
			.substring(5, color.length - 1)
			.split(",")
			.map(function(x) {
				return parseFloat(x.trim());
			});
		if (values.length != 4) throw new Error("Invalid color " + color + ".");
		return {
			type: "hsla",
			h: values[0],
			s: values[1],
			l: values[2],
			a: values[3]
		};
	}

	if (color.indexOf("hsl(") != 0) throw new Error("Invalid color " + color + ".");
	values = color
		.substring(5, color.length - 1)
		.split(",")
		.map(function(x) {
			return parseFloat(x.trim());
		});
	if (values.length != 3) throw new Error("Invalid color " + color + ".");
	return {
		type: "hsla",
		h: values[0],
		s: values[1],
		l: values[2],
		a: 1
	};
}

//shamelessly taken from https://davidwalsh.name/vendor-prefix
var getPrefixes = function getPrefixes() {
	var styles = window.getComputedStyle(document.documentElement, ""),
		pre = (Array.prototype.slice
			.call(styles)
			.join("")
			.match(/-(moz|webkit|ms)-/) ||
			(styles.OLink === "" && ["", "o"]))[1],
		dom = "WebKit|Moz|MS|O".match(new RegExp("(" + pre + ")", "i"))[1];
	return {
		dom: dom,
		lowercase: pre,
		css: "-" + pre + "-",
		js: pre[0].toUpperCase() + pre.substr(1)
	};
};

var prefixes;
function getVendorPrefix(type) {
	if (!prefixes) prefixes = getPrefixes();
	return prefixes[type];
}

//TODO: Resolve alpha input problems

var ColorPicker =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(ColorPicker, _Field);

		function ColorPicker() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = ColorPicker.prototype;

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[
					this,
					{
						value: null,
						format: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			return VDOM$2.createElement(ColorPickerComponent, {
				key: key,
				instance: instance
			});
		};

		_proto.handleEvent = function handleEvent(eventType, instance, color) {
			var data = instance.data;

			if (this.reportOn.indexOf(eventType) != -1) {
				var value;

				switch (data.format) {
					default:
					case "rgba":
						value =
							"rgba(" +
							color.r.toFixed(0) +
							"," +
							color.g.toFixed(0) +
							"," +
							color.b.toFixed(0) +
							"," +
							Math.round(color.a * 100) / 100 +
							")";
						break;

					case "hsla":
						value =
							"hsla(" +
							color.h.toFixed(0) +
							"," +
							color.s.toFixed(0) +
							"%," +
							color.l.toFixed(0) +
							"%," +
							Math.round(color.a * 100) / 100 +
							")";
						break;

					case "hex":
						value = rgbToHex(color.r, color.g, color.b);
						break;
				}

				instance.set("value", value);
			}
		};

		return ColorPicker;
	})(Field);
ColorPicker.prototype.baseClass = "colorpicker";
ColorPicker.prototype.reportOn = "blur change";
ColorPicker.prototype.format = "rgba";
Widget.alias("color-picker", ColorPicker);

var ColorPickerComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(ColorPickerComponent, _VDOM$Component);

		function ColorPickerComponent(props) {
			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			_this.data = props.instance.data;

			try {
				_this.state = _this.parse(props.instance.data.value);
			} catch (e) {
				//if web colors are used (e.g. red), fallback to the default color
				_this.state = _this.parse(null);
			}

			return _this;
		}

		var _proto2 = ColorPickerComponent.prototype;

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			var data = props.instance.data;
			var color = this.parse(data.value);
			if (color.r != this.state.r || color.g != this.state.g || color.b != this.state.b || color.a != this.state.a)
				this.setState(color);
		};

		_proto2.parse = function parse(color) {
			var c = parseColor(color);

			if (c == null) {
				c = {
					type: "rgba",
					r: 128,
					g: 128,
					b: 128,
					a: 0
				};
			}

			c.a = Math.round(c.a * 100) / 100;

			if (c.type == "rgba") {
				var _rgbToHsl = rgbToHsl(c.r, c.g, c.b),
					h = _rgbToHsl[0],
					s = _rgbToHsl[1],
					l = _rgbToHsl[2];

				return {
					r: c.r,
					g: c.g,
					b: c.b,
					h: h,
					s: s,
					l: l,
					a: c.a
				};
			}

			if (c.type == "hsla") {
				var _hslToRgb = hslToRgb(c.h, c.s, c.l),
					r = _hslToRgb[0],
					g = _hslToRgb[1],
					b = _hslToRgb[2];

				r = this.fix255(r);
				g = this.fix255(g);
				b = this.fix255(b);
				return {
					r: r,
					g: g,
					b: b,
					h: c.h,
					s: c.s,
					l: c.l,
					a: c.a
				};
			}

			throw new Error("Color " + color + " parsing failed.");
		};

		_proto2.render = function render() {
			var _this2 = this;

			var _this$state = this.state,
				h = _this$state.h,
				s = _this$state.s,
				l = _this$state.l,
				a = _this$state.a,
				r = _this$state.r,
				g = _this$state.g,
				b = _this$state.b;
			var instance = this.props.instance;
			var widget = instance.widget,
				data = instance.data;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var hcolor = "hsl(" + h + ",100%,50%)";
			var hsla = "hsla(" + h.toFixed(0) + "," + s.toFixed(0) + "%," + l.toFixed(0) + "%," + a + ")";
			var rgba = "rgba(" + r.toFixed(0) + "," + g.toFixed(0) + "," + b.toFixed(0) + "," + a + ")";
			var hex = rgbToHex(r, g, b);
			var alphaGradient =
				getVendorPrefix("css") +
				"linear-gradient(left, hsla(" +
				h +
				"," +
				s +
				"%," +
				l +
				"%,0) 0%, hsla(" +
				h +
				"," +
				s +
				"%," +
				l +
				"%,1) 100%)";
			return VDOM$2.createElement(
				"div",
				{
					className: data.classNames,
					style: data.style,
					onBlur: this.onBlur.bind(this),
					onMouseDown: stopPropagation,
					onTouchStart: stopPropagation
				},
				VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "picker"),
						style: {
							backgroundColor: hcolor
						},
						onMouseDown: this.onSLSelect.bind(this),
						onTouchStart: this.onSLSelect.bind(this)
					},
					VDOM$2.createElement("div", {
						className: CSS.element(baseClass, "indicator"),
						style: {
							left: "calc(" + s + "% - 4px)",
							top: "calc(" + (100 - l) + "% - 4px)",
							borderColor:
								"rgba(" + (r < 128 ? 255 : 0) + ", " + (g < 128 ? 255 : 0) + ", " + (b < 128 ? 255 : 0) + ", 0.5)"
						}
					})
				),
				VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "details")
					},
					VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "hue"),
							onMouseDown: this.onHueSelect.bind(this),
							onTouchStart: this.onHueSelect.bind(this),
							onWheel: function onWheel(e) {
								_this2.onWheel(e, "h", 10);
							}
						},
						VDOM$2.createElement("div", {
							className: CSS.element(baseClass, "indicator"),
							style: {
								left: "calc(" + h / 3.6 + "% - 2px)"
							}
						})
					),
					VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "inputs")
						},
						VDOM$2.createElement(
							"label",
							null,
							"H ",
							VDOM$2.createElement("input", {
								value: h.toFixed(0),
								onChange: function onChange(e) {
									_this2.onNumberChange(e, "h");
								},
								onWheel: function onWheel(e) {
									_this2.onWheel(e, "h", 10);
								}
							})
						),
						VDOM$2.createElement(
							"label",
							null,
							"S ",
							VDOM$2.createElement("input", {
								value: s.toFixed(0),
								onChange: function onChange(e) {
									_this2.onNumberChange(e, "s");
								},
								onWheel: function onWheel(e) {
									_this2.onWheel(e, "s", 5);
								}
							})
						),
						VDOM$2.createElement(
							"label",
							null,
							"L ",
							VDOM$2.createElement("input", {
								value: l.toFixed(0),
								onChange: function onChange(e) {
									_this2.onNumberChange(e, "l");
								},
								onWheel: function onWheel(e) {
									_this2.onWheel(e, "l", 5);
								}
							})
						),
						VDOM$2.createElement(
							"label",
							null,
							"A ",
							VDOM$2.createElement("input", {
								value: a,
								onChange: function onChange(e) {
									_this2.onNumberChange(e, "a");
								},
								onWheel: function onWheel(e) {
									_this2.onWheel(e, "a", 0.1);
								}
							})
						)
					),
					VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "alpha"),
							onMouseDown: this.onAlphaSelect.bind(this),
							onTouchStart: this.onAlphaSelect.bind(this),
							onWheel: function onWheel(e) {
								_this2.onWheel(e, "a", 0.1);
							}
						},
						VDOM$2.createElement("div", {
							style: {
								background: alphaGradient
							}
						}),
						VDOM$2.createElement("div", {
							className: CSS.element(baseClass, "indicator"),
							style: {
								left: "calc(" + a * 100 + "% - 2px)"
							}
						})
					),
					VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "inputs")
						},
						VDOM$2.createElement(
							"label",
							null,
							"R ",
							VDOM$2.createElement("input", {
								value: r.toFixed(0),
								onChange: function onChange(e) {
									_this2.onNumberChange(e, "r");
								},
								onWheel: function onWheel(e) {
									_this2.onWheel(e, "r", 5);
								}
							})
						),
						VDOM$2.createElement(
							"label",
							null,
							"G ",
							VDOM$2.createElement("input", {
								value: g.toFixed(0),
								onChange: function onChange(e) {
									_this2.onNumberChange(e, "g");
								},
								onWheel: function onWheel(e) {
									_this2.onWheel(e, "g", 5);
								}
							})
						),
						VDOM$2.createElement(
							"label",
							null,
							"B ",
							VDOM$2.createElement("input", {
								value: b.toFixed(0),
								onChange: function onChange(e) {
									_this2.onNumberChange(e, "b");
								},
								onWheel: function onWheel(e) {
									_this2.onWheel(e, "b", 5);
								}
							})
						),
						VDOM$2.createElement(
							"label",
							null,
							"A ",
							VDOM$2.createElement("input", {
								value: a,
								onChange: function onChange(e) {
									_this2.onNumberChange(e, "a");
								},
								onWheel: function onWheel(e) {
									_this2.onWheel(e, "a", 0.1);
								}
							})
						)
					),
					VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "preview")
						},
						VDOM$2.createElement(
							"div",
							{
								className: CSS.element(baseClass, "values")
							},
							VDOM$2.createElement("input", {
								value: hsla,
								readOnly: true
							}),
							VDOM$2.createElement("input", {
								value: rgba,
								readOnly: true
							}),
							VDOM$2.createElement("input", {
								value: hex,
								readOnly: true
							})
						),
						VDOM$2.createElement(
							"div",
							{
								className: CSS.element(baseClass, "color"),
								onClick: function onClick(e) {
									_this2.onColorClick(e);
								}
							},
							VDOM$2.createElement("div", {
								style: {
									backgroundColor: hsla
								}
							})
						)
					)
				)
			);
		};

		_proto2.onColorClick = function onColorClick(e) {
			var instance = this.props.instance;
			var widget = instance.widget;
			if (widget.onColorClick) instance.invoke("onColorClick", e, instance);
		};

		_proto2.onHueSelect = function onHueSelect(e) {
			var _this3 = this;

			e.preventDefault();
			e.stopPropagation();
			var el = e.currentTarget;
			var bounds = el.getBoundingClientRect();

			var move = function move(e) {
				var pos = getCursorPos(e);
				var x = Math.max(0, Math.min(1, (pos.clientX + 1 - bounds.left) / el.offsetWidth));

				_this3.setColorProp({
					h: x * 360
				});
			};

			captureMouseOrTouch(e, move);
			move(e);
		};

		_proto2.onAlphaSelect = function onAlphaSelect(e) {
			var _this4 = this;

			e.preventDefault();
			e.stopPropagation();
			var el = e.currentTarget;
			var bounds = getTopLevelBoundingClientRect(el);

			var move = function move(e) {
				var pos = getCursorPos(e);
				var x = Math.max(0, Math.min(1, (pos.clientX + 1 - bounds.left) / el.offsetWidth));

				_this4.setColorProp({
					a: x
				});
			};

			captureMouseOrTouch(e, move);
			move(e);
		};

		_proto2.onSLSelect = function onSLSelect(e) {
			var _this5 = this;

			e.preventDefault();
			e.stopPropagation();
			var el = e.currentTarget;
			var bounds = getTopLevelBoundingClientRect(el);

			var move = function move(e) {
				var pos = getCursorPos(e);
				var x = Math.max(0, Math.min(1, (pos.clientX + 1 - bounds.left) / el.offsetWidth));
				var y = Math.max(0, Math.min(1, (pos.clientY + 1 - bounds.top) / el.offsetWidth));
				var s = x;
				var l = 1 - y;

				_this5.setColorProp({
					s: s * 100,
					l: l * 100
				});
			};

			captureMouseOrTouch(e, move);
			move(e);
		};

		_proto2.fix255 = function fix255(v) {
			return Math.max(0, Math.min(255, Math.round(v)));
		};

		_proto2.setColorProp = function setColorProp(props, value) {
			var _this6 = this;

			if (isString(props)) {
				var _props;

				props = ((_props = {}), (_props[props] = value), _props);
			}

			var state = _objectSpread({}, this.state);

			var fixAlpha = false;

			for (var prop in props) {
				value = props[prop];

				switch (prop) {
					case "h":
						state.h = Math.min(360, Math.max(0, value));

						var _hslToRgb2 = hslToRgb(state.h, state.s, state.l);

						state.r = _hslToRgb2[0];
						state.g = _hslToRgb2[1];
						state.b = _hslToRgb2[2];
						fixAlpha = true;
						break;

					case "s":
						state.s = Math.min(100, Math.max(0, value));

						var _hslToRgb3 = hslToRgb(state.h, state.s, state.l);

						state.r = _hslToRgb3[0];
						state.g = _hslToRgb3[1];
						state.b = _hslToRgb3[2];
						fixAlpha = true;
						break;

					case "l":
						state.l = Math.min(100, Math.max(0, value));

						var _hslToRgb4 = hslToRgb(state.h, state.s, state.l);

						state.r = _hslToRgb4[0];
						state.g = _hslToRgb4[1];
						state.b = _hslToRgb4[2];
						fixAlpha = true;
						break;

					case "r":
					case "g":
					case "b":
						state[prop] = Math.round(Math.min(255, Math.max(0, value)));

						var _rgbToHsl2 = rgbToHsl(state.r, state.g, state.b),
							h = _rgbToHsl2[0],
							s = _rgbToHsl2[1],
							l = _rgbToHsl2[2];

						state.h = h;
						state.s = s;
						state.l = l;
						fixAlpha = true;
						break;

					case "a":
						state.a = Math.round(100 * Math.min(1, Math.max(0, value))) / 100;
						break;
				}
			}

			state.r = this.fix255(state.r);
			state.g = this.fix255(state.g);
			state.b = this.fix255(state.b);
			if (fixAlpha && state.a === 0) state.a = 1;
			this.setState(state, function() {
				_this6.props.instance.widget.handleEvent("change", _this6.props.instance, _this6.state);
			});
		};

		_proto2.onNumberChange = function onNumberChange(e, prop) {
			e.preventDefault();
			e.stopPropagation();
			var number = parseFloat(e.target.value || "0");
			this.setColorProp(prop, number);
		};

		_proto2.onWheel = function onWheel(e, prop, delta) {
			e.preventDefault();
			e.stopPropagation();
			var factor = e.deltaY < 0 ? 1 : -1;
			this.setColorProp(prop, this.state[prop] + delta * factor);
		};

		_proto2.onBlur = function onBlur() {
			this.props.instance.widget.handleEvent("blur", this.props.instance, this.state);
		};

		return ColorPickerComponent;
	})(VDOM$2.Component);

var MonthField =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(MonthField, _Field);

		function MonthField() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = MonthField.prototype;

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			if (this.mode == "range") {
				this.range = true;
				this.mode = "edit";
				Console.warn('Please use the range flag on MonthFields. Syntax mode="range" is deprecated.', this);
			}

			var values = {};

			if (this.range) {
				values = {
					from: null,
					to: null
				};
			} else {
				values = {
					value: null
				};
			}

			(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[
					this,
					values,
					{
						disabled: undefined,
						readOnly: undefined,
						enabled: undefined,
						placeholder: undefined,
						required: undefined,
						minValue: undefined,
						minExclusive: undefined,
						maxValue: undefined,
						maxExclusive: undefined,
						icon: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.isEmpty = function isEmpty(data) {
			return this.range ? data.from == null : data.value == null;
		};

		_proto.init = function init() {
			if (!this.culture) this.culture = new DateTimeCulture(Format.culture);
			if (isDefined(this.hideClear)) this.showClear = !this.hideClear;
			if (this.alwaysShowClear) this.showClear = true;

			_Field.prototype.init.call(this);
		};

		_proto.prepareData = function prepareData(context, instance) {
			_Field.prototype.prepareData.call(this, context, instance);

			var data = instance.data;
			var formatOptions = {
				year: "numeric",
				month: "short"
			};

			if (!this.range && data.value) {
				data.date = new Date(data.value);
				data.formatted = this.culture.format(data.date, formatOptions);
			} else if (this.range && data.from && data.to) {
				data.from = new Date(data.from);
				data.to = new Date(data.to);
				data.to.setDate(data.to.getDate() - 1);
				var fromStr = this.culture.format(data.from, formatOptions);
				var toStr = this.culture.format(data.to, formatOptions);
				if (fromStr != toStr) data.formatted = fromStr + " - " + toStr;
				else data.formatted = fromStr;
			}

			if (data.refDate) data.refDate = monthStart(new Date(data.refDate));
			if (data.maxValue) data.maxValue = monthStart(new Date(data.maxValue));
			if (data.minValue) data.minValue = monthStart(new Date(data.minValue));
			instance.lastDropdown = context.lastDropdown;
		};

		_proto.validateRequired = function validateRequired(context, instance) {
			var data = instance.data;

			if (this.range) {
				if (!data.from || !data.to) return this.requiredText;
			} else return _Field.prototype.validateRequired.call(this, context, instance);
		};

		_proto.validate = function validate(context, instance) {
			_Field.prototype.validate.call(this, context, instance);

			var data = instance.data;

			if (!data.error && data.date) {
				var d;

				if (data.maxValue) {
					d = dateDiff(data.date, data.maxValue);
					if (d > 0) data.error = StringTemplate.format(this.maxValueErrorText, data.maxValue);
					else if (d == 0 && data.maxExclusive)
						data.error = StringTemplate.format(this.maxExclusiveErrorText, data.maxValue);
				}

				if (data.minValue) {
					d = dateDiff(data.date, data.minValue);
					if (d < 0) data.error = StringTemplate.format(this.minValueErrorText, data.minValue);
					else if (d == 0 && data.minExclusive)
						data.error = StringTemplate.format(this.minExclusiveErrorText, data.minValue);
				}
			}
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			return VDOM$2.createElement(MonthInput, {
				key: key,
				data: instance.data,
				instance: instance,
				monthPicker: {
					value: this.value,
					from: this.from,
					to: this.to,
					range: this.range,
					minValue: this.minValue,
					maxValue: this.maxValue,
					minExclusive: this.minExclusive,
					maxExclusive: this.maxExclusive,
					maxValueErrorText: this.maxValueErrorText,
					maxExclusiveErrorText: this.maxExclusiveErrorText,
					minValueErrorText: this.minValueErrorText,
					minExclusiveErrorText: this.minExclusiveErrorText
				},
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help"))
			});
		};

		_proto.formatValue = function formatValue(context, _ref) {
			var data = _ref.data;
			return data.formatted || "";
		};

		_proto.parseDate = function parseDate(date) {
			if (!date) return null;
			if (date instanceof Date) return date;
			date = this.culture.parse(date, {
				useCurrentDateForDefaults: true
			});
			return date;
		};

		_proto.handleSelect = function handleSelect(instance, date1, date2) {
			instance.setState({
				inputError: false
			});
			var data = instance.data; //it's important not to set the same values as that causes weird behavior if debounce is used

			if (this.range) {
				var d1 = date1 ? date1.toISOString() : null;
				var d2 = date2 ? date2.toISOString() : null;
				if (d1 !== data.from) instance.set("from", d1);
				if (d2 !== data.to) instance.set("to", d2);
			} else {
				var value = date1 ? date1.toISOString() : null;
				if (value !== data.value) instance.set("value", value);
			}
		};

		return MonthField;
	})(Field);
MonthField.prototype.baseClass = "monthfield";
MonthField.prototype.maxValueErrorText = "Select {0:d} or before.";
MonthField.prototype.maxExclusiveErrorText = "Select a date before {0:d}.";
MonthField.prototype.minValueErrorText = "Select {0:d} or later.";
MonthField.prototype.minExclusiveErrorText = "Select a date after {0:d}.";
MonthField.prototype.inputErrorText = "Invalid date entered";
MonthField.prototype.suppressErrorsUntilVisited = true;
MonthField.prototype.icon = "calendar";
MonthField.prototype.showClear = true;
MonthField.prototype.alwaysShowClear = false;
MonthField.prototype.range = false;
MonthField.prototype.reactOn = "enter blur";
Localization.registerPrototype("cx/widgets/MonthField", MonthField);
Widget.alias("monthfield", MonthField);

var MonthInput =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(MonthInput, _VDOM$Component);

		function MonthInput(props) {
			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			_this.props.instance.component = _assertThisInitialized(_assertThisInitialized(_this));
			_this.state = {
				dropdownOpen: false,
				focus: false
			};
			return _this;
		}

		var _proto2 = MonthInput.prototype;

		_proto2.getDropdown = function getDropdown() {
			var _this2 = this;

			if (this.dropdown) return this.dropdown;
			var _this$props$instance = this.props.instance,
				widget = _this$props$instance.widget,
				lastDropdown = _this$props$instance.lastDropdown;

			var dropdown = _objectSpread(
				{
					scrollTracking: true,
					inline: !isTouchDevice() || !!lastDropdown,
					placementOrder:
						"down down-left down-right up up-left up-right right right-up right-down left left-up left-down",
					touchFriendly: true
				},
				widget.dropdownOptions,
				{
					type: Dropdown,
					relatedElement: this.input,
					items: _objectSpread(
						{
							type: MonthPicker
						},
						this.props.monthPicker,
						{
							autoFocus: true,
							onFocusOut: function onFocusOut(e) {
								_this2.closeDropdown(e);
							},
							onKeyDown: function onKeyDown(e) {
								return _this2.onKeyDown(e);
							},
							onSelect: function onSelect(e) {
								var touch = isTouchEvent(e);

								_this2.closeDropdown(e, function() {
									if (!touch) _this2.input.focus();
								});
							}
						}
					),
					constrain: true,
					firstChildDefinesWidth: true
				}
			);

			return (this.dropdown = Widget.create(dropdown));
		};

		_proto2.render = function render() {
			var _this3 = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				label = _this$props.label,
				help = _this$props.help,
				data = _this$props.data;
			var widget = instance.widget,
				state = instance.state;
			var CSS = widget.CSS,
				baseClass = widget.baseClass,
				suppressErrorsUntilVisited = widget.suppressErrorsUntilVisited;
			var insideButton, icon;

			if (!data.readOnly && !data.disabled) {
				if (
					widget.showClear &&
					(((widget.alwaysShowClear || !data.required) && !data.empty) || instance.state.inputError)
				)
					insideButton = VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "clear"),
							onMouseDown: function onMouseDown(e) {
								e.preventDefault();
								e.stopPropagation();
							},
							onClick: function onClick(e) {
								_this3.onClearClick(e);
							}
						},
						VDOM$2.createElement(ClearIcon, {
							className: CSS.element(baseClass, "icon")
						})
					);
				else
					insideButton = VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "right-icon")
						},
						VDOM$2.createElement(DropdownIcon, {
							className: CSS.element(baseClass, "icon")
						})
					);
			}

			if (data.icon) {
				icon = VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "left-icon")
					},
					Icon.render(data.icon, {
						className: CSS.element(baseClass, "icon")
					})
				);
			}

			var dropdown = false;
			if (this.state.dropdownOpen)
				dropdown = VDOM$2.createElement(Cx, {
					widget: this.getDropdown(),
					parentInstance: instance,
					options: {
						name: "monthfield-dropdown"
					},
					subscribe: true
				});
			var empty = this.input ? !this.input.value : data.empty;
			return VDOM$2.createElement(
				"div",
				{
					className: CSS.expand(
						data.classNames,
						CSS.state({
							visited: state.visited,
							focus: this.state.focus || this.state.dropdownOpen,
							icon: !!icon,
							empty: empty && !data.placeholder,
							error: data.error && (state.visited || !suppressErrorsUntilVisited || !empty)
						})
					),
					style: data.style,
					onMouseDown: this.onMouseDown.bind(this),
					onTouchStart: stopPropagation,
					onClick: stopPropagation
				},
				VDOM$2.createElement("input", {
					id: data.id,
					ref: function ref(el) {
						_this3.input = el;
					},
					type: "text",
					className: CSS.element(baseClass, "input"),
					style: data.inputStyle,
					defaultValue: data.formatted,
					disabled: data.disabled,
					readOnly: data.readOnly,
					tabIndex: data.tabIndex,
					placeholder: data.placeholder,
					onInput: function onInput(e) {
						return _this3.onChange(e, "input");
					},
					onChange: function onChange(e) {
						return _this3.onChange(e, "change");
					},
					onKeyDown: function onKeyDown(e) {
						return _this3.onKeyDown(e);
					},
					onBlur: function onBlur(e) {
						_this3.onBlur(e);
					},
					onFocus: function onFocus(e) {
						_this3.onFocus(e);
					},
					onMouseMove: function onMouseMove(e) {
						return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(_this3.props.instance)));
					},
					onMouseLeave: function onMouseLeave(e) {
						return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(_this3.props.instance)));
					}
				}),
				icon,
				insideButton,
				dropdown,
				label,
				help
			);
		};

		_proto2.onMouseDown = function onMouseDown(e) {
			e.stopPropagation();
			if (this.state.dropdownOpen) this.closeDropdown(e);
			else {
				this.openDropdownOnFocus = true;
			} //icon click

			if (e.target != this.input) {
				e.preventDefault();
				if (!this.state.dropdownOpen) this.openDropdown(e);
				else this.input.focus();
			}
		};

		_proto2.onFocus = function onFocus(e) {
			var instance = this.props.instance;
			var widget = instance.widget;

			if (widget.trackFocus) {
				this.setState({
					focus: true
				});
			}

			if (this.openDropdownOnFocus) this.openDropdown(e);
		};

		_proto2.onKeyDown = function onKeyDown(e) {
			var _this4 = this;

			var instance = this.props.instance;
			if (instance.widget.handleKeyDown(e, instance) === false) return;

			switch (e.keyCode) {
				case KeyCode.enter:
					e.stopPropagation();
					this.onChange(e, "enter");
					break;

				case KeyCode.esc:
					if (this.state.dropdownOpen) {
						e.stopPropagation();
						this.closeDropdown(e, function() {
							_this4.input.focus();
						});
					}

					break;

				case KeyCode.left:
				case KeyCode.right:
					e.stopPropagation();
					break;

				case KeyCode.down:
					this.openDropdown(e);
					e.stopPropagation();
					e.preventDefault();
					break;
			}
		};

		_proto2.onBlur = function onBlur(e) {
			if (!this.state.dropdownOpen)
				this.props.instance.setState({
					visited: true
				});
			if (this.state.focus)
				this.setState({
					focus: false
				});
			this.onChange(e, "blur");
		};

		_proto2.closeDropdown = function closeDropdown(e, callback) {
			var _this5 = this;

			if (this.state.dropdownOpen) {
				if (this.scrollableParents)
					this.scrollableParents.forEach(function(el) {
						el.removeEventListener("scroll", _this5.updateDropdownPosition);
					});
				this.props.instance.setState({
					visited: true
				});
				this.setState(
					{
						dropdownOpen: false
					},
					callback
				);
			} else if (callback) callback();
		};

		_proto2.openDropdown = function openDropdown(e) {
			var data = this.props.instance.data;
			this.openDropdownOnFocus = false;

			if (!this.state.dropdownOpen && !(data.disabled || data.readOnly)) {
				this.setState({
					dropdownOpen: true
				});
			}
		};

		_proto2.onClearClick = function onClearClick(e) {
			e.stopPropagation();
			e.preventDefault();
			var instance = this.props.instance;
			var widget = instance.widget;
			widget.handleSelect(instance, null, null);
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			var _props$instance = props.instance,
				data = _props$instance.data,
				state = _props$instance.state;

			if (data.formatted != this.input.value && (data.formatted != this.props.data.formatted || !state.inputError)) {
				this.input.value = data.formatted || "";
				props.instance.setState({
					inputError: false
				});
			}

			tooltipParentWillReceiveProps.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
		};

		_proto2.componentDidMount = function componentDidMount() {
			tooltipParentDidMount.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
			autoFocus(this.input, this);
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			autoFocus(this.input, this);
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			tooltipParentWillUnmount(this.props.instance);
		};

		_proto2.onChange = function onChange(e, eventType) {
			var instance = this.props.instance;
			var widget = instance.widget;
			if (widget.reactOn.indexOf(eventType) == -1) return;
			var parts = e.target.value.split("-");
			var date1 = widget.parseDate(parts[0]);
			var date2 = widget.parseDate(parts[1]) || date1;

			if ((date1 != null && isNaN(date1)) || (date2 != null && isNaN(date2))) {
				instance.setState({
					inputError: widget.inputErrorText
				});
			} else if (eventType == "blur" || eventType == "enter") {
				if (date2) date2 = new Date(date2.getFullYear(), date2.getMonth() + 1, 1);
				instance.setState({
					visited: true
				});
				widget.handleSelect(instance, date1, date2);
			}
		};

		return MonthInput;
	})(VDOM$2.Component);

var ColorField =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(ColorField, _Field);

		function ColorField() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = ColorField.prototype;

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[
					this,
					{
						value: null,
						disabled: undefined,
						readOnly: undefined,
						enabled: undefined,
						placeholder: undefined,
						required: undefined,
						format: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.init = function init() {
			if (isDefined(this.hideClear)) this.showClear = !this.hideClear;
			if (this.alwaysShowClear) this.showClear = true;

			_Field.prototype.init.call(this);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			data.stateMods = [
				data.stateMods,
				{
					empty: !data.value
				}
			];
			instance.lastDropdown = context.lastDropdown;

			_Field.prototype.prepareData.call(this, context, instance);
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			return VDOM$2.createElement(ColorInput, {
				key: key,
				instance: instance,
				data: instance.data,
				picker: {
					value: this.value,
					format: this.format
				},
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help"))
			});
		};

		return ColorField;
	})(Field);
ColorField.prototype.baseClass = "colorfield";
ColorField.prototype.format = "rgba";
ColorField.prototype.suppressErrorsUntilVisited = true;
ColorField.prototype.showClear = true;
ColorField.prototype.alwaysShowClear = false;
Widget.alias("color-field", ColorField);
Localization.registerPrototype("cx/widgets/ColorField", ColorField);

var ColorInput =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(ColorInput, _VDOM$Component);

		function ColorInput(props) {
			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			var data = _this.props.data;
			_this.data = data;
			_this.state = {
				dropdownOpen: false,
				focus: false
			};
			return _this;
		}

		var _proto2 = ColorInput.prototype;

		_proto2.getDropdown = function getDropdown() {
			var _this2 = this;

			if (this.dropdown) return this.dropdown;
			var _this$props$instance = this.props.instance,
				widget = _this$props$instance.widget,
				lastDropdown = _this$props$instance.lastDropdown;

			var dropdown = _objectSpread(
				{
					scrollTracking: true,
					autoFocus: true,
					//put focus on the dropdown to prevent opening the keyboard
					focusable: true,
					inline: !isTouchDevice() || !!lastDropdown,
					touchFriendly: true,
					placementOrder:
						" down down-left down-right up up-left up-right right right-up right-down left left-up left-down"
				},
				widget.dropdownOptions,
				{
					type: Dropdown,
					relatedElement: this.input,
					items: _objectSpread(
						{
							type: ColorPicker
						},
						this.props.picker,
						{
							onColorClick: function onColorClick(e) {
								e.stopPropagation();
								e.preventDefault();
								var touch = isTouchEvent(e);

								_this2.closeDropdown(e, function() {
									if (!touch) _this2.input.focus();
								});
							}
						}
					),
					onFocusOut: function onFocusOut() {
						_this2.closeDropdown();
					},
					firstChildDefinesHeight: true,
					firstChildDefinesWidth: true
				}
			);

			return (this.dropdown = Widget.create(dropdown));
		};

		_proto2.render = function render() {
			var _this3 = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				label = _this$props.label,
				help = _this$props.help,
				data = _this$props.data;
			var widget = instance.widget,
				state = instance.state;
			var CSS = widget.CSS,
				baseClass = widget.baseClass,
				suppressErrorsUntilVisited = widget.suppressErrorsUntilVisited;
			var insideButton;

			if (!data.readOnly && !data.disabled) {
				if (
					widget.showClear &&
					(((!data.required || widget.alwaysShowClear) && data.value != null) || instance.state.inputError)
				)
					insideButton = VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "clear"),
							onMouseDown: function onMouseDown(e) {
								e.preventDefault();
								e.stopPropagation();
							},
							onClick: function onClick(e) {
								_this3.onClearClick(e);
							}
						},
						VDOM$2.createElement(ClearIcon, {
							className: CSS.element(baseClass, "icon")
						})
					);
				else
					insideButton = VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "right-icon")
						},
						VDOM$2.createElement(DropdownIcon, {
							className: CSS.element(baseClass, "icon")
						})
					);
			}

			var well = VDOM$2.createElement(
				"div",
				{
					className: CSS.element(baseClass, "left-icon")
				},
				VDOM$2.createElement("div", {
					style: {
						backgroundColor: data.value
					}
				})
			);
			var dropdown = false;
			if (this.state.dropdownOpen)
				dropdown = VDOM$2.createElement(Cx, {
					widget: this.getDropdown(),
					parentInstance: instance,
					options: {
						name: "colorfield-dropdown"
					},
					subscribe: true
				});
			var empty = this.input ? !this.input.value : data.empty;
			return VDOM$2.createElement(
				"div",
				{
					className: CSS.expand(
						data.classNames,
						CSS.state({
							visited: state.visited,
							focus: this.state.focus || this.state.dropdownOpen,
							icon: true,
							empty: empty && !data.placeholder,
							error: data.error && (state.visited || !suppressErrorsUntilVisited || !empty)
						})
					),
					style: data.style,
					onMouseDown: this.onMouseDown.bind(this),
					onTouchStart: stopPropagation,
					onClick: stopPropagation
				},
				VDOM$2.createElement(
					"input",
					_extends(
						{
							id: data.id,
							ref: function ref(el) {
								_this3.input = el;
							},
							type: "text",
							className: CSS.element(baseClass, "input"),
							style: data.inputStyle,
							defaultValue: this.trim(data.value || ""),
							disabled: data.disabled,
							readOnly: data.readOnly,
							tabIndex: data.tabIndex,
							placeholder: data.placeholder
						},
						data.inputAttrs,
						{
							onInput: function onInput(e) {
								return _this3.onChange(e, "input");
							},
							onChange: function onChange(e) {
								return _this3.onChange(e, "change");
							},
							onKeyDown: function onKeyDown(e) {
								return _this3.onKeyDown(e);
							},
							onBlur: function onBlur(e) {
								_this3.onBlur(e);
							},
							onFocus: function onFocus(e) {
								_this3.onFocus(e);
							},
							onMouseMove: function onMouseMove(e) {
								return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
							},
							onMouseLeave: function onMouseLeave(e) {
								return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
							}
						}
					)
				),
				well,
				insideButton,
				dropdown,
				label,
				help
			);
		};

		_proto2.onMouseDown = function onMouseDown(e) {
			e.stopPropagation();
			if (this.state.dropdownOpen) this.closeDropdown(e);
			else {
				this.openDropdownOnFocus = true;
			} //icon click

			if (e.target != this.input) {
				e.preventDefault();
				if (!this.state.dropdownOpen) this.openDropdown(e);
				else this.input.focus();
			}
		};

		_proto2.onFocus = function onFocus(e) {
			if (this.openDropdownOnFocus) this.openDropdown(e);
			var instance = this.props.instance;
			var widget = instance.widget;

			if (widget.trackFocus) {
				this.setState({
					focus: true
				});
			}
		};

		_proto2.onKeyDown = function onKeyDown(e) {
			var _this4 = this;

			var instance = this.props.instance;
			if (instance.widget.handleKeyDown(e, instance) === false) return;

			switch (e.keyCode) {
				case KeyCode.enter:
					e.stopPropagation();
					this.onChange(e, "enter");
					break;

				case KeyCode.esc:
					if (this.state.dropdownOpen) {
						e.stopPropagation();
						this.closeDropdown(e, function() {
							_this4.input.focus();
						});
					}

					break;

				case KeyCode.left:
				case KeyCode.right:
					e.stopPropagation();
					break;

				case KeyCode.down:
					this.openDropdown(e);
					e.stopPropagation();
					e.preventDefault();
					break;
			}
		};

		_proto2.onBlur = function onBlur(e) {
			if (this.state.focus)
				this.setState({
					focus: false
				});
			this.onChange(e, "blur");
		};

		_proto2.closeDropdown = function closeDropdown(e, callback) {
			var _this5 = this;

			if (this.state.dropdownOpen) {
				if (this.scrollableParents)
					this.scrollableParents.forEach(function(el) {
						el.removeEventListener("scroll", _this5.updateDropdownPosition);
					});
				this.setState(
					{
						dropdownOpen: false
					},
					callback
				);
			} else if (callback) callback();
		};

		_proto2.openDropdown = function openDropdown(e) {
			var data = this.props.data;
			this.openDropdownOnFocus = false;

			if (!this.state.dropdownOpen && !(data.disabled || data.readOnly)) {
				this.setState({
					dropdownOpen: true
				});
			}
		};

		_proto2.trim = function trim(value) {
			return value.replace(/\s/g, "");
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			var _this$props2 = this.props,
				data = _this$props2.data,
				instance = _this$props2.instance;
			var state = instance.state;
			var nv = this.trim(data.value || "");

			if (nv != this.input.value && (this.data.value != data.value || !state.inputError)) {
				this.input.value = nv;
				instance.setState({
					inputError: false
				});
			}

			this.data = data;
			tooltipParentWillReceiveProps.apply(void 0, [this.input].concat(getFieldTooltip(instance)));
		};

		_proto2.componentDidMount = function componentDidMount() {
			tooltipParentDidMount.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
			if (this.props.instance.widget.autoFocus && !isTouchDevice()) this.input.focus();
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			tooltipParentWillUnmount(this.props.instance);
		};

		_proto2.onClearClick = function onClearClick(e) {
			var instance = this.props.instance;
			instance.set("value", null);
			instance.setState({
				inputError: false
			});
			e.stopPropagation();
			e.preventDefault();
		};

		_proto2.onChange = function onChange(e, eventType) {
			var _this$props3 = this.props,
				instance = _this$props3.instance,
				data = _this$props3.data;
			if (eventType == "blur")
				instance.setState({
					visited: true
				});
			var text = e.target.value;
			var isValid;

			try {
				parseColor(text);
				isValid = true;
			} catch (e) {
				isValid = false;
			}

			if (eventType == "blur" || eventType == "enter") {
				var value = text || null;
				if (isValid && value !== data.value) instance.set("value", value);
				instance.setState({
					inputError: !isValid && "Invalid color entered."
				});
			}
		};

		return ColorInput;
	})(VDOM$2.Component);

var UploadButton =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(UploadButton, _Field);

		function UploadButton() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = UploadButton.prototype;

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[
					this,
					{
						disabled: undefined,
						text: undefined,
						url: undefined,
						icon: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			var data = instance.data;
			return VDOM$2.createElement(
				UploadButtonComponent,
				{
					key: key,
					instance: instance
				},
				data.text || this.renderChildren(context, instance)
			);
		};

		return UploadButton;
	})(Field);
UploadButton.prototype.baseClass = "uploadbutton";
UploadButton.prototype.multiple = false;
UploadButton.prototype.method = "POST";
UploadButton.prototype.abortOnDestroy = false;
UploadButton.prototype.uploadInProgressText = "Upload is in progress.";
Localization.registerPrototype("cx/widgets/UploadButton", UploadButton);

var UploadButtonComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(UploadButtonComponent, _VDOM$Component);

		function UploadButtonComponent(props) {
			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			_this.uploads = {};
			_this.uploadKey = 0;
			_this.state = {
				progress: 100
			};
			return _this;
		}

		var _proto2 = UploadButtonComponent.prototype;

		_proto2.render = function render() {
			var _this2 = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				children = _this$props.children;
			var widget = instance.widget,
				data = instance.data;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var icon;
			var className = data.classNames;

			if (data.icon) {
				icon = Icon.render(data.icon, {
					className: CSS.element(baseClass, "icon")
				});
				className = CSS.expand(className, CSS.state("icon"), children.length == 0 && CSS.state("empty"));
			}

			return VDOM$2.createElement(
				"div",
				{
					ref: function ref(el) {
						_this2.el = el;
					},
					className: className,
					style: data.style
				},
				VDOM$2.createElement("div", {
					key: "progress",
					className: CSS.element(baseClass, "progress", {
						done: this.state.progress == 100
					}),
					style: {
						width: this.state.progress + "%"
					}
				}),
				icon,
				children,
				!data.disabled &&
					VDOM$2.createElement("input", {
						key: this.uploadKey,
						className: CSS.element(baseClass, "input"),
						type: "file",
						multiple: widget.multiple,
						tabIndex: data.tabIndex,
						onChange: this.onFileSelected.bind(this)
					})
			);
		};

		_proto2.onFileSelected = function onFileSelected(e) {
			var files = e.dataTransfer ? e.dataTransfer.files : e.target ? e.target.files : [];

			for (var i = 0; i < files.length; i++) {
				this.uploadFile(files[i]);
			}
		};

		_proto2.componentDidMount = function componentDidMount() {
			if (this.props.instance.data.autoFocus) this.el.focus();
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			if (this.props.instance.widget.abortOnDestroy) {
				for (var key in this.uploads) {
					var upload = this.uploads[key];
					upload.xhr.abort();
				}
			}
		};

		_proto2.uploadFile = function uploadFile(file) {
			var _this3 = this;

			var instance = this.props.instance;
			var data = instance.data,
				widget = instance.widget;

			if (widget.onResolveUrl) {
				Promise.resolve(instance.invoke("onResolveUrl", file, instance)).then(function(url) {
					_this3.doUpload(file, url);
				});
			} else {
				this.doUpload(file, data.url);
			}
		};

		_proto2.doUpload = function doUpload(file, url) {
			var _this4 = this;

			var instance = this.props.instance;
			var widget = instance.widget;
			if (!url) throw new Error("Upload URL not set.");
			var xhr = new XMLHttpRequest();
			xhr.open(widget.method, Url.resolve(url));
			var formData = new FormData();
			formData.append("file", file);
			if (widget.onUploadStarting && instance.invoke("onUploadStarting", xhr, instance, file, formData) === false)
				return;
			var key = this.uploadKey++;
			var upload = (this.uploads[key] = {
				progress: 0,
				size: file.size || 1,
				file: file,
				xhr: xhr
			});

			xhr.onload = function() {
				delete _this4.uploads[key];
				if (widget.onUploadComplete) instance.invoke("onUploadComplete", xhr, instance, file, formData);

				_this4.reportProgress();
			};

			xhr.onerror = function(e) {
				delete _this4.uploads[key];
				if (widget.onUploadError) instance.invoke("onUploadError", e, instance, file, formData);

				_this4.reportProgress();
			};

			xhr.upload.onprogress = function(event) {
				if (event.lengthComputable) {
					upload.progress = event.loaded / event.total;

					_this4.reportProgress();
				}
			};

			xhr.send(formData);
			this.reportProgress();
			this.forceUpdate();
		};

		_proto2.reportProgress = function reportProgress() {
			var totalSize = 0;
			var uploaded = 0;

			for (var key in this.uploads) {
				var upload = this.uploads[key];
				totalSize += upload.size;
				uploaded += upload.size * upload.progress;
			}

			var progress = 100 * (totalSize ? uploaded / totalSize : 1);
			this.props.instance.setState({
				inputError: progress == 100 ? false : this.props.instance.uploadInProgressText
			});
			this.setState({
				progress: Math.max(0.001, Math.floor(progress))
			});
		};

		return UploadButtonComponent;
	})(VDOM$2.Component);

Widget.alias("upload-button", UploadButton);

var Slider =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(Slider, _Field);

		function Slider() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = Slider.prototype;

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[
					this,
					{
						from: 0,
						to: 0,
						step: undefined,
						minValue: undefined,
						maxValue: undefined,
						increment: undefined,
						incrementPercentage: undefined,
						wheel: undefined,
						disabled: undefined,
						readOnly: undefined,
						rangeStyle: {
							structured: true
						},
						handleStyle: {
							structured: true
						}
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.init = function init() {
			if (isDefined(this.min)) this.minValue = this.min;
			if (isDefined(this.max)) this.maxValue = this.max;
			if (this.value != null) this.to = this.value;
			if (isUndefined(this.from)) this.from = this.minValue;
			else this.showFrom = true;
			if (isUndefined(this.to)) this.to = this.maxValue;
			else this.showTo = true;
			if (this.valueTooltip) this.toTooltip = this.valueTooltip;

			_Field.prototype.init.call(this);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			data.stateMods = _objectSpread({}, data.stateMods, {
				horizontal: !this.vertical,
				vertical: this.vertical,
				disabled: data.disabled
			});

			_Field.prototype.prepareData.call(this, context, instance);
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			return VDOM$2.createElement(SliderComponent, {
				key: key,
				instance: instance,
				data: instance.data,
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label"))
			});
		};

		return Slider;
	})(Field);
Slider.prototype.baseClass = "slider";
Slider.prototype.minValue = 0;
Slider.prototype.maxValue = 100;
Slider.prototype.vertical = false;
Slider.prototype.incrementPercentage = 0.01;
Slider.prototype.wheel = false;
Widget.alias("slider", Slider);

var SliderComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(SliderComponent, _VDOM$Component);

		function SliderComponent(props) {
			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			_this.dom = {};
			var data = props.data;
			_this.state = {
				from: data.from,
				to: data.to
			};
			return _this;
		}

		var _proto2 = SliderComponent.prototype;

		_proto2.render = function render() {
			var _objectSpread2,
				_objectSpread3,
				_objectSpread4,
				_this2 = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				data = _this$props.data,
				label = _this$props.label;
			var widget = instance.widget;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var minValue = data.minValue,
				maxValue = data.maxValue;
			var _this$state = this.state,
				from = _this$state.from,
				to = _this$state.to;
			from = Math.min(maxValue, Math.max(minValue, from));
			to = Math.min(maxValue, Math.max(minValue, to));
			var handleStyle = CSS.parseStyle(data.handleStyle);

			var fromHandleStyle = _objectSpread(
				{},
				handleStyle,
				((_objectSpread2 = {}),
				(_objectSpread2[widget.vertical ? "top" : "left"] = 100 * (from - minValue) / (maxValue - minValue) + "%"),
				_objectSpread2)
			);

			var toHandleStyle = _objectSpread(
				{},
				handleStyle,
				((_objectSpread3 = {}),
				(_objectSpread3[widget.vertical ? "top" : "left"] = 100 * (to - minValue) / (maxValue - minValue) + "%"),
				_objectSpread3)
			);

			var rangeStart = (from - minValue) / (maxValue - minValue);
			var rangeSize = (to - from) / (maxValue - minValue);

			var rangeStyle = _objectSpread(
				{},
				CSS.parseStyle(data.rangeStyle),
				((_objectSpread4 = {}),
				(_objectSpread4[widget.vertical ? "top" : "left"] = 100 * rangeStart + "%"),
				(_objectSpread4[widget.vertical ? "height" : "width"] = 100 * rangeSize + "%"),
				_objectSpread4)
			);

			return VDOM$2.createElement(
				"div",
				{
					className: data.classNames,
					style: data.style,
					id: data.id,
					onClick: this.onClick.bind(this),
					onWheel: this.onWheel.bind(this),
					onMouseMove: function onMouseMove(e) {
						return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
					},
					onMouseLeave: function onMouseLeave(e) {
						return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
					}
				},
				label,
				"\xA0",
				VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "axis")
					},
					rangeSize > 0 &&
						VDOM$2.createElement("div", {
							key: "range",
							className: CSS.element(baseClass, "range"),
							style: rangeStyle
						}),
					VDOM$2.createElement(
						"div",
						{
							key: "space",
							className: CSS.element(baseClass, "space"),
							ref: function ref(c) {
								return (_this2.dom.range = c);
							}
						},
						widget.showFrom &&
							VDOM$2.createElement("div", {
								key: "from",
								className: CSS.element(baseClass, "handle"),
								tabIndex: data.disabled ? null : data.tabIndex || 0,
								style: fromHandleStyle,
								onMouseDown: function onMouseDown(e) {
									return _this2.onHandleMouseDown(e, "from");
								},
								onMouseMove: function onMouseMove(e) {
									return tooltipMouseMove(e, instance, widget.fromTooltip, {
										tooltipName: "fromTooltip"
									});
								},
								onMouseLeave: function onMouseLeave(e) {
									return _this2.onHandleMouseLeave(e, "from");
								},
								onTouchStart: function onTouchStart(e) {
									return _this2.onHandleMouseDown(e, "from");
								},
								ref: function ref(c) {
									return (_this2.dom.from = c);
								}
							}),
						widget.showTo &&
							VDOM$2.createElement("div", {
								key: "to",
								className: CSS.element(baseClass, "handle"),
								tabIndex: data.disabled ? null : 0,
								style: toHandleStyle,
								onMouseDown: function onMouseDown(e) {
									return _this2.onHandleMouseDown(e, "to");
								},
								onMouseMove: function onMouseMove(e) {
									return tooltipMouseMove(e, instance, widget.toTooltip, {
										tooltipName: "toTooltip"
									});
								},
								onMouseLeave: function onMouseLeave(e) {
									return _this2.onHandleMouseLeave(e, "to");
								},
								onTouchStart: function onTouchStart(e) {
									return _this2.onHandleMouseDown(e, "to");
								},
								ref: function ref(c) {
									return (_this2.dom.to = c);
								}
							})
					)
				)
			);
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			this.setState({
				from: props.data.from,
				to: props.data.to
			});
			var instance = props.instance;
			var widget = instance.widget;
			tooltipParentWillReceiveProps(this.dom.to, instance, widget.toTooltip, {
				tooltipName: "toTooltip"
			});
			tooltipParentWillReceiveProps(this.dom.from, instance, widget.fromTooltip, {
				tooltipName: "fromTooltip"
			});
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			tooltipParentWillUnmount(this.props.instance);
		};

		_proto2.componentDidMount = function componentDidMount() {
			var instance = this.props.instance;
			var widget = instance.widget;
			tooltipParentDidMount(this.dom.to, instance, widget.toTooltip, {
				tooltipName: "toTooltip"
			});
			tooltipParentDidMount(this.dom.from, instance, widget.fromTooltip, {
				tooltipName: "fromTooltip"
			});
		};

		_proto2.onHandleMouseLeave = function onHandleMouseLeave(e, handle) {
			if (!this.state.drag) {
				var tooltipName = handle + "Tooltip";
				var instance = this.props.instance;
				var tooltip = instance.widget[tooltipName];
				tooltipMouseLeave(e, instance, tooltip, {
					tooltipName: tooltipName
				});
			}
		};

		_proto2.onHandleMouseDown = function onHandleMouseDown(e, handle) {
			var _this3 = this;

			e.preventDefault();
			e.stopPropagation();
			var instance = this.props.instance;
			var data = instance.data,
				widget = instance.widget;
			if (data.disabled || data.readOnly) return;
			var handleEl = this.dom[handle];
			var b = getTopLevelBoundingClientRect(handleEl);
			var pos = getCursorPos(e);
			var dx = pos.clientX - (b.left + b.right) / 2;
			var dy = pos.clientY - (b.top + b.bottom) / 2;
			var tooltipName = handle + "Tooltip";
			var tooltip = widget[tooltipName];
			this.setState({
				drag: true
			});
			captureMouseOrTouch(
				e,
				function(e) {
					var _this3$getValues = _this3.getValues(e, widget.vertical ? dy : dx),
						value = _this3$getValues.value;

					if (handle === "from") {
						if (instance.set("from", value))
							_this3.setState({
								from: value
							});

						if (value > _this3.state.to) {
							if (instance.set("to", value))
								_this3.setState({
									to: value
								});
						}
					} else if (handle === "to") {
						if (instance.set("to", value))
							_this3.setState({
								to: value
							});

						if (value < _this3.state.from) {
							if (instance.set("from", value))
								_this3.setState({
									from: value
								});
						}
					}

					tooltipMouseMove(e, instance, tooltip, {
						tooltipName: tooltipName,
						target: handleEl
					});
				},
				function(e) {
					_this3.setState({
						drag: false
					});

					var pos = getCursorPos(e);
					var el = document.elementFromPoint(pos.clientX, pos.clientY);
					if (el !== handleEl)
						tooltipMouseLeave(e, instance, tooltip, {
							tooltipName: tooltipName,
							target: handleEl
						});
				}
			);
		};

		_proto2.getValues = function getValues(e, d) {
			if (d === void 0) {
				d = 0;
			}

			var _this$props$instance = this.props.instance,
				data = _this$props$instance.data,
				widget = _this$props$instance.widget;
			var minValue = data.minValue,
				maxValue = data.maxValue;
			var b = getTopLevelBoundingClientRect(this.dom.range);
			var pos = getCursorPos(e);
			var pct = widget.vertical
				? Math.max(0, Math.min(1, (pos.clientY - b.top - d) / this.dom.range.offsetHeight))
				: Math.max(0, Math.min(1, (pos.clientX - b.left - d) / this.dom.range.offsetWidth));
			var delta = (maxValue - minValue) * pct;
			if (data.step) delta = Math.round(delta / data.step) * data.step;
			return {
				percent: delta / (maxValue - minValue),
				value: minValue + delta
			};
		};

		_proto2.onClick = function onClick(e) {
			var instance = this.props.instance;
			var data = instance.data;

			if (!data.disabled && !data.readOnly) {
				var _this$getValues = this.getValues(e),
					value = _this$getValues.value;

				this.props.instance.set("value", value);
			}
		};

		_proto2.onWheel = function onWheel(e) {
			var instance = this.props.instance;
			var data = instance.data,
				widget = instance.widget;
			if ((widget.showFrom && widget.showTo) || !data.wheel) return;
			e.preventDefault();
			e.stopPropagation();
			var increment = e.deltaY > 0 ? this.getIncrement() : -this.getIncrement();

			if (!data.disabled && !data.readOnly) {
				if (widget.showFrom) {
					var value = this.checkBoundries(data.from + increment);
					if (instance.set("from", value))
						this.setState({
							from: value
						});
				} else if (widget.showTo) {
					var _value = this.checkBoundries(data.to + increment);

					if (instance.set("to", _value))
						this.setState({
							to: _value
						});
				}
			}
		};

		_proto2.checkBoundries = function checkBoundries(value) {
			var data = this.props.instance.data;
			if (value > data.maxValue) value = data.maxValue;
			else if (value < data.minValue) value = data.minValue;
			return value;
		};

		_proto2.getIncrement = function getIncrement() {
			var instance = this.props.instance;
			var data = instance.data;
			var increment = data.increment || (data.maxValue - data.minValue) * data.incrementPercentage;
			return increment;
		};

		return SliderComponent;
	})(VDOM$2.Component);

var Switch =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(Switch, _Field);

		function Switch() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = Switch.prototype;

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[
					this,
					{
						on: false,
						off: true,
						value: undefined,
						disabled: undefined,
						readOnly: undefined,
						text: undefined,
						rangeStyle: {
							structured: true
						},
						handleStyle: {
							structured: true
						}
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.isEmpty = function isEmpty() {
			return false;
		};

		_proto.init = function init() {
			if (isDefined(this.value)) this.on = this.value;
			this.rangeStyle = parseStyle(this.rangeStyle);
			this.handleStyle = parseStyle(this.handleStyle);

			_Field.prototype.init.call(this);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			if (isDefined(this.off)) data.on = !data.off;
			data.stateMods = _objectSpread({}, data.stateMods, {
				on: data.on,
				disabled: data.disabled
			});

			_Field.prototype.prepareData.call(this, context, instance);
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			var _this = this;

			var data = instance.data,
				widget = instance.widget;
			var rangeStyle = data.rangeStyle,
				handleStyle = data.handleStyle;
			var CSS = this.CSS,
				baseClass = this.baseClass;
			var text = data.text || this.renderChildren(context, instance);
			return VDOM$2.createElement(
				"div",
				{
					key: key,
					className: data.classNames,
					style: data.style,
					id: data.id,
					tabIndex: data.disabled ? null : data.tabIndex || 0,
					onMouseDown: function onMouseDown(e) {
						e.stopPropagation();
						if (!_this.focusOnMouseDown) preventFocus(e);
					},
					onClick: function onClick(e) {
						_this.toggle(e, instance);
					},
					onKeyDown: function onKeyDown(e) {
						if (widget.handleKeyDown(e, instance) === false) return;

						if (e.keyCode == KeyCode.space) {
							_this.toggle(e, instance);
						}
					},
					onMouseMove: function onMouseMove(e) {
						return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
					},
					onMouseLeave: function onMouseLeave(e) {
						return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
					}
				},
				this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				"\xA0",
				VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "axis")
					},
					VDOM$2.createElement("div", {
						className: CSS.element(baseClass, "range"),
						style: parseStyle(rangeStyle)
					}),
					VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "space")
						},
						VDOM$2.createElement("div", {
							className: CSS.element(baseClass, "handle"),
							style: parseStyle(handleStyle)
						})
					)
				),
				text &&
					VDOM$2.createElement(
						"div",
						{
							key: "text",
							className: CSS.element(this.baseClass, "text")
						},
						text
					)
			);
		};

		_proto.toggle = function toggle(e, instance) {
			var data = instance.data;
			if (data.readOnly || data.disabled) return;
			instance.set("on", !data.on);
			instance.set("off", data.on);
			e.preventDefault();
			e.stopPropagation();
		};

		return Switch;
	})(Field);
Switch.prototype.baseClass = "switch";
Switch.prototype.focusOnMouseDown = false;
Widget.alias("switch", Switch);

var Wheel =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(Wheel, _PureContainer);

		function Wheel() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = Wheel.prototype;

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						value: undefined,
						options: undefined
					}
				])
			);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			var value = data.value,
				options = data.options;
			var index = options.findIndex(function(a) {
				return a.id === value;
			});
			if (index === -1) index = Math.floor(options.length / 2);
			return VDOM$2.createElement(
				WheelComponent,
				{
					key: key,
					size: this.size,
					focusable: true,
					CSS: this.CSS,
					baseClass: this.baseClass,
					className: data.classNames,
					style: data.style,
					index: index,
					onChange: function onChange(newIndex) {
						var option = options[newIndex];
						instance.set("value", option.id);
					}
				},
				options.map(function(o, i) {
					return VDOM$2.createElement(
						"span",
						{
							key: 0
						},
						o.text
					);
				})
			);
		};

		return Wheel;
	})(PureContainer);
Wheel.prototype.baseClass = "wheel";
Wheel.prototype.size = 3;
Wheel.prototype.styled = true;
var WheelComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(WheelComponent, _VDOM$Component);

		function WheelComponent(props) {
			var _context;

			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			_this.state = {};
			_this.index = props.index || 0;

			_this.wheelRef = function(el) {
				_this.wheelEl = el;
			};

			_this.scrollRef = function(el) {
				_this.scrollEl = el;
			};

			_this.onWheel = (_context = _this).onWheel.bind(_context);
			_this.onKeyDown = (_context = _this).onKeyDown.bind(_context);
			return _this;
		}

		var _proto2 = WheelComponent.prototype;

		_proto2.render = function render() {
			var _this2 = this;

			var _this$props = this.props,
				size = _this$props.size,
				children = _this$props.children,
				CSS = _this$props.CSS,
				baseClass = _this$props.baseClass,
				active = _this$props.active,
				className = _this$props.className,
				style = _this$props.style,
				onMouseDown = _this$props.onMouseDown;
			var optionClass = CSS.element(baseClass, "option");
			var dummyClass = CSS.element(baseClass, "option", {
				dummy: true
			});
			var tpad = [],
				bpad = [];

			for (var i = 0; i < (size - 1) / 2; i++) {
				tpad.push({
					key: -1 - i,
					child: children[0],
					cls: dummyClass
				});
				bpad.push({
					key: -100 - i,
					child: children[0],
					cls: dummyClass
				});
			}

			var displayedOptions = [].concat(
				tpad,
				children.map(function(c, i) {
					return {
						key: i,
						child: c,
						cls: optionClass
					};
				}),
				bpad
			);
			if (!this.state.wheelHeight) displayedOptions = displayedOptions.slice(this.index, this.index + size);
			return VDOM$2.createElement(
				"div",
				{
					tabIndex: this.props.focusable ? data.tabIndex || 0 : null,
					className:
						className ||
						CSS.element(baseClass, "container", {
							active: active
						}),
					style: style,
					onKeyDown: this.onKeyDown
				},
				VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "clip"),
						style: {
							width: this.state.wheelWidth
						},
						onMouseDown: onMouseDown
					},
					VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "vscroll"),
							ref: this.scrollRef,
							onWheel: this.onWheel,
							onTouchStart: this.onTouchStart.bind(this),
							onTouchEnd: this.onTouchEnd.bind(this)
						},
						VDOM$2.createElement(
							"div",
							{
								className: CSS.element(baseClass, "wheel"),
								style: {
									height: this.state.wheelHeight
								},
								ref: this.wheelRef
							},
							displayedOptions.map(function(opt) {
								return VDOM$2.createElement(
									"div",
									{
										key: opt.key,
										className: opt.cls
									},
									opt.child
								);
							})
						)
					),
					VDOM$2.createElement("div", {
						className: CSS.element(baseClass, "mask"),
						style: {
							top: "0",
							bottom: (50 + 50 / size).toFixed(3) + "%"
						}
					}),
					VDOM$2.createElement("div", {
						className: CSS.element(baseClass, "mask"),
						style: {
							top: (50 + 50 / size).toFixed(3) + "%",
							bottom: "0"
						}
					}),
					VDOM$2.createElement("div", {
						className: CSS.element(baseClass, "selection"),
						style: {
							height: (100 / size).toFixed(3) + "%",
							top: (50 - 50 / size).toFixed(3) + "%"
						}
					})
				),
				VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "arrow-up"),
						onClick: function onClick(e) {
							e.preventDefault();

							_this2.select(_this2.index - 1);
						}
					},
					Icon.render("drop-down", {
						className: CSS.element(baseClass, "arrow-icon")
					})
				),
				VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "arrow-down"),
						onClick: function onClick(e) {
							e.preventDefault();

							_this2.select(_this2.index + 1);
						}
					},
					Icon.render("drop-down", {
						className: CSS.element(baseClass, "arrow-icon")
					})
				)
			);
		};

		_proto2.componentDidMount = function componentDidMount() {
			var _this3 = this;

			this.setState(
				{
					wheelHeight: this.wheelEl.offsetHeight,
					wheelWidth: this.wheelEl.offsetWidth
				},
				function() {
					_this3.scrollEl.scrollTop = _this3.index * _this3.state.wheelHeight / _this3.props.size;
				}
			);
			if (this.props.onPipeKeyDown) this.props.onPipeKeyDown(this.onKeyDown);
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			this.index = props.index || 0;
			this.scrollTo();
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			this.scrolling = false;
		};

		_proto2.onKeyDown = function onKeyDown(e) {
			switch (e.keyCode) {
				case KeyCode.up:
					e.preventDefault();
					this.select(this.index - 1);
					break;

				case KeyCode.down:
					e.preventDefault();
					this.select(this.index + 1);
					break;
			}
		};

		_proto2.onWheel = function onWheel(e) {
			e.preventDefault();
			var index = this.index;
			if (e.deltaY > 0) index++;
			else index--;
			this.select(index);
		};

		_proto2.onTouchStart = function onTouchStart(e) {
			this.scrolling = false;
		};

		_proto2.onTouchEnd = function onTouchEnd(e) {
			var size = this.props.size;
			var index = Math.round(this.scrollEl.scrollTop / (this.state.wheelHeight / size));
			this.select(index);
		};

		_proto2.select = function select(newIndex) {
			var children = this.props.children;
			newIndex = Math.max(0, Math.min(children.length - 1, newIndex));

			if (this.index !== newIndex) {
				this.index = newIndex;
				this.props.onChange(newIndex);
			}

			this.scrollTo();
		};

		_proto2.scrollTo = function scrollTo() {
			var _this4 = this;

			var size = this.props.size;

			var callback = function callback() {
				if (!_this4.scrolling) return;
				var x = _this4.index * _this4.state.wheelHeight / size;
				var delta = Math.round(x - _this4.scrollEl.scrollTop);

				if (delta === 0) {
					_this4.scrolling = false;
					return;
				}

				var sign = delta > 0 ? 1 : -1;
				delta = Math.abs(delta) / 10;
				if (delta < 1) delta = 1;
				_this4.scrollEl.scrollTop += sign * delta;
				requestAnimationFrame(callback);
			};

			if (!this.scrolling) {
				this.scrolling = true;
				requestAnimationFrame(callback);
			}
		};

		return WheelComponent;
	})(VDOM$2.Component);

enableCultureSensitiveFormatting();
var DateTimePicker =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(DateTimePicker, _Widget);

		function DateTimePicker() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = DateTimePicker.prototype;

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			return (_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						value: undefined
					}
				])
			);
		};

		_proto.render = function render(context, instance, key) {
			return VDOM$2.createElement(DateTimePickerComponent, {
				key: key,
				instance: instance,
				data: instance.data,
				size: this.size,
				segment: this.segment
			});
		};

		return DateTimePicker;
	})(Widget);
DateTimePicker.prototype.baseClass = "datetimepicker";
DateTimePicker.prototype.styled = true;
DateTimePicker.prototype.size = 3;
DateTimePicker.prototype.autoFocus = false;
DateTimePicker.prototype.segment = "datetime";
DateTimePicker.prototype.showSeconds = false;

var DateTimePickerComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(DateTimePickerComponent, _VDOM$Component);

		function DateTimePickerComponent(props) {
			var _context;

			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			var date = props.data.value ? new Date(props.data.value) : new Date();
			if (isNaN(date.getTime())) date = new Date();
			_this.state = {
				date: date,
				activeWheel: null
			};
			var widget = props.instance.widget;
			_this.handleChange = (_context = _this).handleChange.bind(_context);
			_this.onFocus = (_context = _this).onFocus.bind(_context);
			_this.onBlur = (_context = _this).onBlur.bind(_context);
			_this.onKeyDown = (_context = _this).onKeyDown.bind(_context);
			var showDate = props.segment.indexOf("date") !== -1;
			var showTime = props.segment.indexOf("time") !== -1;
			_this.wheels = {
				year: showDate,
				month: showDate,
				date: showDate,
				hours: showTime,
				minutes: showTime,
				seconds: showTime && widget.showSeconds
			};
			_this.keyDownPipes = {};
			return _this;
		}

		var _proto2 = DateTimePickerComponent.prototype;

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			var date = props.data.value ? new Date(props.data.value) : new Date();
			if (isNaN(date.getTime())) date = new Date();
			this.setState({
				date: date
			});
		};

		_proto2.setDateComponent = function setDateComponent(date, component, value) {
			var v = new Date(date);

			switch (component) {
				case "year":
					v.setFullYear(value);
					break;

				case "month":
					v.setMonth(value);
					break;

				case "date":
					v.setDate(value);
					break;

				case "hours":
					v.setHours(value);
					break;

				case "minutes":
					v.setMinutes(value);
					break;

				case "seconds":
					v.setSeconds(value);
					break;
			}

			return v;
		};

		_proto2.handleChange = function handleChange() {
			var encode = this.props.instance.widget.encoding || Culture.getDefaultDateEncoding();
			this.props.instance.set("value", encode(this.state.date));
		};

		_proto2.render = function render() {
			var _this2 = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				data = _this$props.data,
				size = _this$props.size;
			var widget = instance.widget;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var date = this.state.date;
			var culture = Culture.getDateTimeCulture();
			var monthNames = culture.getMonthNames("short");
			var years = [];

			for (var y = 1970; y <= 2050; y++) {
				years.push(
					VDOM$2.createElement(
						"span",
						{
							key: y
						},
						y
					)
				);
			}

			var days = [];
			var start = new Date(date.getFullYear(), date.getMonth(), 1);

			while (start.getMonth() === date.getMonth()) {
				var day = start.getDate();
				days.push(
					VDOM$2.createElement(
						"span",
						{
							key: day
						},
						day < 10 ? "0" + day : day
					)
				);
				start.setDate(start.getDate() + 1);
			}

			var hours = [];

			for (var h = 0; h < 24; h++) {
				hours.push(
					VDOM$2.createElement(
						"span",
						{
							key: h
						},
						h < 10 ? "0" + h : h
					)
				);
			}

			var minutes = [];

			for (var m = 0; m < 60; m++) {
				minutes.push(
					VDOM$2.createElement(
						"span",
						{
							key: m
						},
						m < 10 ? "0" + m : m
					)
				);
			}

			return VDOM$2.createElement(
				"div",
				{
					tabIndex: 0,
					ref: function ref(el) {
						_this2.el = el;
					},
					className: data.classNames,
					onFocus: this.onFocus,
					onBlur: this.onBlur,
					onKeyDown: this.onKeyDown
				},
				this.wheels.year &&
					VDOM$2.createElement(
						WheelComponent,
						{
							size: size,
							CSS: CSS,
							active: this.state.activeWheel === "year",
							baseClass: baseClass + "-wheel",
							index: date.getFullYear() - 1970,
							onChange: function onChange(newIndex) {
								_this2.setState(function(state) {
									return {
										date: _this2.setDateComponent(_this2.state.date, "year", newIndex + 1970)
									};
								}, _this2.handleChange);
							},
							onPipeKeyDown: function onPipeKeyDown(kd) {
								_this2.keyDownPipes["year"] = kd;
							},
							onMouseDown: function onMouseDown() {
								_this2.setState({
									activeWheel: "year"
								});
							}
						},
						years
					),
				this.wheels.year && this.wheels.month && VDOM$2.createElement("span", null, "-"),
				this.wheels.month &&
					VDOM$2.createElement(
						WheelComponent,
						{
							size: size,
							CSS: CSS,
							active: this.state.activeWheel === "month",
							baseClass: baseClass + "-wheel",
							index: date.getMonth(),
							onChange: function onChange(newIndex) {
								_this2.setState(function(state) {
									return {
										date: _this2.setDateComponent(_this2.state.date, "month", newIndex)
									};
								}, _this2.handleChange);
							},
							onPipeKeyDown: function onPipeKeyDown(kd) {
								_this2.keyDownPipes["month"] = kd;
							},
							onMouseDown: function onMouseDown() {
								_this2.setState({
									activeWheel: "month"
								});
							}
						},
						monthNames.map(function(m, i) {
							return VDOM$2.createElement(
								"span",
								{
									key: i
								},
								m
							);
						})
					),
				this.wheels.month && this.wheels.date && VDOM$2.createElement("span", null, "-"),
				this.wheels.date &&
					VDOM$2.createElement(
						WheelComponent,
						{
							size: size,
							CSS: CSS,
							active: this.state.activeWheel === "date",
							baseClass: baseClass + "-wheel",
							index: date.getDate() - 1,
							onChange: function onChange(newIndex) {
								_this2.setState(function(state) {
									return {
										date: _this2.setDateComponent(_this2.state.date, "date", newIndex + 1)
									};
								}, _this2.handleChange);
							},
							onPipeKeyDown: function onPipeKeyDown(kd) {
								_this2.keyDownPipes["date"] = kd;
							},
							onMouseDown: function onMouseDown() {
								_this2.setState({
									activeWheel: "date"
								});
							}
						},
						days
					),
				this.wheels.hours &&
					this.wheels.year &&
					VDOM$2.createElement("span", {
						className: CSS.element(baseClass, "spacer")
					}),
				this.wheels.hours &&
					VDOM$2.createElement(
						WheelComponent,
						{
							size: size,
							CSS: CSS,
							active: this.state.activeWheel === "hours",
							baseClass: baseClass + "-wheel",
							index: date.getHours(),
							onChange: function onChange(newIndex) {
								_this2.setState(function(state) {
									return {
										date: _this2.setDateComponent(_this2.state.date, "hours", newIndex)
									};
								}, _this2.handleChange);
							},
							onPipeKeyDown: function onPipeKeyDown(kd) {
								_this2.keyDownPipes["hours"] = kd;
							},
							onMouseDown: function onMouseDown() {
								_this2.setState({
									activeWheel: "hours"
								});
							}
						},
						hours
					),
				this.wheels.hours && this.wheels.minutes && VDOM$2.createElement("span", null, ":"),
				this.wheels.minutes &&
					VDOM$2.createElement(
						WheelComponent,
						{
							size: size,
							CSS: CSS,
							baseClass: baseClass + "-wheel",
							active: this.state.activeWheel === "minutes",
							index: date.getMinutes(),
							onChange: function onChange(newIndex) {
								_this2.setState(function(state) {
									return {
										date: _this2.setDateComponent(_this2.state.date, "minutes", newIndex)
									};
								}, _this2.handleChange);
							},
							onPipeKeyDown: function onPipeKeyDown(kd) {
								_this2.keyDownPipes["minutes"] = kd;
							},
							onMouseDown: function onMouseDown() {
								_this2.setState({
									activeWheel: "minutes"
								});
							}
						},
						minutes
					),
				this.wheels.minutes && this.wheels.seconds && VDOM$2.createElement("span", null, ":"),
				this.wheels.seconds &&
					VDOM$2.createElement(
						WheelComponent,
						{
							size: size,
							CSS: CSS,
							baseClass: baseClass + "-wheel",
							active: this.state.activeWheel === "seconds",
							index: date.getSeconds(),
							onChange: function onChange(newIndex) {
								_this2.setState(function(state) {
									return {
										date: _this2.setDateComponent(_this2.state.date, "seconds", newIndex)
									};
								}, _this2.handleChange);
							},
							onPipeKeyDown: function onPipeKeyDown(kd) {
								_this2.keyDownPipes["seconds"] = kd;
							},
							onMouseDown: function onMouseDown() {
								_this2.setState({
									activeWheel: "seconds"
								});
							}
						},
						minutes
					)
			);
		};

		_proto2.componentDidMount = function componentDidMount() {
			if (this.props.instance.widget.autoFocus) this.el.focus();
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			offFocusOut(this);
		};

		_proto2.onFocus = function onFocus() {
			oneFocusOut(this, this.el, this.onFocusOut.bind(this));

			if (!this.state.activeWheel) {
				var firstWheel = null;

				for (var wheel in this.wheels) {
					if (this.wheels[wheel]) {
						firstWheel = wheel;
						break;
					}
				}

				this.setState({
					activeWheel: firstWheel
				});
			}
		};

		_proto2.onFocusOut = function onFocusOut() {
			var instance = this.props.instance;
			var widget = instance.widget;
			if (widget.onFocusOut) instance.invoke("onFocusOut", null, instance);
		};

		_proto2.onBlur = function onBlur() {
			this.setState({
				activeWheel: null
			});
		};

		_proto2.onKeyDown = function onKeyDown(e) {
			var tmp = null;
			var instance = this.props.instance;

			switch (e.keyCode) {
				case KeyCode.right:
					e.preventDefault();

					for (var wheel in this.wheels) {
						if (this.wheels[wheel]) {
							if (tmp === this.state.activeWheel) {
								this.setState({
									activeWheel: wheel
								});
								break;
							}

							tmp = wheel;
						}
					}

					break;

				case KeyCode.left:
					e.preventDefault();

					for (var _wheel in this.wheels) {
						if (this.wheels[_wheel]) {
							if (_wheel === this.state.activeWheel && tmp) {
								this.setState({
									activeWheel: tmp
								});
								break;
							}

							tmp = _wheel;
						}
					}

					break;

				case KeyCode.enter:
					e.preventDefault();
					if (instance.widget.onSelect) instance.invoke("onSelect", e, instance, this.state.date);
					break;

				default:
					var kdp = this.keyDownPipes[this.state.activeWheel];
					if (kdp) kdp(e);
					break;
			}
		};

		return DateTimePickerComponent;
	})(VDOM$2.Component);

var DateTimeField =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(DateTimeField, _Field);

		function DateTimeField() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = DateTimeField.prototype;

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[
					this,
					{
						value: null,
						disabled: undefined,
						readOnly: undefined,
						enabled: undefined,
						placeholder: undefined,
						required: undefined,
						minValue: undefined,
						minExclusive: undefined,
						maxValue: undefined,
						maxExclusive: undefined,
						format: undefined,
						icon: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.init = function init() {
			if (typeof this.hideClear !== "undefined") this.showClear = !this.hideClear;
			if (this.alwaysShowClear) this.showClear = true;

			if (!this.format) {
				switch (this.segment) {
					case "datetime":
						this.format = "YYYYMMddhhmm";
						break;

					case "time":
						this.format = "hhmm";
						break;

					case "date":
						this.format = "YYYYMMMdd";
						break;
				}
			}

			_Field.prototype.init.call(this);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;

			if (data.value) {
				var date = (data.date = new Date(data.value));
				if (isNaN(date.getTime())) data.formatted = String(data.value);
				else data.formatted = Culture.getDateTimeCulture().format(date, data.format);
			} else data.formatted = "";

			if (data.refDate) data.refDate = zeroTime(new Date(data.refDate));
			if (data.maxValue) data.maxValue = new Date(data.maxValue);
			if (data.minValue) data.minValue = new Date(data.minValue);

			if (this.segment == "date") {
				if (data.minValue) data.minValue = zeroTime(data.minValue);
				if (data.maxValue) data.maxValue = zeroTime(data.maxValue);
			}

			instance.lastDropdown = context.lastDropdown;

			_Field.prototype.prepareData.call(this, context, instance);
		};

		_proto.validate = function validate(context, instance) {
			_Field.prototype.validate.call(this, context, instance);

			var data = instance.data;

			if (!data.error && data.date) {
				if (isNaN(data.date)) data.error = this.inputErrorText;
				else {
					var d;

					if (data.maxValue) {
						d = dateDiff(data.date, data.maxValue);
						if (d > 0) data.error = StringTemplate.format(this.maxValueErrorText, data.maxValue);
						else if (d == 0 && data.maxExclusive)
							data.error = StringTemplate.format(this.maxExclusiveErrorText, data.maxValue);
					}

					if (data.minValue) {
						d = dateDiff(data.date, data.minValue);
						if (d < 0) data.error = StringTemplate.format(this.minValueErrorText, data.minValue);
						else if (d == 0 && data.minExclusive)
							data.error = StringTemplate.format(this.minExclusiveErrorText, data.minValue);
					}
				}
			}
		};

		_proto.renderInput = function renderInput(context, instance, key) {
			return VDOM$2.createElement(DateTimeInput, {
				key: key,
				instance: instance,
				data: instance.data,
				picker: {
					value: this.value,
					minValue: this.minValue,
					maxValue: this.maxValue,
					minExclusive: this.minExclusive,
					maxExclusive: this.maxExclusive,
					maxValueErrorText: this.maxValueErrorText,
					maxExclusiveErrorText: this.maxExclusiveErrorText,
					minValueErrorText: this.minValueErrorText,
					minExclusiveErrorText: this.minExclusiveErrorText
				},
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help"))
			});
		};

		_proto.formatValue = function formatValue(context, _ref) {
			var data = _ref.data;
			return data.value ? data.formatted : null;
		};

		_proto.parseDate = function parseDate(date) {
			if (!date) return null;
			if (date instanceof Date) return date;
			date = Culture.getDateTimeCulture().parse(date, {
				useCurrentDateForDefaults: true
			});
			return date;
		};

		return DateTimeField;
	})(Field);
DateTimeField.prototype.baseClass = "datetimefield"; //DateTimeField.prototype.memoize = false;

DateTimeField.prototype.maxValueErrorText = "Select {0:d} or before.";
DateTimeField.prototype.maxExclusiveErrorText = "Select a date before {0:d}.";
DateTimeField.prototype.minValueErrorText = "Select {0:d} or later.";
DateTimeField.prototype.minExclusiveErrorText = "Select a date after {0:d}.";
DateTimeField.prototype.inputErrorText = "Invalid date entered.";
DateTimeField.prototype.suppressErrorsUntilVisited = true;
DateTimeField.prototype.icon = "calendar";
DateTimeField.prototype.showClear = true;
DateTimeField.prototype.alwaysShowClear = false;
DateTimeField.prototype.reactOn = "enter blur";
DateTimeField.prototype.segment = "datetime";
DateTimeField.prototype.picker = "auto";
Widget.alias("datetimefield", DateTimeField);
Localization.registerPrototype("cx/widgets/DateTimeField", DateTimeField);

var DateTimeInput =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(DateTimeInput, _VDOM$Component);

		function DateTimeInput(props) {
			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			props.instance.component = _assertThisInitialized(_assertThisInitialized(_this));
			_this.state = {
				dropdownOpen: false,
				focus: false
			};
			return _this;
		}

		var _proto2 = DateTimeInput.prototype;

		_proto2.getDropdown = function getDropdown() {
			var _this2 = this;

			if (this.dropdown) return this.dropdown;
			var _this$props$instance = this.props.instance,
				widget = _this$props$instance.widget,
				lastDropdown = _this$props$instance.lastDropdown;
			var pickerConfig;

			switch (widget.picker) {
				case "calendar":
					pickerConfig = {
						type: Calendar,
						partial: widget.partial,
						encoding: widget.encoding
					};
					break;

				default:
					pickerConfig = {
						type: DateTimePicker,
						segment: widget.segment,
						encoding: widget.encoding
					};
					break;
			}

			var dropdown = _objectSpread(
				{
					scrollTracking: true,
					inline: !isTouchDevice() || !!lastDropdown,
					matchWidth: false,
					placementOrder: "down down-right down-left up up-right up-left",
					touchFriendly: true,
					firstChildDefinesHeight: true,
					firstChildDefinesWidth: true
				},
				widget.dropdownOptions,
				{
					type: Dropdown,
					relatedElement: this.input,
					items: _objectSpread({}, pickerConfig, this.props.picker, {
						autoFocus: true,
						onFocusOut: function onFocusOut(e) {
							_this2.closeDropdown(e);
						},
						onKeyDown: function onKeyDown(e) {
							return _this2.onKeyDown(e);
						},
						onSelect: function onSelect(e) {
							e.stopPropagation();
							e.preventDefault();
							var touch = isTouchEvent(e);

							_this2.closeDropdown(e, function() {
								if (!touch) _this2.input.focus();
							});
						}
					})
				}
			);

			return (this.dropdown = Widget.create(dropdown));
		};

		_proto2.render = function render() {
			var _this3 = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				label = _this$props.label,
				help = _this$props.help;
			var data = instance.data,
				widget = instance.widget,
				state = instance.state;
			var CSS = widget.CSS,
				baseClass = widget.baseClass,
				suppressErrorsUntilVisited = widget.suppressErrorsUntilVisited;
			var insideButton, icon;

			if (!data.readOnly && !data.disabled) {
				if (
					widget.showClear &&
					(((widget.alwaysShowClear || !data.required) && data.value != null) || instance.state.inputError)
				)
					insideButton = VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "clear"),
							onMouseDown: function onMouseDown(e) {
								e.preventDefault();
								e.stopPropagation();
							},
							onClick: function onClick(e) {
								return _this3.onClearClick(e);
							}
						},
						VDOM$2.createElement(ClearIcon, {
							className: CSS.element(baseClass, "icon")
						})
					);
				else
					insideButton = VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "right-icon")
						},
						VDOM$2.createElement(DropdownIcon, {
							className: CSS.element(baseClass, "icon")
						})
					);
			}

			if (data.icon) {
				icon = VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "left-icon")
					},
					Icon.render(data.icon, {
						className: CSS.element(baseClass, "icon")
					})
				);
			}

			var dropdown = false;
			if (this.state.dropdownOpen)
				dropdown = VDOM$2.createElement(Cx, {
					widget: this.getDropdown(),
					parentInstance: instance,
					options: {
						name: "datefield-dropdown"
					},
					subscribe: true
				});
			var empty = this.input ? !this.input.value : data.empty;
			return VDOM$2.createElement(
				"div",
				{
					className: CSS.expand(
						data.classNames,
						CSS.state({
							visited: state.visited,
							focus: this.state.focus || this.state.dropdownOpen,
							icon: !!icon,
							empty: empty && !data.placeholder,
							error: data.error && (state.visited || !suppressErrorsUntilVisited || !empty)
						})
					),
					style: data.style,
					onMouseDown: this.onMouseDown.bind(this),
					onTouchStart: stopPropagation
				},
				VDOM$2.createElement(
					"input",
					_extends(
						{
							id: data.id,
							ref: function ref(el) {
								_this3.input = el;
							},
							type: "text",
							className: CSS.element(baseClass, "input"),
							style: data.inputStyle,
							defaultValue: data.formatted,
							disabled: data.disabled,
							readOnly: data.readOnly,
							tabIndex: data.tabIndex,
							placeholder: data.placeholder
						},
						data.inputAttrs,
						{
							onInput: function onInput(e) {
								return _this3.onChange(e, "input");
							},
							onChange: function onChange(e) {
								return _this3.onChange(e, "change");
							},
							onKeyDown: function onKeyDown(e) {
								return _this3.onKeyDown(e);
							},
							onBlur: function onBlur(e) {
								_this3.onBlur(e);
							},
							onFocus: function onFocus(e) {
								_this3.onFocus(e);
							},
							onMouseMove: function onMouseMove(e) {
								return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(_this3.props.instance)));
							},
							onMouseLeave: function onMouseLeave(e) {
								return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(_this3.props.instance)));
							}
						}
					)
				),
				icon,
				insideButton,
				dropdown,
				label,
				help
			);
		};

		_proto2.onMouseDown = function onMouseDown(e) {
			e.stopPropagation();
			if (this.state.dropdownOpen) this.closeDropdown(e);
			else {
				this.openDropdownOnFocus = true;
			} //icon click

			if (e.target !== this.input) {
				e.preventDefault();
				if (!this.state.dropdownOpen) this.openDropdown(e);
				else this.input.focus();
			}
		};

		_proto2.onFocus = function onFocus(e) {
			var instance = this.props.instance;
			var widget = instance.widget;

			if (widget.trackFocus) {
				this.setState({
					focus: true
				});
			}

			if (this.openDropdownOnFocus) this.openDropdown(e);
		};

		_proto2.onKeyDown = function onKeyDown(e) {
			var _this4 = this;

			var instance = this.props.instance;
			if (instance.widget.handleKeyDown(e, instance) === false) return;

			switch (e.keyCode) {
				case KeyCode.enter:
					e.stopPropagation();
					this.onChange(e, "enter");
					break;

				case KeyCode.esc:
					if (this.state.dropdownOpen) {
						e.stopPropagation();
						this.closeDropdown(e, function() {
							_this4.input.focus();
						});
					}

					break;

				case KeyCode.left:
				case KeyCode.right:
					e.stopPropagation();
					break;

				case KeyCode.down:
					this.openDropdown(e);
					e.stopPropagation();
					e.preventDefault();
					break;
			}
		};

		_proto2.onBlur = function onBlur(e) {
			if (!this.state.dropdownOpen)
				this.props.instance.setState({
					visited: true
				});
			if (this.state.focus)
				this.setState({
					focus: false
				});
			this.onChange(e, "blur");
		};

		_proto2.closeDropdown = function closeDropdown(e, callback) {
			var _this5 = this;

			if (this.state.dropdownOpen) {
				if (this.scrollableParents)
					this.scrollableParents.forEach(function(el) {
						el.removeEventListener("scroll", _this5.updateDropdownPosition);
					});
				this.setState(
					{
						dropdownOpen: false
					},
					callback
				);
				this.props.instance.setState({
					visited: true
				});
			} else if (callback) callback();
		};

		_proto2.openDropdown = function openDropdown(e) {
			var data = this.props.instance.data;
			this.openDropdownOnFocus = false;

			if (!this.state.dropdownOpen && !(data.disabled || data.readOnly)) {
				this.setState({
					dropdownOpen: true
				});
			}
		};

		_proto2.onClearClick = function onClearClick(e) {
			this.setValue(null);
			e.stopPropagation();
			e.preventDefault();
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			var _props$instance = props.instance,
				data = _props$instance.data,
				state = _props$instance.state;

			if (data.formatted !== this.input.value && (data.formatted !== this.props.data.formatted || !state.inputError)) {
				this.input.value = data.formatted || "";
				props.instance.setState({
					inputError: false
				});
			}

			tooltipParentWillReceiveProps.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
		};

		_proto2.componentDidMount = function componentDidMount() {
			tooltipParentDidMount.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
			autoFocus(this.input, this);
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			autoFocus(this.input, this);
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			tooltipParentWillUnmount(this.props.instance);
		};

		_proto2.onChange = function onChange(e, eventType) {
			var _this$props2 = this.props,
				instance = _this$props2.instance,
				data = _this$props2.data;
			var widget = instance.widget;
			if (data.disabled || data.readOnly) return;
			if (widget.reactOn.indexOf(eventType) === -1) return;
			if (eventType == "enter")
				instance.setState({
					visited: true
				});
			this.setValue(e.target.value, data.value);
		};

		_proto2.setValue = function setValue(text, baseValue) {
			var _this$props3 = this.props,
				instance = _this$props3.instance,
				data = _this$props3.data;
			var widget = instance.widget;
			var date = widget.parseDate(text);
			instance.setState({
				inputError: isNaN(date) && widget.inputErrorText
			});

			if (!isNaN(date)) {
				var mixed = new Date(baseValue);

				if (date && baseValue && !isNaN(mixed) && widget.partial) {
					switch (widget.segment) {
						case "date":
							mixed.setFullYear(date.getFullYear());
							mixed.setMonth(date.getMonth());
							mixed.setDate(date.getDate());
							break;

						case "time":
							mixed.setHours(date.getHours());
							mixed.setMinutes(date.getMinutes());
							mixed.setSeconds(date.getSeconds());
							break;

						default:
							mixed = date;
							break;
					}

					date = mixed;
				}

				var encode = widget.encoding || Culture.getDefaultDateEncoding();
				var value = date ? encode(date) : null;

				if (value !== data.value) {
					if (!instance.set("value", value)) this.input.value = text || "";
				}
			}
		};

		return DateTimeInput;
	})(VDOM$2.Component);

var DateField =
	/*#__PURE__*/
	(function(_DateTimeField) {
		_inheritsLoose(DateField, _DateTimeField);

		function DateField() {
			return _DateTimeField.apply(this, arguments) || this;
		}

		return DateField;
	})(DateTimeField);
DateField.prototype.picker = "calendar";
DateField.prototype.segment = "date";
Widget.alias("datefield", DateField);
Localization.registerPrototype("cx/widgets/DateField", DateField);

var TimeField =
	/*#__PURE__*/
	(function(_DateTimeField) {
		_inheritsLoose(TimeField, _DateTimeField);

		function TimeField() {
			return _DateTimeField.apply(this, arguments) || this;
		}

		return TimeField;
	})(DateTimeField);
TimeField.prototype.segment = "time";
Widget.alias("timefield", TimeField);
Localization.registerPrototype("cx/widgets/TimeField", TimeField);

var Validator =
	/*#__PURE__*/
	(function(_Field) {
		_inheritsLoose(Validator, _Field);

		function Validator() {
			return _Field.apply(this, arguments) || this;
		}

		var _proto = Validator.prototype;

		_proto.declareData = function declareData() {
			var _Field$prototype$decl;

			return (_Field$prototype$decl = _Field.prototype.declareData).call.apply(
				_Field$prototype$decl,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						value: {
							structured: true
						}
					}
				])
			);
		};

		_proto.isEmpty = function isEmpty(data) {
			return false;
		};

		_proto.render = function render() {
			return null;
		};

		return Validator;
	})(Field);

var DropDownIcon = registerIcon(
	"sort-asc",
	function(props) {
		return VDOM$2.createElement(
			"svg",
			_extends({}, props, {
				viewBox: "0 0 16 16"
			}),
			VDOM$2.createElement("path", {
				fill: "currentColor",
				d: "M10.5 5.8l-3-3-3 3 .707.708L7 4.688v8.312h1V4.69l1.793 1.817z"
			})
		);
	},
	true
);

var GridCell =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(GridCell, _PureContainer);

		function GridCell() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = GridCell.prototype;

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						value: undefined,
						aggregateValue: undefined,
						weight: undefined,
						pad: undefined,
						format: undefined,
						colSpan: undefined,
						rowSpan: undefined,
						editable: undefined
					}
				])
			);
		};

		_proto.init = function init() {
			if (!this.value && this.field)
				this.value = {
					bind: this.recordName + "." + this.field
				};
			if (isUndefined(this.editable)) this.editable = !!this.editor;

			_PureContainer.prototype.init.call(this);
		};

		_proto.prepareCSS = function prepareCSS(context, instance) {
			var _this$CSS$state;

			var data = instance.data;
			data.classNames = this.CSS.expand(
				data.className,
				data.class,
				this.CSS.state(
					((_this$CSS$state = {
						pad: data.pad,
						editable: data.editable
					}),
					(_this$CSS$state["aligned-" + this.align] = this.align),
					_this$CSS$state)
				)
			);
			data.style = this.CSS.parseStyle(data.style);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			var v = this.renderChildren(context, instance);

			if (v.length == 0) {
				v = data.value;
				if (data.format) v = Format$1.value(v, data.format);
			}

			return {
				atomic: true,
				content: v,
				instance: instance,
				data: data,
				key: key
			};
		};

		return GridCell;
	})(PureContainer);
GridCell.prototype.pad = true;
GridCell.prototype.styled = true;

var GridRowLine =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(GridRowLine, _Container);

		function GridRowLine() {
			return _Container.apply(this, arguments) || this;
		}

		var _proto = GridRowLine.prototype;

		_proto.init = function init() {
			this.items = Widget.create(GridCell, this.columns || [], {
				recordName: this.recordName
			});

			_Container.prototype.init.call(this);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			return {
				key: key,
				data: data,
				content: this.renderChildren(context, instance),
				atomic: true
			};
		};

		return GridRowLine;
	})(Container);
GridRowLine.prototype.styled = true;

var GridRow =
	/*#__PURE__*/
	(function(_ValidationGroup) {
		_inheritsLoose(GridRow, _ValidationGroup);

		function GridRow() {
			return _ValidationGroup.apply(this, arguments) || this;
		}

		var _proto = GridRow.prototype;

		_proto.init = function init() {
			this.items = [];

			for (var i = 0; i < 10; i++) {
				if (this["line" + i])
					this.items.push(
						GridRowLine.create(this["line" + i], {
							recordName: this.recordName
						})
					);
			}

			_ValidationGroup.prototype.init.call(this);
		};

		_proto.explore = function explore(context, instance) {
			context.push("dragHandles", (instance.dragHandles = []));

			_ValidationGroup.prototype.explore.call(this, context, instance);
		};

		_proto.exploreCleanup = function exploreCleanup(context, instance) {
			_ValidationGroup.prototype.exploreCleanup.call(this, context, instance);

			context.pop("dragHandles");
		};

		return GridRow;
	})(ValidationGroup);
GridRow.prototype.styled = true; //styles used on the wrapper component

var GridRowComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(GridRowComponent, _VDOM$Component);

		function GridRowComponent(props) {
			var _context;

			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			_this.onMouseMove = (_context = _this).onMouseMove.bind(_context);
			_this.onMouseDown = (_context = _this).onMouseDown.bind(_context);
			_this.onClick = (_context = _this).onClick.bind(_context);
			_this.onKeyDown = (_context = _this).onKeyDown.bind(_context);
			var grid = props.grid,
				instance = props.instance;
			if (grid.widget.onRowDoubleClick)
				_this.onDoubleClick = function(e) {
					grid.invoke("onRowDoubleClick", e, instance);
				};
			if (grid.widget.cellEditable)
				_this.onDoubleClick = function(e) {
					_this.props.parent.moveCursor(_this.props.cursorIndex, {
						cellEdit: true
					});

					e.preventDefault(); //prevent text selection
				};
			if (grid.widget.onRowContextMenu)
				_this.onRowContextMenu = function(e) {
					grid.invoke("onRowContextMenu", e, instance);
				};
			return _this;
		}

		var _proto2 = GridRowComponent.prototype;

		_proto2.render = function render() {
			var _this$props = this.props,
				className = _this$props.className,
				dragSource = _this$props.dragSource,
				instance = _this$props.instance;
			var data = instance.data,
				widget = instance.widget;
			var CSS = widget.CSS;
			var move, up, keyDown;

			if (dragSource) {
				move = this.onMouseMove;
				up = ddMouseUp;
			}

			if (widget.onRowClick) keyDown = this.onKeyDown;
			return VDOM$2.createElement(
				"tbody",
				{
					className: CSS.expand(data.classNames, className),
					style: data.style,
					onClick: this.onClick,
					onDoubleClick: this.onDoubleClick,
					onTouchStart: this.onMouseDown,
					onMouseDown: this.onMouseDown,
					onTouchMove: move,
					onMouseMove: move,
					onTouchEnd: up,
					onMouseUp: up,
					onKeyDown: keyDown,
					onContextMenu: this.onRowContextMenu
				},
				this.props.children
			);
		};

		_proto2.onMouseDown = function onMouseDown(e) {
			var _this$props2 = this.props,
				grid = _this$props2.grid,
				record = _this$props2.record,
				instance = _this$props2.instance,
				parent = _this$props2.parent,
				cursorIndex = _this$props2.cursorIndex;

			if (this.props.dragSource) {
				ddMouseDown(e);

				if (isDragHandleEvent(e) || instance.dragHandles.length == 0) {
					e.preventDefault();
					e.stopPropagation();
				}
			}

			var store = grid.store,
				widget = grid.widget;
			if (widget.selectable) preventFocusOnTouch(e);
			parent.moveCursor(cursorIndex, {
				select:
					!isTouchEvent() &&
					(e.shiftKey || e.ctrlKey || !widget.selection.isSelected(store, record.data, record.index)),
				selectRange: e.shiftKey,
				selectOptions: {
					toggle: e.ctrlKey
				},
				cellIndex: this.getCellIndex(e)
			});
			if (e.shiftKey && !isTouchEvent()) e.preventDefault();
		};

		_proto2.onMouseMove = function onMouseMove(e) {
			if (ddDetect(e) && (isDragHandleEvent(e) || this.props.instance.dragHandles.length == 0))
				this.props.parent.beginDragDrop(e, this.props.record);
		};

		_proto2.getCellIndex = function getCellIndex(e) {
			var td = closest(e.target, function(node) {
				return node.tagName == "TD";
			});
			if (td) return Array.from(td.parentElement.children).indexOf(td);
			return -1;
		};

		_proto2.onKeyDown = function onKeyDown(e) {
			var _this$props3 = this.props,
				grid = _this$props3.grid,
				instance = _this$props3.instance;

			if (e.keyCode == KeyCode.enter && grid.invoke("onRowClick", e, instance) === false) {
				e.stopPropagation();
			}
		};

		_proto2.onClick = function onClick(e) {
			var _this$props4 = this.props,
				grid = _this$props4.grid,
				record = _this$props4.record,
				instance = _this$props4.instance,
				parent = _this$props4.parent,
				cursorIndex = _this$props4.cursorIndex;
			var store = grid.store,
				widget = grid.widget;

			if (grid.widget.onRowClick) {
				if (grid.invoke("onRowClick", e, instance) === false) return;
			}

			e.stopPropagation();
			parent.moveCursor(cursorIndex, {
				select:
					isTouchEvent() ||
					(!e.shiftKey && !e.ctrlKey && widget.selection.isSelected(store, record.data, record.index)),
				selectRange: e.shiftKey,
				selectOptions: {
					toggle: e.ctrlKey
				},
				cellIndex: this.getCellIndex(e)
			});
		};

		_proto2.shouldComponentUpdate = function shouldComponentUpdate(props) {
			return (
				props.shouldUpdate !== false ||
				props.cursor != this.props.cursor ||
				props.selected != this.props.selected ||
				props.isBeingDragged != this.props.isBeingDragged ||
				props.cursorIndex !== this.props.cursorIndex ||
				props.cursorCellIndex !== this.props.cursorCellIndex ||
				props.cellEdit !== this.props.cellEdit
			);
		};

		return GridRowComponent;
	})(VDOM$2.Component);

var Grid =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(Grid, _Widget);

		function Grid() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = Grid.prototype;

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			var selection = this.selection.configureWidget(this);

			(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[
					this,
					{
						records: undefined,
						sorters: undefined,
						scrollable: undefined,
						sortField: undefined,
						sortDirection: undefined,
						emptyText: undefined,
						dragSource: {
							structured: true
						},
						dropZone: {
							structured: true
						},
						filterParams: {
							structured: true
						},
						groupingParams: {
							structured: true
						},
						page: undefined,
						totalRecordCount: undefined,
						tabIndex: undefined
					},
					selection
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.init = function init() {
			var _this = this;

			if (this.recordAlias) this.recordName = this.recordAlias;
			if (this.indexAlias) this.indexName = this.indexAlias;

			if (this.infinite) {
				this.buffered = true;
				this.remoteSort = true;
			}

			if (this.buffered) this.scrollable = true;
			if (isBinding(this.records)) this.recordsBinding = Binding.get(this.records.bind);
			if (!this.row) this.row = {};
			if (this.columns)
				this.row.line1 = {
					columns: this.columns
				};
			this.hasSortableColumns = false;
			var aggregates = {};
			var lines = [];

			for (var i = 0; i < 10; i++) {
				var l = this.row["line" + i];

				if (l) {
					lines.push(l);
				}
			}

			this.header = PureContainer.create({
				items: GridColumnHeaderLine.create(lines)
			});
			this.header.items.forEach(function(line) {
				line.items.forEach(function(c) {
					if (c.sortable) _this.hasSortableColumns = true;

					if (c.aggregate && (c.aggregateField || isDefined(c.aggregateValue))) {
						aggregates[c.aggregateAlias] = {
							value: isDefined(c.aggregateValue)
								? c.aggregateValue
								: isDefined(c.value)
									? c.value
									: c.aggregateField
										? {
												bind: _this.recordName + "." + c.aggregateField
											}
										: null,
							weight:
								c.weight != null
									? c.weight
									: c.weightField && {
											bind: _this.recordName + "." + c.weightField
										},
							type: c.aggregate
						};
					}
				});
			}); //add default footer if some columns have aggregates and grouping is not defined

			if (!this.grouping && (Object.keys(aggregates).length > 0 || this.fixedFooter))
				this.grouping = [
					{
						key: {},
						showFooter: true
					}
				];

			if (this.fixedFooter && isNonEmptyArray(this.grouping)) {
				this.grouping[0].showFooter = true;
				if (this.grouping[0].key && Object.keys(this.grouping[0].key).length > 0)
					Console.warn(
						"First grouping level in grids with a fixed footer must group all data. The key field should be omitted."
					);
			}

			this.dataAdapter = DataAdapter.create(
				{
					type: (this.dataAdapter && this.dataAdapter.type) || GroupAdapter,
					recordsBinding: this.recordsBinding,
					keyField: this.keyField,
					aggregates: aggregates,
					recordName: this.recordName,
					indexName: this.indexName
				},
				this.dataAdapter
			);
			this.selection = Selection.create(this.selection, {
				records: this.records
			});
			if (!this.selection.isDummy) this.selectable = true;

			_Widget.prototype.init.call(this);

			this.row = Widget.create(
				GridRow,
				_objectSpread(
					{
						class: this.CSS.element(this.baseClass, "data"),
						className: this.rowClass,
						style: this.rowStyle,
						recordName: this.recordName
					},
					this.row
				)
			);

			if (this.grouping) {
				this.groupBy(this.grouping);
			}
		};

		_proto.initState = function initState(context, instance) {
			instance.state = {};
			instance.v = 0;
			if (this.infinite)
				instance.buffer = {
					records: [],
					totalRecordCount: 0,
					page: 1
				};
		};

		_proto.prepareData = function prepareData(context, instance) {
			var _data$stateMods;

			var data = instance.data,
				state = instance.state,
				cached = instance.cached;
			data.version = ++instance.v;
			if (!this.infinite) data.totalRecordCount = isArray(data.records) ? data.records.length : 0;
			else {
				if (isNumber(data.totalRecordCount)) instance.buffer.totalRecordCount = data.totalRecordCount;
				else data.totalRecordCount = instance.buffer.totalRecordCount;
				if (isDefined(data.records)) instance.buffer.records = data.records;
				else data.records = instance.buffer.records;
				if (isNumber(data.page)) instance.buffer.page = data.page;
				else data.page = instance.buffer.page;
				data.offset = (data.page - 1) * this.pageSize;
			}
			if (!isArray(data.records)) data.records = [];
			if (state.sorters && !data.sorters) data.sorters = state.sorters;
			if (data.sortField && data.sortDirection)
				data.sorters = [
					{
						field: data.sortField,
						direction: data.sortDirection
					}
				];
			if ((!data.sorters || data.sorters.length == 0) && this.defaultSortField)
				data.sorters = [
					{
						field: this.defaultSortField,
						direction: this.defaultSortDirection || "ASC"
					}
				];
			var headerMode = this.headerMode;

			if (this.headerMode == null) {
				if (this.scrollable || this.hasSortableColumns) headerMode = "default";
				else headerMode = "plain";
			}

			var border = this.border;
			if (this.showBorder || (border == null && this.scrollable)) border = true;
			var dragMode = false;
			if (data.dragSource) dragMode = data.dragSource.mode || "move";
			var dropMode = data.dropZone && data.dropZone.mode;
			if (this.onDrop && !dropMode) dropMode = "preview";
			data.dropMode = dropMode;
			data.stateMods = ((_data$stateMods = {
				selectable: this.selectable,
				"cell-editable": this.cellEditable,
				scrollable: data.scrollable,
				buffered: this.buffered
			}),
			(_data$stateMods["header-" + headerMode] = true),
			(_data$stateMods.border = border),
			(_data$stateMods.vlines = this.vlines),
			(_data$stateMods["drag-" + dragMode] = dragMode),
			(_data$stateMods["drop-" + dropMode] = dropMode),
			_data$stateMods);

			_Widget.prototype.prepareData.call(this, context, instance);

			if (this.onGetGrouping && (!cached.data || cached.data.groupingParams !== data.groupingParams)) {
				var grouping = instance.invoke("onGetGrouping", data.groupingParams, instance);
				this.groupBy(grouping, {
					autoConfigure: true
				});
			}

			instance.records = this.mapRecords(context, instance); //tree adapters can have additional (child) records

			if (instance.records && instance.records.length > data.totalRecordCount && this.dataAdapter.isTreeAdapter)
				data.totalRecordCount = instance.records.length;
		};

		_proto.initInstance = function initInstance(context, instance) {
			instance.fixedHeaderResizeEvent = new SubscriberList();
			this.dataAdapter.initInstance(context, instance);

			_Widget.prototype.initInstance.call(this, context, instance);
		};

		_proto.initComponents = function initComponents(context, instance) {
			var _Widget$prototype$ini;

			return (_Widget$prototype$ini = _Widget.prototype.initComponents).call.apply(
				_Widget$prototype$ini,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						header: this.header
					}
				])
			);
		};

		_proto.explore = function explore(context, instance) {
			context.push("parentPositionChangeEvent", instance.fixedHeaderResizeEvent);

			_Widget.prototype.explore.call(this, context, instance);

			var store = instance.store;
			instance.isSelected = this.selection.getIsSelectedDelegate(store); //do not process rows in buffered mode or cached mode if nothing has changed;

			if (!this.buffered && (!this.cached || instance.shouldUpdate)) {
				for (var i = 0; i < instance.records.length; i++) {
					var record = instance.records[i];

					if (record.type == "data") {
						var row = (record.row = instance.getChild(context, this.row, record.key, record.store));
						var selected = instance.isSelected(record.data, record.index);
						var changed = false;
						if (row.cache("selected", row.selected)) changed = true;
						if (row.cache("recordData", record.data)) changed = true;
						row.selected = selected;

						if (this.cached && !changed && !row.childStateDirty) {
							row.shouldUpdate = false;
						} else row.scheduleExploreIfVisible(context);
					}
				}
			}
		};

		_proto.exploreCleanup = function exploreCleanup(context, instance) {
			context.pop("parentPositionChangeEvent");
		};

		_proto.applyGrouping = function applyGrouping(grouping, _temp) {
			var _this2 = this;

			var _ref = _temp === void 0 ? {} : _temp,
				autoConfigure = _ref.autoConfigure;

			if (grouping) {
				if (!isArray(grouping)) {
					if (isString(grouping) || isObject(grouping)) return this.groupBy([grouping]);
					throw new Error("DynamicGrouping should be an array or grouping objects");
				}

				grouping = grouping.map(function(g, i) {
					if (isString(g)) {
						var _key;

						return {
							key: ((_key = {}),
							(_key[g] = {
								bind: _this2.recordName + "." + g
							}),
							_key),
							showHeader: !_this2.scrollable && i == grouping.length - 1,
							showFooter: true,
							caption: {
								bind: "$group." + g
							},
							text: {
								bind: _this2.recordName + "." + g
							}
						};
					}

					return g;
				});
				initGrouping(grouping);
			}

			if (autoConfigure)
				this.showHeader =
					this.scrollable ||
					!isArray(grouping) ||
					!grouping.some(function(g) {
						return g.showHeader;
					});

			if (!this.dataAdapter.groupBy) {
				Console.warn("Configured grid data adapter does not support grouping. Grouping instructions are ignored.");
				return;
			}

			this.dataAdapter.groupBy(grouping);
		};

		_proto.groupBy = function groupBy(grouping, options) {
			this.applyGrouping(grouping, options);
			this.update();
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			var fixedHeader = data.scrollable && this.showHeader && this.renderHeader(context, instance, "header", true);
			if (!this.buffered) this.renderRows(context, instance);
			var header = this.showHeader && this.renderHeader(context, instance, "header");
			var fixedFooter = false;

			if (instance.footerVDOM) {
				fixedFooter = instance.footerVDOM;
			}

			return VDOM$2.createElement(GridComponent, {
				key: key,
				instance: instance,
				data: instance.data,
				shouldUpdate: instance.shouldUpdate,
				header: header,
				fixedHeader: fixedHeader,
				fixedFooter: fixedFooter
			});
		};

		_proto.renderHeader = function renderHeader(context, instance, key, fixed) {
			var _this3 = this;

			var data = instance.data,
				widget = instance.widget,
				components = instance.components;
			var header = components.header;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var headerRows = [];
			if (!header) return null;
			var skip = {};
			header.children.forEach(function(line, lineIndex) {
				var empty = [true, true, true];
				var result = [[], [], []];
				line.children.forEach(function(columnInstance, i) {
					var c = columnInstance.widget;

					var _loop = function _loop(l) {
						var colKey = lineIndex + "-" + i + "-" + l;
						if (skip[colKey]) return "continue";
						var header = columnInstance.components["header" + (l + 1)];
						var colSpan = void 0,
							rowSpan = void 0,
							style = void 0,
							cls = void 0,
							mods = [],
							content = void 0,
							sortIcon = void 0,
							tool = void 0;

						if (header) {
							empty[l] = false;
							if (header.widget.align) mods.push("aligned-" + header.widget.align);
							else if (c.align) mods.push("aligned-" + c.align);

							if (c.sortable && header.widget.allowSorting) {
								mods.push("sortable");

								if (data.sorters && data.sorters[0].field == (c.sortField || c.field)) {
									mods.push("sorted-" + data.sorters[0].direction.toLowerCase());
									sortIcon = VDOM$2.createElement(DropDownIcon, {
										className: CSS.element(baseClass, "column-sort-icon")
									});
								}
							}

							style = header.data.style;
							if (header.data.classNames) cls = header.data.classNames;
							content = header.render(context);

							if (header.components && header.components.tool) {
								tool = VDOM$2.createElement(
									"div",
									{
										className: CSS.element(baseClass, "col-header-tool")
									},
									getContent(header.components.tool.render(context))
								);
								mods.push("tool");
							}

							if (header.data.colSpan > 1 || header.data.rowSpan > 1) {
								colSpan = header.data.colSpan;
								rowSpan = header.data.rowSpan;

								for (var r = 0; r < header.data.rowSpan; r++) {
									for (var _c = 0; _c < header.data.colSpan; _c++) {
										skip[lineIndex + "-" + (i + _c) + "-" + (l + r)] = true;
									}
								}
							}
						}

						cls = CSS.element(baseClass, "col-header", mods) + (cls ? " " + cls : "");
						var onContextMenu = void 0;
						if (_this3.onColumnContextMenu)
							onContextMenu = function onContextMenu(e) {
								return instance.invoke("onColumnContextMenu", e, columnInstance);
							};
						result[l].push(
							VDOM$2.createElement(
								"th",
								{
									key: i,
									colSpan: colSpan,
									rowSpan: rowSpan,
									className: cls,
									style: style,
									onClick: function onClick(e) {
										return _this3.onHeaderClick(e, c, instance, l);
									},
									onContextMenu: onContextMenu
								},
								getContent(content),
								sortIcon,
								tool
							)
						);
					};

					for (var l = 0; l < 3; l++) {
						var _ret = _loop(l);

						if (_ret === "continue") continue;
					}
				});
				result = result.filter(function(_, i) {
					return !empty[i];
				});

				if (result[0]) {
					if (fixed) {
						result[0].push(
							VDOM$2.createElement("th", {
								key: "dummy",
								rowSpan: result.length,
								className: CSS.element(baseClass, "col-header")
							})
						);
					}

					headerRows.push(
						VDOM$2.createElement(
							"tbody",
							{
								key: "h" + key + lineIndex,
								className: CSS.element(baseClass, "header")
							},
							result.map(function(h, i) {
								return VDOM$2.createElement(
									"tr",
									{
										key: i
									},
									h
								);
							})
						)
					);
				}
			});
			if (headerRows.length == 0) return null;
			return headerRows;
		};

		_proto.onHeaderClick = function onHeaderClick(e, column, instance, headerLine) {
			e.preventDefault();
			e.stopPropagation();
			var data = instance.data;
			var header = column.components["header" + (headerLine + 1)];

			if (header && header.allowSorting && column.sortable && (column.field || column.sortField || column.value)) {
				var sortField = column.sortField || column.field;
				var dir = "ASC";

				if (
					data.sorters &&
					data.sorters[0].field == sortField &&
					(data.sorters[0].value == column.value || data.sortField)
				) {
					if (data.sorters[0].direction == "ASC") dir = "DESC";
					else if (this.clearableSort && data.sorters[0].direction == "DESC") dir = null;
				}

				var sorters = dir
					? [
							{
								field: sortField,
								direction: dir,
								value: column.value
							}
						]
					: null;
				instance.set("sorters", sorters);
				instance.set("sortField", sortField);
				instance.set("sortDirection", dir);
				if (!this.remoteSort || this.infinite)
					instance.setState({
						sorters: sorters
					});
			}
		};

		_proto.renderGroupHeader = function renderGroupHeader(context, instance, g, level, group, i, store) {
			var CSS = this.CSS,
				baseClass = this.baseClass;
			var data = store.getData();
			var caption = g.caption(data);
			return VDOM$2.createElement(
				"tbody",
				{
					key: "g-" + level + "-" + i,
					className: CSS.element(baseClass, "group-caption", ["level-" + level])
				},
				VDOM$2.createElement(
					"tr",
					null,
					VDOM$2.createElement(
						"td",
						{
							colSpan: 1000
						},
						caption
					)
				)
			);
		};

		_proto.renderGroupFooter = function renderGroupFooter(context, instance, g, level, group, i, store, fixed) {
			var CSS = this.CSS,
				baseClass = this.baseClass;
			var data = store.getData();
			var skip = 0;
			var header = instance.components.header;
			var lines = [];
			header.children.forEach(function(line, lineIndex) {
				var empty = true;
				var cells = line.children.map(function(ci, i) {
					if (--skip >= 0) return null;
					var v,
						c = ci.widget,
						colSpan,
						pad;

					if (c.footer) {
						v = c.footer.value(data);
						pad = c.footer.pad;
						colSpan = c.footer.colSpan;
						empty = false;

						if (c.footer.expand) {
							colSpan = 1;

							for (
								var ind = i + 1;
								ind < line.children.length && !line.children[ind].widget.footer && !line.children[ind].widget.aggregate;
								ind++
							) {
								colSpan++;
							}
						}

						if (colSpan > 1) skip = colSpan - 1;
					} else if (c.aggregate && c.aggregateField && c.footer !== false) {
						empty = false;
						v = group[c.aggregateField];
						if (isString(ci.data.format)) v = Format$1.value(v, ci.data.format);
					}

					var cls = "";
					if (c.align) cls += CSS.state("aligned-" + c.align);
					if (pad !== false) cls += (cls ? " " : "") + CSS.state("pad");
					return VDOM$2.createElement(
						"td",
						{
							key: i,
							className: cls,
							colSpan: colSpan
						},
						v
					);
				});
				if (empty) return;
				if (fixed)
					cells.push(
						VDOM$2.createElement("td", {
							key: "dummy",
							className: CSS.element(baseClass, "fixed-footer-corner")
						})
					);
				lines.push(
					VDOM$2.createElement(
						"tr",
						{
							key: lineIndex
						},
						cells
					)
				);
			});
			if (lines.length == 0) return null;
			return VDOM$2.createElement(
				"tbody",
				{
					key: "f" + i,
					className: CSS.element(baseClass, "group-footer", ["level-" + level])
				},
				lines
			);
		};

		_proto.renderRows = function renderRows(context, instance) {
			var records = instance.records;
			instance.footerVDOM = null;
			if (!isArray(records)) return null;
			var record, g;

			for (var i = 0; i < records.length; i++) {
				record = records[i];
				if (record.type == "data") record.vdom = record.row.render(context, record.key);

				if (record.type == "group-header") {
					record.vdom = [];
					g = record.grouping;
					if (g.caption)
						record.vdom.push(
							this.renderGroupHeader(
								context,
								instance,
								g,
								record.level,
								record.group,
								record.key + "-caption",
								record.store
							)
						);
					if (g.showHeader) record.vdom.push(this.renderHeader(context, instance, record.key + "-header"));
				}

				if (record.type == "group-footer") {
					g = record.grouping;

					if (g.showFooter) {
						record.vdom = this.renderGroupFooter(
							context,
							instance,
							g,
							record.level,
							record.group,
							record.key + "-footer",
							record.store
						);
					}
				}

				if (this.fixedFooter && i == records.length - 1) {
					instance.footerVDOM = this.renderGroupFooter(
						context,
						instance,
						g,
						record.level,
						record.group,
						record.key + "-footer",
						record.store,
						true
					);
				}
			}
		};

		_proto.mapRecords = function mapRecords(context, instance) {
			var data = instance.data,
				store = instance.store;
			var filter = null;
			if (this.onCreateFilter) filter = instance.invoke("onCreateFilter", data.filterParams, instance);
			var sorters = !this.remoteSort && data.sorters;
			this.dataAdapter.setFilter(filter);
			this.dataAdapter.sort(sorters); //if no filtering or sorting applied, let the component maps records on demand

			if (this.buffered && !filter && !isNonEmptyArray(sorters) && !this.dataAdapter.isTreeAdapter) return null;
			return this.dataAdapter.getRecords(context, instance, data.records, store);
		};

		_proto.mapRecord = function mapRecord(context, instance, data, index) {
			return this.dataAdapter.mapRecord(context, instance, data, instance.store, this.recordsBinding, index);
		};

		return Grid;
	})(Widget);
Grid.prototype.baseClass = "grid";
Grid.prototype.showHeader = true;
Grid.prototype.showFooter = false;
Grid.prototype.recordName = "$record";
Grid.prototype.indexName = "$index";
Grid.prototype.remoteSort = false;
Grid.prototype.lockColumnWidths = false;
Grid.prototype.lockColumnWidthsRequiredRowCount = 3;
Grid.prototype.focused = false;
Grid.prototype.emptyText = false;
Grid.prototype.showBorder = false; // show border override for material theme

Grid.prototype.cached = false;
Grid.prototype.buffered = false;
Grid.prototype.bufferStep = 15;
Grid.prototype.bufferSize = 60;
Grid.prototype.pageSize = 100;
Grid.prototype.infinite = false;
Grid.prototype.styled = true;
Grid.prototype.scrollSelectionIntoView = false;
Grid.prototype.clearableSort = false;
Grid.prototype.cellEditable = false;
Widget.alias("grid", Grid);
Localization.registerPrototype("cx/widgets/Grid", Grid);

var GridComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(GridComponent, _VDOM$Component);

		function GridComponent(props) {
			var _this4;

			_this4 = _VDOM$Component.call(this, props) || this;
			_this4.dom = {};
			var widget = props.instance.widget;
			var end = Math.min(widget.bufferSize, props.data.totalRecordCount);
			_this4.state = {
				cursor: widget.focused && widget.selectable ? 0 : -1,
				cursorCellIndex: 0,
				focused: widget.focused,
				dragInsertionIndex: null,
				start: 0,
				end: end
			};
			_this4.syncBuffering = false;

			if (widget.infinite) {
				_this4.start = 0;
				_this4.end = end;
				_this4.syncBuffering = false; //control with a flag

				_this4.loadingStartPage = 0;
				_this4.loadingEndPage = 0;
			}

			_this4.scrollerRef = function(el) {
				_this4.dom.scroller = el;
			};

			return _this4;
		}

		var _proto2 = GridComponent.prototype;

		_proto2.render = function render() {
			var _this5 = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				data = _this$props.data;
			var widget = instance.widget;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var dragSource = data.dragSource;
			var _this$state = this.state,
				dragged = _this$state.dragged,
				start = _this$state.start,
				end = _this$state.end,
				cursor = _this$state.cursor,
				cursorCellIndex = _this$state.cursorCellIndex,
				cellEdit = _this$state.cellEdit;

			if (this.syncBuffering) {
				start = this.start;
				end = this.end;
			}

			var children = [];

			var addRow = function addRow(record, i, standalone) {
				var store = record.store,
					key = record.key,
					row = record.row;
				var isDragged = dragged && (row.selected || record == dragged);
				var mod = {
					selected: row.selected,
					dragged: isDragged,
					draggable: dragSource && (!row.dragHandles || row.dragHandles.length == 0),
					cursor: widget.selectable && i == cursor
				};

				var wrap = function wrap(children) {
					return VDOM$2.createElement(
						GridRowComponent,
						{
							key: key,
							className: CSS.state(mod),
							store: store,
							dragSource: dragSource,
							instance: row,
							grid: instance,
							record: record,
							parent: _this5,
							cursorIndex: i,
							selected: row.selected,
							isBeingDragged: dragged,
							cursor: mod.cursor,
							cursorCellIndex: i == cursor && cursorCellIndex,
							cellEdit: i == cursor && cursorCellIndex && cellEdit,
							shouldUpdate: row.shouldUpdate
						},
						children.content.map(function(_ref2) {
							var key = _ref2.key,
								data = _ref2.data,
								content = _ref2.content;
							return VDOM$2.createElement(
								"tr",
								{
									key: key,
									className: data.classNames,
									style: data.style
								},
								content.map(function(_ref3, cellIndex) {
									var key = _ref3.key,
										data = _ref3.data,
										content = _ref3.content,
										instance = _ref3.instance;
									var cellected = i == cursor && cellIndex == cursorCellIndex;
									var className = cellected ? CSS.expand(data.classNames, CSS.state("cellected")) : data.classNames;

									if (cellected && cellEdit) {
										var column = widget.row.line1.columns[cursorCellIndex];
										if (column && column.editor && data.editable)
											//add an inner div with fixed height in order to help IE absolutely position the contents inside
											return VDOM$2.createElement(
												"td",
												{
													key: key,
													className: CSS.element(baseClass, "cell-editor")
												},
												VDOM$2.createElement(
													"div",
													{
														className: CSS.element(baseClass, "cell-editor-wrap"),
														style:
															_this5.rowHeight > 0
																? {
																		height: _this5.rowHeight + 1
																	}
																: null
													},
													VDOM$2.createElement(Cx, {
														parentInstance: instance,
														subscribe: true,
														items: [
															{
																$type: ValidationGroup,
																valid: {
																	get: function get() {
																		return _this5.cellEditorValid;
																	},
																	set: function set(value) {
																		_this5.cellEditorValid = value;
																	}
																},
																jsxAttributes: ["valid"],
																children: [
																	"\n                                       ",
																	column.editor,
																	"\n                                    "
																]
															}
														]
													})
												)
											);
									}

									return VDOM$2.createElement(
										"td",
										{
											key: key,
											className: className,
											style: data.style,
											colSpan: data.colSpan,
											rowSpan: data.rowSpan
										},
										content
									);
								})
							);
						})
					);
				};

				if (standalone) {
					children.push(
						VDOM$2.createElement(Cx, {
							key: key,
							instance: record.row,
							parentInstance: instance,
							options: {
								name: "grid-row"
							},
							contentFactory: function contentFactory(x) {
								return wrap({
									content: Array.isArray(x.children) ? x.children : [x.children],
									data: {}
								});
							},
							params: _objectSpread({}, mod, {
								cursorIndex: i,
								data: record.data,
								cursorCellIndex: i == cursor && cursorCellIndex,
								cellEdit: i == cursor && cursorCellIndex && cellEdit
							})
						})
					);
				} else children.push(wrap(record.vdom)); //avoid re-rendering on cursor change

				row.shouldUpdate = false;
			};

			if (widget.buffered) {
				var context = new RenderingContext();
				var dummyDataClass = CSS.element(baseClass, "data", {
					dummy: true
				});
				if (!instance.recordInstanceCache) instance.recordInstanceCache = new InstanceCache(instance);
				instance.recordInstanceCache.mark();
				this.getRecordsSlice(start, end).forEach(function(r, i) {
					if (r == null) {
						addRow(
							{
								key: "dummy-" + start + i,
								row: {
									data: {
										classNames: dummyDataClass
									},
									widget: widget.row
								},
								vdom: {
									content: [
										{
											key: 0,
											data: {},
											content: [
												{
													key: 0,
													data: {
														colSpan: 1000,
														style: {
															height: _this5.rowHeight + "px"
														}
													}
												}
											]
										}
									]
								}
							},
							start + i
						);
					} else {
						var record = instance.records
							? r
							: widget.mapRecord(context, instance, r, widget.infinite ? start + i - data.offset : start + i);
						var row = (record.row = instance.recordInstanceCache.getChild(widget.row, record.store, record.key));
						row.detached = true;
						row.selected = instance.isSelected(record.data, record.index); // if (row.cache('selected', row.selected) || row.cache('recordData', record.data)) {
						//    //row.markShouldUpdate(context);
						// }

						addRow(record, start + i, true);
					}
				});
				instance.recordInstanceCache.sweep();
			} else {
				instance.records.forEach(function(record, i) {
					if (record.type == "data") {
						addRow(record, i);
					} else children.push(record.vdom);
				});
			}

			if (this.state.dragInsertionIndex != null) {
				var dragInsertionRow = VDOM$2.createElement(
					"tbody",
					{
						key: "dropzone"
					},
					VDOM$2.createElement(
						"tr",
						null,
						VDOM$2.createElement("td", {
							className: CSS.element(baseClass, "dropzone"),
							colSpan: 1000,
							style: {
								height: data.dropMode == "insertion" ? 0 : this.state.dragItemHeight
							}
						})
					)
				);
				children.splice(this.state.dragInsertionIndex, 0, dragInsertionRow);
			}

			var content = [];

			if (data.totalRecordCount == 0 && data.emptyText) {
				children = [
					VDOM$2.createElement(
						"tbody",
						{
							key: "empty",
							className: CSS.element(baseClass, "empty-text")
						},
						VDOM$2.createElement(
							"tr",
							null,
							VDOM$2.createElement(
								"td",
								{
									colSpan: 1000
								},
								data.emptyText
							)
						)
					)
				];
			}

			content.push(
				VDOM$2.createElement(
					"div",
					{
						key: "scroller",
						ref: this.scrollerRef,
						tabIndex: widget.selectable || widget.cellEditable ? data.tabIndex || 0 : null,
						onScroll: this.onScroll.bind(this),
						className: CSS.element(baseClass, "scroll-area", {
							"fixed-header": !!this.props.header
						}),
						onKeyDown: this.handleKeyDown.bind(this),
						onFocus: this.onFocus.bind(this),
						onBlur: this.onBlur.bind(this)
					},
					VDOM$2.createElement(
						"div",
						{
							className: CSS.element(baseClass, "table-wrapper")
						},
						VDOM$2.createElement(
							"table",
							{
								ref: function ref(el) {
									_this5.dom.table = el;
								}
							},
							this.props.header,
							children
						)
					)
				)
			);
			if (this.props.fixedHeader)
				content.push(
					VDOM$2.createElement(
						"div",
						{
							key: "fh",
							ref: function ref(el) {
								_this5.dom.fixedHeader = el;
							},
							className: CSS.element(baseClass, "fixed-header"),
							style: {
								display: this.scrollWidth > 0 ? "block" : "none"
							}
						},
						VDOM$2.createElement("table", null, this.props.fixedHeader)
					)
				);
			if (this.props.fixedFooter)
				content.push(
					VDOM$2.createElement(
						"div",
						{
							key: "ff",
							ref: function ref(el) {
								_this5.dom.fixedFooter = el;
							},
							className: CSS.element(baseClass, "fixed-footer"),
							style: {
								display: this.scrollWidth > 0 ? "block" : "none"
							}
						},
						VDOM$2.createElement("table", null, this.props.fixedFooter)
					)
				);
			return VDOM$2.createElement(
				"div",
				{
					className: data.classNames,
					style: data.style
				},
				content
			);
		};

		_proto2.getRecordsSlice = function getRecordsSlice(start, end) {
			var _this$props2 = this.props,
				data = _this$props2.data,
				instance = _this$props2.instance;
			var widget = instance.widget;

			if (!widget.infinite) {
				var source = instance.records || data.records;
				return source.slice(start, end);
			}

			var offset = data.offset,
				records = data.records;
			var result = [];

			for (var i = start; i < Math.min(end, data.totalRecordCount); i++) {
				if (i >= offset && i < offset + records.length) result.push(records[i - offset]);
				else result.push(null);
			}

			return result;
		};

		_proto2.ensureData = function ensureData(visibleStart, visibleEnd) {
			var _this6 = this;

			if (this.loading) return;
			var instance = this.props.instance;
			var widget = instance.widget;
			var pageSize = widget.pageSize;
			var startPage = Math.trunc(visibleStart / pageSize) + 1,
				endPage = Math.trunc((visibleEnd - 1) / pageSize) + 1; //debouncing restricts excessive page loading on fast scrolling as rendering data is
			//useless because visible region is scrolled away before data appears
			//the user should spent some time on the page before loading it

			if (!this.loadPageRange)
				this.loadPageRange = debounce(function(startPage, endPage) {
					var data = _this6.props.data;
					var records = data.records,
						offset = data.offset;
					var promises = [];

					for (var page = startPage; page <= endPage; page++) {
						var s = (page - 1) * pageSize,
							e = s + pageSize;

						if (s >= offset && e <= offset + records.length) {
							promises.push(Promise.resolve(records.slice(s - offset, e - offset)));
						} else {
							var result = instance.invoke(
								"onFetchRecords",
								{
									page: page,
									pageSize: pageSize,
									sorters: data.sorters,
									sortField: data.sortField,
									sortDirection: data.sortDirection,
									filterParams: data.filterParams,
									state: _this6.prevFetchRecordsState
								},
								instance
							);
							promises.push(Promise.resolve(result));
						}
					}

					_this6.loading = true;
					Promise.all(promises)
						.then(function(pageRecords) {
							_this6.loading = false;
							var records = [];
							var totalRecordCount;
							var lastPage;
							pageRecords.forEach(function(page) {
								if (Array.isArray(page)) {
									records.push.apply(records, page);
								} else {
									if (!Array.isArray(page.records))
										throw new Error(
											"onFetchRecords should return an array of records or an object with results inside records property."
										);
									totalRecordCount = page.totalRecordCount;
									lastPage = page.lastPage;
									_this6.prevFetchRecordsState = page.state;
									records.push.apply(records, page.records);
								}
							});
							var data = _this6.props.data;

							if (!isNumber(totalRecordCount)) {
								totalRecordCount = (startPage - 1) * pageSize + records.length;
								if (!lastPage && records.length == (endPage - startPage + 1) * pageSize) totalRecordCount++;
								if (data.totalRecordCount > totalRecordCount) totalRecordCount = data.totalRecordCount;
							}

							instance.buffer.totalRecordCount = data.totalRecordCount = totalRecordCount;
							instance.buffer.records = data.records = records;
							instance.buffer.page = data.page = startPage;
							data.offset = (startPage - 1) * pageSize;
							instance.store.silently(function() {
								instance.set("records", records);
								instance.set("page", startPage);
								instance.set("totalRecordCount", totalRecordCount);
							});
							var stateChanges = {
								startPage: startPage,
								endPage: endPage
							};
							if (_this6.state.end == 0) stateChanges.end = Math.min(widget.bufferSize, totalRecordCount);

							_this6.setState(stateChanges, function() {
								_this6.loadingStartPage = startPage;
								_this6.loadingEndPage = endPage;

								_this6.onScroll();
							});
						})
						.catch(function(error) {
							_this6.loading = false;
							if (widget.onLoadingError) instance.invoke(error, "onLoadingError", instance);
						});
				}, 30);

			if (startPage < this.loadingStartPage || endPage > this.loadingEndPage) {
				this.loadingStartPage = startPage;
				this.loadingEndPage = endPage;
				this.loadPageRange(startPage, endPage);
			}
		};

		_proto2.onScroll = function onScroll() {
			var _this7 = this;

			if (this.dom.fixedHeader) {
				this.dom.fixedHeader.scrollLeft = this.dom.scroller.scrollLeft;
			}

			if (this.dom.fixedFooter) {
				this.dom.fixedFooter.scrollLeft = this.dom.scroller.scrollLeft;
			}

			var _this$props3 = this.props,
				instance = _this$props3.instance,
				data = _this$props3.data;
			var widget = instance.widget;

			if (widget.buffered && !this.pending) {
				var start = 0;

				if (this.rowHeight > 0) {
					start = Math.round(this.dom.scroller.scrollTop / this.rowHeight - widget.bufferStep);
					start = Math.round(start / widget.bufferStep) * widget.bufferStep;
					start = Math.max(0, Math.min(start, data.totalRecordCount - widget.bufferSize));
				}

				var end = Math.min(data.totalRecordCount, start + widget.bufferSize);

				if (widget.infinite) {
					this.ensureData(start, end);
				}

				if (this.syncBuffering) {
					this.start = start;
					this.end = end;
				} else if (this.state.end != end) {
					this.pending = true;
					this.setState(
						{
							start: start,
							end: end
						},
						function() {
							_this7.pending = false;
						}
					);
				}
			}
		};

		_proto2.shouldComponentUpdate = function shouldComponentUpdate(props, state) {
			return props.shouldUpdate !== false || state !== this.state;
		};

		_proto2.componentDidMount = function componentDidMount() {
			this.componentDidUpdate();
			var instance = this.props.instance;
			var widget = instance.widget;
			if (widget.scrollable)
				this.offResize = ResizeManager.trackElement(this.dom.scroller, this.componentDidUpdate.bind(this));
			if (widget.pipeKeyDown) instance.invoke("pipeKeyDown", this.handleKeyDown.bind(this), instance);
			this.unregisterDropZone = registerDropZone(this);
			if (widget.infinite) this.ensureData(0, 0);
		};

		_proto2.onDragStart = function onDragStart(e) {
			var instance = this.props.instance;
			var widget = instance.widget;
			if (widget.onDragStart) instance.invoke("onDragStart", e, instance);
		};

		_proto2.onDrop = function onDrop(e) {
			var instance = this.props.instance;
			var widget = instance.widget;

			if (widget.onDrop) {
				e.target = {
					insertionIndex: this.state.dragInsertionIndex
				};
				instance.invoke("onDrop", e, instance);
			}
		};

		_proto2.onDropTest = function onDropTest(e) {
			var instance = this.props.instance;
			var widget = instance.widget;
			return widget.onDropTest && instance.invoke("onDropTest", e, instance);
		};

		_proto2.onDragEnd = function onDragEnd(e) {
			this.setState({
				dragInsertionIndex: null,
				lastDragInsertionIndex: null
			});
			var instance = this.props.instance;
			var widget = instance.widget;
			if (widget.onDragEnd) instance.invoke("onDragEnd", e, instance);
		};

		_proto2.onDragMeasure = function onDragMeasure(e) {
			var r = getTopLevelBoundingClientRect(this.dom.scroller);
			var _e$cursor = e.cursor,
				clientX = _e$cursor.clientX,
				clientY = _e$cursor.clientY;
			if (clientX < r.left || clientX >= r.right || clientY < r.top || clientY >= r.bottom) return false;
			return {
				over: 1000
			};
		};

		_proto2.onDragOver = function onDragOver(ev) {
			var _this$props$instance$ = this.props.instance.widget,
				CSS = _this$props$instance$.CSS,
				baseClass = _this$props$instance$.baseClass;
			var rowClass = CSS.element(baseClass, "data");
			var nodes = Array.from(this.dom.table.children).filter(function(node) {
				return node.className && node.className.indexOf(rowClass) != -1;
			});
			var s = 0,
				e = nodes.length,
				m,
				b;
			var parentOffset = getParentFrameBoundingClientRect(this.dom.scroller);
			var cy = ev.cursor.clientY - parentOffset.top;

			while (s < e) {
				m = Math.floor((s + e) / 2);
				b = nodes[m].getBoundingClientRect(); //dragged items might be invisible and have no client bounds

				if (b.top == 0 && b.bottom == 0) {
					if (m > s) m--;
					else if (m + 1 < e) m = m + 1;
					else {
						s = e = m;
						break;
					}
					b = nodes[m].getBoundingClientRect();
				}

				if (cy < b.top) e = m;
				else if (cy > b.bottom) s = m + 1;
				else {
					if (cy > (b.bottom + b.top) / 2) s = e = m + 1;
					else {
						s = e = m;
					}
				}
			}

			if (s != this.state.dragInsertionIndex) {
				this.setState({
					dragInsertionIndex: s,
					dragItemHeight: ev.source.height - 1
				});
			}
		};

		_proto2.onDragLeave = function onDragLeave(e) {
			this.setState({
				dragInsertionIndex: null
			});
		};

		_proto2.onGetHScrollParent = function onGetHScrollParent() {
			var widget = this.props.instance.widget;
			if (widget.scrollable) return this.dom.scroller;
			return findScrollableParent(this.dom.table, true);
		};

		_proto2.onGetVScrollParent = function onGetVScrollParent() {
			var widget = this.props.instance.widget;
			if (widget.scrollable) return this.dom.scroller;
			return findScrollableParent(this.dom.table);
		};

		_proto2.componentWillReceiveProps = function componentWillReceiveProps(props) {
			var _props$instance = props.instance,
				data = _props$instance.data,
				widget = _props$instance.widget;
			this.setState({
				cursor: Math.max(
					Math.min(this.state.cursor, data.totalRecordCount - 1),
					widget.selectable && this.state.focused ? 0 : -1
				)
			});
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			var instance = this.props.instance;
			var widget = instance.widget;
			if (this.offResize) this.offResize();
			offFocusOut(this);
			if (this.unregisterDropZone) this.unregisterDropZone();
			if (widget.pipeKeyDown) instance.invoke("pipeKeyDown", null, instance);
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			var _this$props4 = this.props,
				instance = _this$props4.instance,
				data = _this$props4.data;
			var widget = instance.widget;

			if (
				widget.lockColumnWidths &&
				isArray(data.records) &&
				data.records.length >= widget.lockColumnWidthsRequiredRowCount
			) {
				var headerTBody = this.dom.table.firstChild;

				for (var r = 0; r < headerTBody.children.length; r++) {
					var sr = headerTBody.children[r];

					for (var c = 0; c < sr.children.length; c++) {
						var cell = sr.children[c];
						cell.style.width = cell.style.minWidth = cell.style.maxWidth = sr.children[c].offsetWidth + "px";
						cell.style.boxSizing = "border-box";
					}
				}
			}

			if (widget.scrollable) {
				this.scrollWidth = this.dom.scroller.offsetWidth - this.dom.scroller.clientWidth;
				var resized = false,
					headerHeight = 0,
					footerHeight = 0,
					rowHeight = 0;

				if (this.dom.fixedHeader) {
					var fixedHeaderTBody = this.dom.fixedHeader.firstChild.firstChild;
					resized = copyCellWidths(this.dom.table.firstChild, fixedHeaderTBody);
					var scrollColumnEl = fixedHeaderTBody.firstChild.lastChild;
					if (scrollColumnEl) scrollColumnEl.style.minWidth = scrollColumnEl.style.maxWidth = this.scrollWidth + "px";
					this.dom.fixedHeader.style.display = "block";
					headerHeight = this.dom.fixedHeader.offsetHeight;
					this.dom.scroller.style.marginTop = headerHeight + "px";
				} else {
					this.dom.scroller.style.marginTop = 0;
				}

				if (this.dom.fixedFooter) {
					var dstTableBody = this.dom.fixedFooter.firstChild.firstChild;
					var srcTableBody = this.dom.table.lastChild;
					copyCellWidths(srcTableBody, dstTableBody);
					var _scrollColumnEl = dstTableBody.firstChild.lastChild;
					if (_scrollColumnEl)
						_scrollColumnEl.style.minWidth = _scrollColumnEl.style.maxWidth = this.scrollWidth + "px";
					this.dom.fixedFooter.style.display = "block";
					footerHeight = this.dom.fixedFooter.offsetHeight;
					this.dom.scroller.style.marginBottom = footerHeight + "px"; //Show the last row if fixed footer is shown without grouping, otherwise hide it
					//Hacky: accessing internal adapter property to check if grouping is applied

					if (!isNonEmptyArray(widget.dataAdapter.groupings)) footerHeight = 0;
				} else {
					this.dom.scroller.style.marginBottom = 0;
				}

				if (widget.buffered) {
					var _this$state2 = this.state,
						start = _this$state2.start,
						end = _this$state2.end;

					if (this.syncBuffering) {
						start = this.start;
						end = this.end;
					}

					var remaining = 0,
						count = Math.min(data.totalRecordCount, end - start);

					if (count > 0) {
						rowHeight = Math.round((this.dom.table.offsetHeight - headerHeight) / count); // if (this.rowHeight && this.rowHeight != rowHeight) {
						//    console.warn("ROW-HEIGHT-CHANGE", this.rowHeight, rowHeight);
						// }

						remaining = Math.max(0, data.totalRecordCount - end);
					}

					this.dom.table.style.marginTop = (-headerHeight + start * rowHeight).toFixed(0) + "px";
					this.dom.table.style.marginBottom = (remaining * headerHeight - footerHeight).toFixed(0) + "px";
				} else {
					this.dom.table.style.marginTop = -headerHeight + "px";
					this.dom.table.style.marginBottom = -footerHeight + "px";
				}

				this.rowHeight = rowHeight;
				var sortersChanged = widget.infinite && !shallowEquals(data.sorters, this.lastSorters);

				if (data.totalRecordCount == 0) {
					this.dom.scroller.scrollTop = 0;
				}

				if (sortersChanged || data.filterParams !== this.lastScrollFilterParams) {
					this.dom.scroller.scrollTop = 0;
					this.lastScrollFilterParams = data.filterParams;
					this.lastSorters = data.sorters;

					if (widget.infinite) {
						this.loadingStartPage = 0;
						this.loadingEndPage = 0;
						instance.buffer.records = data.records = [];
						instance.buffer.totalRecordCount = 0;
						instance.buffer.page = 1;
						this.prevFetchRecordsState = null;
					}
				}

				if (widget.scrollSelectionIntoView && !widget.buffered) {
					var CSS = widget.CSS,
						baseClass = widget.baseClass;
					var selectedRowSelector = "." + CSS.element(baseClass, "data") + "." + CSS.state("selected");
					var firstSelectedRow = this.dom.table.querySelector(selectedRowSelector);

					if (firstSelectedRow != this.selectedEl) {
						firstSelectedRow && scrollElementIntoView(firstSelectedRow);
						this.selectedEl = firstSelectedRow;
					}
				}

				setTimeout(this.onScroll.bind(this), 0);
				if (resized) instance.fixedHeaderResizeEvent.notify();
			}
		};

		_proto2.moveCursor = function moveCursor(index, _temp2) {
			var _this8 = this;

			var _ref4 = _temp2 === void 0 ? {} : _temp2,
				focused = _ref4.focused,
				hover = _ref4.hover,
				scrollIntoView = _ref4.scrollIntoView,
				select = _ref4.select,
				selectRange = _ref4.selectRange,
				selectOptions = _ref4.selectOptions,
				cellIndex = _ref4.cellIndex,
				cellEdit = _ref4.cellEdit,
				cancelEdit = _ref4.cancelEdit;

			var widget = this.props.instance.widget;
			if (!widget.selectable && !widget.cellEditable) return;
			var newState = {};

			if (cellEdit != null && cellEdit != this.state.cellEdit) {
				newState.cellEdit = cellEdit;
				if (cellEdit && !widget.row.line1.columns[this.state.cursorCellIndex].editor) newState.cellEdit = false;
			}

			if (cellIndex != null && cellIndex != this.state.cursorCellIndex) {
				newState.cursorCellIndex = cellIndex;
				newState.cellEdit = false;
			}

			if (widget.focused) focused = true;

			if (focused != null && this.state.focused != focused) {
				newState.focused = focused;
				newState.cellEdit = false;
			}

			if (index != this.state.cursor) {
				newState.cursor = index;
				newState.cellEdit = false;
			}

			if (select) {
				var start = selectRange && this.state.selectionStart >= 0 ? this.state.selectionStart : index;
				if (start < 0) start = index;
				this.selectRange(start, index, selectOptions);
				if (!selectRange) newState.selectionStart = index;
			}

			if (Object.keys(newState).length > 0) {
				var prevState = this.state;
				this.setState(newState, function() {
					var wasCellEditing = prevState.focused && prevState.cellEdit;

					if (!_this8.state.cellEdit && wasCellEditing) {
						FocusManager.focus(_this8.dom.scroller);

						var record = _this8.getRecordAt(prevState.cursor);

						if ((!_this8.cellEditorValid || cancelEdit) && _this8.cellEditUndoData)
							record.store.set(widget.recordName, _this8.cellEditUndoData);
						else {
							if (widget.onCellEdited && record.data != _this8.cellEditUndoData)
								_this8.props.instance.invoke(
									"onCellEdited",
									{
										column: widget.row.line1.columns[prevState.cursorCellIndex],
										newData: record.data,
										oldData: _this8.cellEditUndoData,
										field: widget.row.line1.columns[prevState.cursorCellIndex].field
									},
									record
								);
						}
					}

					if (_this8.state.cellEdit && !wasCellEditing)
						_this8.cellEditUndoData = _this8.getRecordAt(_this8.state.cursor).data;

					if (scrollIntoView) {
						var _start = !widget.buffered ? 0 : _this8.syncBuffering ? _this8.start : _this8.state.start;

						var item = _this8.dom.table.children[index + 1 - _start];
						if (widget.cellEditable && _this8.state.cursorCellIndex >= 0 && item)
							item = item.firstChild.children[_this8.state.cursorCellIndex];
						if (item) scrollElementIntoView(item, true, widget.cellEditable);
					}
				});
			}
		};

		_proto2.showCursor = function showCursor(focused) {
			var _this$props$instance = this.props.instance,
				records = _this$props$instance.records,
				isSelected = _this$props$instance.isSelected;
			var cursor = this.state.cursor;

			if (cursor == -1) {
				if (records) {
					cursor = records.findIndex(function(x) {
						return isSelected(x.data, x.index);
					}); //if there are no selected records, find the first data record (skip group header)

					if (cursor == -1)
						cursor = records.findIndex(function(x) {
							return x.type == "data";
						});
				} else cursor = 0;
			}

			this.moveCursor(cursor, {
				focused: true,
				scrollIntoView: true
			});
		};

		_proto2.onFocus = function onFocus() {
			var _this9 = this;

			FocusManager.nudge(); //focus moved within the grid

			if (this.state.focused) return;
			var widget = this.props.instance.widget; //the cursor will be set if focus in originating from a mouse event

			setTimeout(function() {
				_this9.showCursor(true);
			}, 0);

			if (!widget.focused) {
				if (this.dom.scroller) {
					//if an inner element is focused first (autoFocus), this.dom.scroller might be undefined
					oneFocusOut(this, this.dom.scroller, function() {
						_this9.moveCursor(-1, {
							focused: false
						});
					});
				}
			}

			this.setState({
				focused: true
			});
		};

		_proto2.onBlur = function onBlur() {
			FocusManager.nudge();
		};

		_proto2.selectRange = function selectRange(from, to, options) {
			var _this$props5 = this.props,
				instance = _this$props5.instance,
				data = _this$props5.data;
			var records = instance.records,
				widget = instance.widget;

			if (from > to) {
				var tmp = from;
				from = to;
				to = tmp;
			}

			var selection = [],
				indexes = [];

			for (var cursor = from; cursor <= to; cursor++) {
				var record = void 0;
				if (records) record = records[cursor];
				else {
					var offset = widget.infinite ? data.offset : 0;
					var r = data.records[cursor - offset];
					if (r) record = widget.mapRecord(null, instance, r, cursor - offset);
				}

				if (record) {
					selection.push(record.data);
					indexes.push(record.index);
				}
			}

			widget.selection.selectMultiple(instance.store, selection, indexes, options);
		};

		_proto2.getRecordAt = function getRecordAt(cursor) {
			var _this$props6 = this.props,
				instance = _this$props6.instance,
				data = _this$props6.data;
			var records = instance.records,
				widget = instance.widget;
			if (records) return records[cursor];
			var offset = widget.infinite ? data.offset : 0;
			var r = data.records[cursor - offset];
			if (r) return widget.mapRecord(null, instance, r, cursor - offset);
			return null;
		};

		_proto2.getRecordInstanceAt = function getRecordInstanceAt(cursor) {
			var record = this.getRecordAt(cursor);
			if (!record) return null;
			var instance = this.props.instance;
			if (instance.recordInstanceCache)
				return instance.recordInstanceCache.getChild(instance.widget.row, record.store, record.key); //different signature

			return instance.getChild(instance.widget.row, record.key, record.store);
		};

		_proto2.handleKeyDown = function handleKeyDown(e) {
			var _this$props7 = this.props,
				instance = _this$props7.instance,
				data = _this$props7.data;
			var widget = instance.widget;
			if (widget.onKeyDown && instance.invoke("onKeyDown", e, instance) === false) return;
			var recordInstance = this.getRecordInstanceAt(this.state.cursor);
			if (recordInstance && widget.onRowKeyDown) instance.invoke("onRowKeyDown", e, recordInstance);

			switch (e.keyCode) {
				case KeyCode.enter:
					this.moveCursor(this.state.cursor, {
						select: true,
						selectOptions: {
							toggle: e.ctrlKey
						},
						selectRange: e.shiftKey,
						cellEdit: widget.cellEditable && !this.state.cellEdit,
						focused: true
					});
					e.stopPropagation();
					e.preventDefault();
					break;

				case KeyCode.esc:
					if (this.state.cellEdit) {
						this.moveCursor(this.state.cursor, {
							cellEdit: false,
							focused: true,
							cancelEdit: true
						});
						e.stopPropagation();
						e.preventDefault();
					}

					break;

				case KeyCode.down:
					if (this.state.cursor + 1 < data.totalRecordCount) {
						this.moveCursor(this.state.cursor + 1, {
							focused: true,
							scrollIntoView: true,
							select: e.shiftKey,
							selectRange: true
						});
						e.stopPropagation();
						e.preventDefault();
					}

					break;

				case KeyCode.up:
					if (this.state.cursor > 0) {
						this.moveCursor(this.state.cursor - 1, {
							focused: true,
							scrollIntoView: true,
							select: e.shiftKey,
							selectRange: true
						});
						e.stopPropagation();
						e.preventDefault();
					}

					break;

				case KeyCode.right:
					if (this.state.cursorCellIndex + 1 < widget.row.line1.columns.length) {
						this.moveCursor(this.state.cursor, {
							focused: true,
							cellIndex: this.state.cursorCellIndex + 1,
							scrollIntoView: true
						});
						e.stopPropagation();
						e.preventDefault();
					}

					break;

				case KeyCode.left:
					if (this.state.cursorCellIndex > 0) {
						this.moveCursor(this.state.cursor, {
							focused: true,
							cellIndex: this.state.cursorCellIndex - 1,
							scrollIntoView: true
						});
						e.stopPropagation();
						e.preventDefault();
					}

					break;
			}
		};

		_proto2.beginDragDrop = function beginDragDrop(e, record) {
			var _this10 = this;

			var _this$props8 = this.props,
				instance = _this$props8.instance,
				data = _this$props8.data;
			var widget = instance.widget,
				store = instance.store,
				isSelected = instance.isSelected;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var selected = instance.records.filter(function(record) {
				return isSelected(record.data, record.index);
			});
			if (selected.length == 0) selected = [record];
			var contents = selected.map(function(record, i) {
				return VDOM$2.createElement(
					"tbody",
					{
						key: i,
						className: CSS.element(baseClass, "data", {
							selected: !widget.selection.isDummy
						})
					},
					record.vdom.content.map(function(_ref5) {
						var key = _ref5.key,
							data = _ref5.data,
							content = _ref5.content;
						return VDOM$2.createElement(
							"tr",
							{
								key: key,
								className: data.classNames,
								style: data.style
							},
							content.map(function(_ref6) {
								var key = _ref6.key,
									data = _ref6.data,
									content = _ref6.content;
								return VDOM$2.createElement(
									"td",
									{
										key: key,
										className: data.classNames,
										style: data.style,
										colSpan: data.colSpan,
										rowSpan: data.rowSpan
									},
									content
								);
							})
						);
					})
				);
			});
			initiateDragDrop(
				e,
				{
					sourceEl: closest(e.currentTarget, function(a) {
						return a.tagName == "TBODY";
					}),
					source: {
						data: data.dragSource.data,
						store: store,
						record: record,
						records: selected
					},
					clone: {
						store: record.store,
						matchCursorOffset: true,
						matchWidth: true,
						widget: function widget() {
							return VDOM$2.createElement(
								"div",
								{
									className: data.classNames
								},
								VDOM$2.createElement("table", null, contents)
							);
						}
					}
				},
				function() {
					_this10.setState({
						dragged: false
					});
				}
			);
			this.setState({
				dragged: record
			});
		};

		return GridComponent;
	})(VDOM$2.Component);

var GridColumnHeaderLine =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(GridColumnHeaderLine, _PureContainer);

		function GridColumnHeaderLine() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto3 = GridColumnHeaderLine.prototype;

		_proto3.declareData = function declareData() {
			var _PureContainer$protot;

			return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						showHeader: undefined
					}
				])
			);
		};

		_proto3.init = function init() {
			this.items = Widget.create(GridColumnHeader, this.columns || []);
			this.visible = this.showHeader;
			this.style = this.headerStyle;
			this.className = this.headerClass;
			this.class = null;

			_PureContainer.prototype.init.call(this);
		};

		_proto3.render = function render(context, instance, key) {
			var data = instance.data;
			return VDOM$2.createElement(
				"tr",
				{
					key: key,
					className: data.classNames,
					style: data.style
				},
				this.renderChildren(context, instance)
			);
		};

		return GridColumnHeaderLine;
	})(PureContainer);

GridColumnHeaderLine.prototype.isPureContainer = false;
GridColumnHeaderLine.prototype.styled = true;
GridColumnHeaderLine.prototype.showHeader = true;
GridColumnHeaderLine.autoInit = true;

var GridColumnHeader =
	/*#__PURE__*/
	(function(_Widget2) {
		_inheritsLoose(GridColumnHeader, _Widget2);

		function GridColumnHeader() {
			return _Widget2.apply(this, arguments) || this;
		}

		var _proto4 = GridColumnHeader.prototype;

		_proto4.declareData = function declareData() {
			var _Widget2$prototype$de;

			return (_Widget2$prototype$de = _Widget2.prototype.declareData).call.apply(
				_Widget2$prototype$de,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						format: undefined
					}
				])
			);
		};

		_proto4.init = function init() {
			delete this.style;
			delete this.className;
			delete this.class;
			if (this.header) this.header1 = this.header;
			if (!this.header1 && this.sortable)
				this.header1 = {
					text: ""
				};
			if (this.header1 && isSelector(this.header1))
				this.header1 = {
					text: this.header1
				};
			if (this.header2 && isSelector(this.header2))
				this.header2 = {
					text: this.header2
				};
			if (this.header3 && isSelector(this.header3))
				this.header3 = {
					text: this.header3
				};
			if (!this.aggregateField && this.field) this.aggregateField = this.field;
			if (!this.aggregateAlias) this.aggregateAlias = this.aggregateField;
			if (this.footer && isSelector(this.footer))
				this.footer = {
					value: this.footer,
					pad: this.pad,
					format: this.format
				};
			if (this.footer) this.footer.value = getSelector(this.footer.value);

			_Widget2.prototype.init.call(this);
		};

		_proto4.initComponents = function initComponents() {
			return _Widget2.prototype.initComponents.call(this, {
				header1: this.header1 && GridColumnHeaderCell.create(this.header1),
				header2: this.header2 && GridColumnHeaderCell.create(this.header2),
				header3: this.header3 && GridColumnHeaderCell.create(this.header3)
			});
		};

		_proto4.render = function render() {
			return null;
		};

		return GridColumnHeader;
	})(Widget);

GridColumnHeader.autoInit = true;

var GridColumnHeaderCell =
	/*#__PURE__*/
	(function(_PureContainer2) {
		_inheritsLoose(GridColumnHeaderCell, _PureContainer2);

		function GridColumnHeaderCell() {
			return _PureContainer2.apply(this, arguments) || this;
		}

		var _proto5 = GridColumnHeaderCell.prototype;

		_proto5.declareData = function declareData() {
			var _PureContainer2$proto;

			return (_PureContainer2$proto = _PureContainer2.prototype.declareData).call.apply(
				_PureContainer2$proto,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						text: undefined,
						colSpan: undefined,
						rowSpan: undefined
					}
				])
			);
		};

		_proto5.initComponents = function initComponents() {
			var _PureContainer2$proto2;

			return (_PureContainer2$proto2 = _PureContainer2.prototype.initComponents).call.apply(
				_PureContainer2$proto2,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						tool: this.tool && Widget.create(this.tool)
					}
				])
			);
		};

		_proto5.render = function render(context, instance, key) {
			var data = instance.data;
			return data.text || _PureContainer2.prototype.render.call(this, context, instance, key);
		};

		return GridColumnHeaderCell;
	})(PureContainer);

GridColumnHeaderCell.prototype.colSpan = 1;
GridColumnHeaderCell.prototype.rowSpan = 1;
GridColumnHeaderCell.prototype.allowSorting = true;
GridColumnHeaderCell.prototype.styled = true;

function initGrouping(grouping) {
	grouping.forEach(function(g) {
		if (g.caption) g.caption = getSelector(g.caption);
	});
}

function copyCellWidths(srcTableBody, dstTableBody) {
	if (!srcTableBody || !dstTableBody) return false;
	var changed = false;

	for (var r = 0; r < srcTableBody.children.length; r++) {
		var sr = srcTableBody.children[r];
		var dr = dstTableBody.children[r];

		for (var c = 0; c < sr.children.length; c++) {
			var dc = dr.children[c];
			var ws = sr.children[c].offsetWidth + "px";
			if (!changed && dc.style.width != ws) changed = true;
			dc.style.width = dc.style.minWidth = dc.style.maxWidth = ws;
		}
	}

	return changed;
}

var TreeNode =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(TreeNode, _Container);

		function TreeNode() {
			return _Container.apply(this, arguments) || this;
		}

		var _proto = TreeNode.prototype;

		_proto.init = function init() {
			if (this.itemIcon) this.leafIcon = this.itemIcon;

			_Container.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Container$prototype$;

			(_Container$prototype$ = _Container.prototype.declareData).call.apply(
				_Container$prototype$,
				[
					this,
					{
						level: undefined,
						expanded: undefined,
						leaf: undefined,
						text: undefined,
						loading: undefined,
						icon: undefined,
						leafIcon: undefined,
						openFolderIcon: undefined,
						folderIcon: undefined,
						hideArrow: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			var data = instance.data;
			data.stateMods = {
				expanded: data.expanded,
				loading: data.loading,
				leaf: data.leaf,
				folder: !data.leaf,
				icon: !this.hideIcon
			};
			data.stateMods["level-" + data.level] = true;

			_Container.prototype.prepareData.call(this, context, instance);
		};

		_proto.render = function render(context, instance, key) {
			var _this = this;

			var data = instance.data,
				widget = instance.widget;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			var icon = data.icon;

			if (!data.icon) {
				if (data.leaf) icon = data.leafIcon;
				else {
					if (data.loading) icon = this.loadingIcon;
					else if (data.expanded) icon = data.openFolderIcon || data.folderIcon;
					else icon = data.folderIcon;
				}
			}

			var arrowIcon = this.arrowIcon;
			if (this.hideIcon && data.loading) arrowIcon = this.loadingIcon;
			return VDOM$2.createElement(
				"div",
				{
					key: key,
					className: data.classNames,
					style: data.style
				},
				VDOM$2.createElement(
					"div",
					{
						className: CSS.element(baseClass, "handle"),
						onClick: function onClick(e) {
							return _this.toggle(e, instance);
						},
						onMouseDown: stopPropagation
					},
					!data.leaf &&
						!data.hideArrow &&
						Icon.render(arrowIcon, {
							className: CSS.element(baseClass, "arrow")
						}),
					!this.hideIcon &&
						Icon.render(icon, {
							className: CSS.element(baseClass, "icon")
						})
				),
				VDOM$2.createElement("div", null, data.text || this.renderChildren(context, instance))
			);
		};

		_proto.toggle = function toggle(e, instance) {
			var data = instance.data;
			if (!data.leaf) instance.set("expanded", !data.expanded);
			e.preventDefault();
			e.stopPropagation();
		};

		return TreeNode;
	})(Container);
TreeNode.prototype.baseClass = "treenode";
TreeNode.prototype.itemIcon = "file";
TreeNode.prototype.loadingIcon = "loading";
TreeNode.prototype.folderIcon = "folder";
TreeNode.prototype.openFolderIcon = "folder-open";
TreeNode.prototype.arrowIcon = "drop-down";
TreeNode.prototype.styled = true;
TreeNode.prototype.hideIcon = false;
Widget.alias("treenode", TreeNode);

var Pagination =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(Pagination, _Widget);

		function Pagination() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = Pagination.prototype;

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[
					this,
					{
						page: undefined,
						length: undefined,
						pageCount: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.render = function render(context, instance, key) {
			var _this = this;

			var data = instance.data,
				widget = instance.widget;
			var page = data.page,
				pageCount = data.pageCount,
				length = data.length;
			var CSS = widget.CSS,
				baseClass = widget.baseClass;
			if (!pageCount) pageCount = 1;
			var minPage = Math.max(1, page - Math.floor(length / 2));
			var maxPage = minPage + length - 1;

			if (maxPage > pageCount) {
				maxPage = Math.max(pageCount, length);
				minPage = maxPage - length + 1;
			}

			var nextPageIcon = VDOM$2.createElement(ForwardIcon, {
				className: CSS.element(baseClass, "icon-next-page")
			});
			var prevPageIcon = VDOM$2.createElement(ForwardIcon, {
				className: CSS.element(baseClass, "icon-prev-page")
			});
			var pageBtns = [];

			var _loop = function _loop(p) {
				pageBtns.push(
					VDOM$2.createElement(
						"li",
						{
							key: p < minPage ? "-1" : p > maxPage ? "-2" : p,
							className: CSS.element(baseClass, "page", {
								active: page == p,
								disabled:
									(p <= maxPage && p > pageCount) || (p < minPage && page == 1) || (p > maxPage && page + 1 > pageCount)
							}),
							onMouseDown: function onMouseDown(e) {
								e.stopPropagation();
								preventFocusOnTouch(e);
							},
							onClick: function onClick(e) {
								_this.setPage(e, instance, p < minPage ? page - 1 : p > maxPage ? page + 1 : p);
							}
						},
						p < minPage ? prevPageIcon : p > maxPage ? nextPageIcon : p
					)
				);
			};

			for (var p = minPage - 1; p <= maxPage + 1; p++) {
				_loop(p);
			}

			return VDOM$2.createElement(
				"ul",
				{
					key: key,
					className: data.classNames,
					style: data.style,
					tabIndex: 0,
					onKeyDown: function onKeyDown(e) {
						_this.onKeyDown(e, instance);
					}
				},
				pageBtns
			);
		};

		_proto.onKeyDown = function onKeyDown(e, instance) {
			var data = instance.data;

			switch (e.keyCode) {
				case KeyCode.left:
					this.setPage(e, instance, data.page - 1);
					break;

				case KeyCode.right:
					this.setPage(e, instance, data.page + 1);
					break;
			}
		};

		_proto.setPage = function setPage(e, instance, page) {
			e.preventDefault();
			e.stopPropagation();
			var data = instance.data;
			var pageCount = data.pageCount;
			if (page <= pageCount && page > 0) instance.set("page", page);
		};

		return Pagination;
	})(Widget);
Pagination.prototype.baseClass = "pagination";
Pagination.prototype.length = 5;
Pagination.prototype.styled = true;
Widget.alias("pagination", Pagination);

var TreeAdapter =
	/*#__PURE__*/
	(function(_ArrayAdapter) {
		_inheritsLoose(TreeAdapter, _ArrayAdapter);

		function TreeAdapter() {
			return _ArrayAdapter.apply(this, arguments) || this;
		}

		var _proto = TreeAdapter.prototype;

		_proto.mapRecords = function mapRecords(context, instance, data, parentStore, recordsBinding) {
			var nodes = _ArrayAdapter.prototype.mapRecords.call(this, context, instance, data, parentStore, recordsBinding);

			var result = [];
			this.processList(context, instance, 0, "", nodes, result);
			return result;
		};

		_proto.processList = function processList(context, instance, level, parentKey, nodes, result) {
			var _this = this;

			var nonLeafs = [],
				leafs = [];
			nodes.forEach(function(record) {
				record.key = parentKey + record.key;

				_this.processNode(context, instance, level, record.data.$leaf ? leafs : nonLeafs, record);
			});
			result.push.apply(result, nonLeafs.concat(leafs));
		};

		_proto.processNode = function processNode(context, instance, level, result, record) {
			var _this2 = this;

			result.push(record);
			var data = record.data,
				store = record.store;
			data.$level = level;

			if (!data[this.leafField]) {
				if (data[this.expandedField]) {
					if (data[this.childrenField]) {
						var childNodes = _ArrayAdapter.prototype.mapRecords.call(
							this,
							context,
							instance,
							data[this.childrenField],
							store,
							Binding.get(this.recordName + "." + this.childrenField)
						);

						this.processList(context, instance, level + 1, record.key + ":", childNodes, result);
					} else if (!data[this.loadedField]) {
						if (this.load) {
							store.set(this.recordName + "." + this.loadingField, true);
							var response = this.load(context, instance, data);
							Promise.resolve(response)
								.then(function(children) {
									store.set(_this2.recordName + "." + _this2.childrenField, children);
									store.set(_this2.recordName + "." + _this2.loadedField, true);
									store.set(_this2.recordName + "." + _this2.loadingField, false);
								})
								.catch(function(response) {
									if (_this2.onLoadError) _this2.onLoadError(response);
								});
						}
					}
				} else data[this.expandedField] = false;
			}
		};

		_proto.sort = function sort(sorters) {
			if (this.foldersFirst) {
				if (!sorters || !isArray(sorters)) sorters = [];
				sorters = [
					{
						field: this.leafField,
						direction: "ASC"
					}
				].concat(sorters);
			}

			_ArrayAdapter.prototype.sort.call(this, sorters);
		};

		return TreeAdapter;
	})(ArrayAdapter);
TreeAdapter.prototype.childrenField = "$children";
TreeAdapter.prototype.expandedField = "$expanded";
TreeAdapter.prototype.leafField = "$leaf";
TreeAdapter.prototype.loadingField = "$loading";
TreeAdapter.prototype.loadedField = "$loaded";
TreeAdapter.prototype.foldersFirst = true;
TreeAdapter.prototype.isTreeAdapter = true;

var DragSource =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(DragSource, _Container);

		function DragSource() {
			return _Container.apply(this, arguments) || this;
		}

		var _proto = DragSource.prototype;

		_proto.init = function init() {
			this.cloneStyle = parseStyle(this.cloneStyle);

			_Container.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Container$prototype$;

			(_Container$prototype$ = _Container.prototype.declareData).call.apply(
				_Container$prototype$,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						id: undefined,
						data: {
							structured: true
						},
						cloneStyle: {
							structured: true
						},
						cloneClass: {
							structured: true
						}
					}
				])
			);
		};

		_proto.explore = function explore(context, instance) {
			context.push("dragHandles", (instance.dragHandles = []));

			_Container.prototype.explore.call(this, context, instance);
		};

		_proto.exploreCleanup = function exploreCleanup(context, instance) {
			context.pop("dragHandles");
		};

		_proto.render = function render(context, instance, key) {
			return VDOM$2.createElement(
				DragSourceComponent,
				{
					key: key,
					instance: instance,
					handled: this.handled || instance.dragHandles.length > 0
				},
				this.renderChildren(context, instance)
			);
		};

		return DragSource;
	})(Container);
DragSource.prototype.styled = true;
DragSource.prototype.baseClass = "dragsource";
DragSource.prototype.hideOnDrag = false;
DragSource.prototype.handled = false;
Widget.alias("dragsource", DragSource);

var DragSourceComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(DragSourceComponent, _VDOM$Component);

		function DragSourceComponent(props) {
			var _context;

			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			_this.state = {
				dragged: false
			};
			_this.beginDragDrop = (_context = _this).beginDragDrop.bind(_context);
			_this.onMouseMove = (_context = _this).onMouseMove.bind(_context);
			_this.onMouseDown = (_context = _this).onMouseDown.bind(_context);

			_this.setRef = function(el) {
				_this.el = el;
			};

			return _this;
		}

		var _proto2 = DragSourceComponent.prototype;

		_proto2.render = function render() {
			var _this$props = this.props,
				instance = _this$props.instance,
				children = _this$props.children,
				handled = _this$props.handled;
			var data = instance.data,
				widget = instance.widget;
			var CSS = widget.CSS;
			if (this.state.dragged && widget.hideOnDrag) return null;
			var classes = [
				data.classNames,
				CSS.state({
					dragged: this.state.dragged,
					draggable: !handled
				})
			];

			var eventHandlers = _objectSpread({}, instance.getJsxEventProps(), {
				onTouchStart: this.onMouseDown,
				onMouseDown: this.onMouseDown,
				onTouchMove: this.onMouseMove,
				onMouseMove: this.onMouseMove,
				onTouchEnd: ddMouseUp,
				onMouseUp: ddMouseUp
			});

			delete eventHandlers.onDragStart;
			delete eventHandlers.onDragEnd;
			return VDOM$2.createElement(
				"div",
				_extends(
					{
						id: data.id,
						ref: this.setRef,
						className: CSS.expand(classes),
						style: data.style
					},
					eventHandlers
				),
				children
			);
		};

		_proto2.onMouseDown = function onMouseDown(e) {
			ddMouseDown(e);

			if (isDragHandleEvent(e) || !this.props.handled) {
				preventFocus(e); //disables text selection in Firefox

				e.stopPropagation();
			}
		};

		_proto2.onMouseMove = function onMouseMove(e) {
			if (ddDetect(e)) {
				if (isDragHandleEvent(e) || !this.props.handled) {
					this.beginDragDrop(e);
				}
			}
		};

		_proto2.beginDragDrop = function beginDragDrop(e) {
			var _this2 = this;

			var instance = this.props.instance;
			var data = instance.data,
				widget = instance.widget,
				store = instance.store;
			if (widget.onDragStart && instance.invoke("onDragStart", e, instance) === false) return;
			initiateDragDrop(
				e,
				{
					sourceEl: this.el,
					source: {
						store: store,
						data: data.data
					},
					clone: {
						widget: widget.clone || widget,
						store: store,
						class: data.cloneClass,
						style: data.cloneStyle,
						cloneContent: !widget.clone,
						matchSize: !widget.clone,
						matchCursorOffset: !widget.clone
					}
				},
				function(e) {
					_this2.setState({
						dragged: false
					});

					if (widget.onDragEnd) instance.invoke("onDragEnd", e, instance);
				}
			);
			this.setState({
				dragged: true
			});
		};

		return DragSourceComponent;
	})(VDOM$2.Component);

var DragHandle =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(DragHandle, _Container);

		function DragHandle() {
			return _Container.apply(this, arguments) || this;
		}

		var _proto = DragHandle.prototype;

		_proto.explore = function explore(context, instance) {
			if (isArray(context.dragHandles)) context.dragHandles.push(instance);

			_Container.prototype.explore.call(this, context, instance);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			return VDOM$2.createElement(
				"div",
				{
					key: key,
					className: data.classNames,
					style: data.style,
					onTouchStart: ddHandle,
					onMouseDown: ddHandle,
					onTouchMove: ddHandle,
					onMouseMove: ddHandle,
					onTouchEnd: ddHandle,
					onMouseUp: ddHandle
				},
				this.renderChildren(context, instance)
			);
		};

		return DragHandle;
	})(Container);
DragHandle.prototype.styled = true;
DragHandle.prototype.baseClass = "draghandle";
Widget.alias("draghandle", DragHandle);

var DropZone =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(DropZone, _Container);

		function DropZone() {
			return _Container.apply(this, arguments) || this;
		}

		var _proto = DropZone.prototype;

		_proto.init = function init() {
			this.overStyle = parseStyle(this.overStyle);
			this.nearStyle = parseStyle(this.nearStyle);
			this.farStyle = parseStyle(this.farStyle);

			if (isNumber(this.inflate)) {
				this.hinflate = this.inflate;
				this.vinflate = this.inflate;
			}

			_Container.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Container$prototype$;

			return (_Container$prototype$ = _Container.prototype.declareData).call.apply(
				_Container$prototype$,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						overClass: {
							structured: true
						},
						nearClass: {
							structured: true
						},
						farClass: {
							structured: true
						},
						overStyle: {
							structured: true
						},
						nearStyle: {
							structured: true
						},
						farStyle: {
							structured: true
						},
						data: {
							structured: true
						}
					}
				])
			);
		};

		_proto.render = function render(context, instance, key) {
			return VDOM$2.createElement(
				DropZoneComponent,
				{
					key: key,
					instance: instance
				},
				this.renderChildren(context, instance)
			);
		};

		return DropZone;
	})(Container);
DropZone.prototype.styled = true;
DropZone.prototype.nearDistance = 0;
DropZone.prototype.hinflate = 0;
DropZone.prototype.vinflate = 0;
DropZone.prototype.baseClass = "dropzone";
Widget.alias("dropzone", DropZone);

var DropZoneComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(DropZoneComponent, _VDOM$Component);

		function DropZoneComponent(props) {
			var _this;

			_this = _VDOM$Component.call(this, props) || this;
			_this.state = {
				state: false
			};
			return _this;
		}

		var _proto2 = DropZoneComponent.prototype;

		_proto2.render = function render() {
			var _this2 = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				children = _this$props.children;
			var data = instance.data,
				widget = instance.widget;
			var CSS = widget.CSS;
			var classes = [data.classNames, CSS.state(this.state.state)];
			var stateStyle;

			switch (this.state.state) {
				case "over":
					classes.push(data.overClass);
					stateStyle = parseStyle(data.overStyle);
					break;

				case "near":
					classes.push(data.nearClass);
					stateStyle = parseStyle(data.nearStyle);
					break;

				case "far":
					classes.push(data.farClass);
					stateStyle = parseStyle(data.farStyle);
					break;
			}

			return VDOM$2.createElement(
				"div",
				{
					className: CSS.expand(classes),
					style: _objectSpread({}, data.style, this.state.style, stateStyle),
					ref: function ref(el) {
						_this2.el = el;
					}
				},
				children
			);
		};

		_proto2.componentDidMount = function componentDidMount() {
			this.unregister = registerDropZone(this);
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			this.unregister();
		};

		_proto2.onDropTest = function onDropTest(e) {
			var instance = this.props.instance;
			var widget = instance.widget;
			return !widget.onDropTest || instance.invoke("onDropTest", e, instance);
		};

		_proto2.onDragStart = function onDragStart(e) {
			this.setState({
				state: "far"
			});
		};

		_proto2.onDragNear = function onDragNear(e) {
			this.setState({
				state: "near"
			});
		};

		_proto2.onDragAway = function onDragAway(e) {
			this.setState({
				state: "far"
			});
		};

		_proto2.onDragLeave = function onDragLeave(e) {
			var nearDistance = this.props.instance.widget.nearDistance;
			this.setState({
				state: nearDistance ? "near" : "far",
				style: null
			});
		};

		_proto2.onDragMeasure = function onDragMeasure(e) {
			var rect = getTopLevelBoundingClientRect(this.el);
			var instance = this.props.instance;
			var widget = instance.widget;
			var _e$cursor = e.cursor,
				clientX = _e$cursor.clientX,
				clientY = _e$cursor.clientY;
			var distance =
				Math.max(0, rect.left - clientX, clientX - rect.right) + Math.max(0, rect.top - clientY, clientY - rect.bottom);

			if (widget.hinflate > 0) {
				rect.left -= widget.hinflate;
				rect.right += widget.hinflate;
			}

			if (widget.vinflate > 0) {
				rect.top -= widget.vinflate;
				rect.bottom += widget.vinflate;
			}

			var nearDistance = widget.nearDistance;
			var over = rect.left <= clientX && clientX < rect.right && rect.top <= clientY && clientY < rect.bottom;
			return {
				over: over && distance,
				near: nearDistance && (over || distance < nearDistance)
			};
		};

		_proto2.onDragEnter = function onDragEnter(e) {
			var instance = this.props.instance;
			var widget = instance.widget;
			var style = {};
			if (widget.matchWidth) style.width = e.source.width + "px";
			if (widget.matchHeight) style.height = e.source.height + "px";
			if (widget.matchMargin) style.margin = e.source.margin.join(" ");
			if (this.state != "over")
				this.setState({
					state: "over",
					style: style
				});
		};

		_proto2.onDragOver = function onDragOver(e) {};

		_proto2.onGetHScrollParent = function onGetHScrollParent() {
			return findScrollableParent(this.el, true);
		};

		_proto2.onGetVScrollParent = function onGetVScrollParent() {
			return findScrollableParent(this.el);
		};

		_proto2.onDrop = function onDrop(e) {
			var instance = this.props.instance;
			var widget = instance.widget;
			if (this.state.state == "over" && widget.onDrop) instance.invoke("onDrop", e, instance);
		};

		_proto2.onDragEnd = function onDragEnd(e) {
			this.setState({
				state: false,
				style: null
			});
		};

		return DropZoneComponent;
	})(VDOM$2.Component);

//http://stackoverflow.com/questions/36428283/arrow-function-eval-preprocessor
function expandFatArrows(code) {
	var arrowHeadRegex = RegExp(/(\((?:\w+,)*\w+\)|\(\)|\w+)[\r\t ]*=>\s*/);
	var arrowHeadMatch = arrowHeadRegex.exec(code);

	if (arrowHeadMatch) {
		//if no match return as it is
		var params = arrowHeadMatch[1];

		if (params.charAt(0) !== "(") {
			params = "(" + params + ")";
		}

		var index = arrowHeadMatch.index;
		var startCode = code.substring(0, index);
		var bodyAndNext = code.substring(index + arrowHeadMatch[0].length);
		var curlyCount = 0;
		var curlyPresent = false;
		var singleLineBodyEnd = 0;
		var bodyEnd = 0;

		for (var i = 0; i < bodyAndNext.length; i++) {
			var ch = bodyAndNext[i];

			if (ch === "{") {
				curlyPresent = true;
				curlyCount++;
			} else if (ch === "}") {
				curlyCount--;
			} else if (!curlyPresent) {
				//any character other than { or }
				singleLineBodyEnd = getSingeLineBodyEnd(bodyAndNext, i);
				break;
			}

			if (curlyPresent && curlyCount === 0) {
				bodyEnd = i;
				break;
			}
		}

		var body;

		if (curlyPresent) {
			if (curlyCount !== 0) {
				throw Error("Could not match curly braces for function at : " + index);
			}

			body = bodyAndNext.substring(0, bodyEnd + 1);
			var restCode = bodyAndNext.substring(bodyEnd + 1);
			var expandedFun = "(function " + params + body + ").bind(this)";
			code = startCode + expandedFun + restCode;
		} else {
			if (singleLineBodyEnd <= 0) {
				throw Error("could not get function body at : " + index);
			}

			body = bodyAndNext.substring(0, singleLineBodyEnd + 1);
			restCode = bodyAndNext.substring(singleLineBodyEnd + 1);
			expandedFun = "(function " + params + "{return " + body + "}).bind(this)";
			code = startCode + expandedFun + restCode;
		}

		return expandFatArrows(code); //recursive call
	}

	return code;
}

function getSingeLineBodyEnd(bodyCode, startI) {
	var braceCount = 0;
	var openingQuote = null;

	for (var i = startI; i < bodyCode.length; i++) {
		var ch = bodyCode[i];
		var lastCh = null;

		if (ch === '"' || ch === "'") {
			openingQuote = ch;
			i = skipQuotedString(bodyCode, openingQuote, i);
			ch = bodyCode[i];
		}

		if (i !== 0 && !bodyCode[i - 1].match(/[\t\r ]/)) {
			lastCh = bodyCode[i - 1];
		}

		if (ch === "{" || ch === "(") {
			braceCount++;
		} else if (ch === "}" || ch === ")") {
			braceCount--;
		}

		if (braceCount < 0 || (lastCh !== "." && ch === "\n")) {
			return i - 1;
		}
	}

	return bodyCode.length;
}

function skipQuotedString(bodyAndNext, openingQuote, i) {
	var matchFound = false; //matching quote

	var openingQuoteI = i;
	i++;

	for (; i < bodyAndNext.length; i++) {
		var ch = bodyAndNext[i];
		var lastCh = i !== 0 ? bodyAndNext[i - 1] : null;

		if (ch !== openingQuote || (ch === openingQuote && lastCh === "\\")) {
			continue; //skip quoted string
		} else if (ch === openingQuote) {
			//matched closing quote
			matchFound = false;
			break;
		}
	}

	if (matchFound) {
		throw new Error("Could not find closing quote for quote at : " + openingQuoteI);
	}

	return i;
}

function enableFatArrowExpansion() {
	plugFatArrowExpansion(expandFatArrows);
}

function enableAllInternalDependencies() {
	enableTooltips();
	enableMsgBoxAlerts();
	enableCultureSensitiveFormatting();
	enableFatArrowExpansion();
}

export {
	Widget,
	StaticText,
	Text,
	PureContainer,
	Content,
	ContentPlaceholder,
	ContentPlaceholderScope,
	ContentResolver,
	Rescope,
	Repeater,
	IsolatedScope,
	DetachedScope,
	Restate,
	DataProxy,
	cx,
	react,
	urlAttributes,
	HtmlElement,
	Button,
	DocumentTitle,
	List,
	Sandbox,
	CxCredit,
	Heading,
	Section,
	FlexBox,
	FlexRow,
	FlexCol,
	Icon,
	ProgressBar,
	Resizer,
	Overlay,
	OverlayComponent,
	Dropdown,
	tooltipMouseMove,
	tooltipMouseLeave,
	tooltipParentDidMount,
	tooltipParentWillReceiveProps,
	tooltipParentWillUnmount,
	wireTooltipOps,
	Tooltip,
	getTooltipInstance,
	enableTooltips,
	Window,
	MsgBox,
	enableMsgBoxAlerts,
	Toast,
	captureMouse,
	captureMouseOrTouch,
	getCursorPos,
	ContextMenu,
	openContextMenu,
	Route,
	RedirectRoute,
	Tab,
	Link,
	LinkButton,
	Menu,
	MenuItem,
	Submenu,
	Scroller,
	HScrollerComponent,
	HScroller,
	VScroller,
	Field,
	getFieldTooltip,
	autoFocus,
	TextField,
	Checkbox,
	Radio,
	Select,
	Option,
	Calendar,
	CalendarCmp,
	LookupField,
	NumberField,
	TextArea,
	LabeledContainer,
	ValidationError,
	ValidationGroup,
	FieldGroup,
	MonthPicker,
	MonthPickerComponent,
	ColorPicker,
	MonthField,
	ColorField,
	UploadButton,
	Slider,
	Switch,
	HelpText,
	Wheel,
	WheelComponent,
	DateTimePicker,
	DateTimeField,
	DateField,
	TimeField,
	Validator,
	DataAdapter,
	ArrayAdapter,
	GroupAdapter,
	TreeAdapter,
	Grid,
	TreeNode,
	Pagination,
	DragSource,
	DragHandle,
	DropZone,
	registerDropZone,
	initiateDragDrop,
	ddMouseDown,
	ddMouseUp,
	ddDetect,
	ddHandle,
	isDragHandleEvent,
	enableAllInternalDependencies
};
