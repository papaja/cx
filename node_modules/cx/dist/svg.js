import { VDOM } from "cx-react";

function isNumber(n) {
	return typeof n === "number";
}

function isArray(a) {
	return Array.isArray(a);
}

var Rect =
	/*#__PURE__*/
	(function() {
		function Rect(config) {
			Object.assign(this, config);
		}

		var _proto = Rect.prototype;

		_proto.width = function width() {
			return this.r - this.l;
		};

		_proto.height = function height() {
			return this.b - this.t;
		};

		_proto.valid = function valid() {
			return this.r > this.l && this.b > this.t;
		};

		_proto.makeValid = function makeValid() {
			return new Rect({
				l: Math.min(this.l, this.r),
				r: Math.max(this.l, this.r),
				t: Math.min(this.t, this.b),
				b: Math.max(this.t, this.b)
			});
		};

		_proto.isEqual = function isEqual(r) {
			if (!r || !r.isRect) return false;
			return r.l == this.l && r.r == this.r && r.t == this.t && r.b == this.b;
		};

		Rect.add = function add(a, b) {
			return new Rect({
				l: a.l + b.l,
				t: a.t + b.t,
				r: a.r + b.r,
				b: a.b + b.b
			});
		};

		Rect.multiply = function multiply(a, b) {
			return new Rect({
				l: a.l + (a.r - a.l) * b.l,
				r: a.l + (a.r - a.l) * b.r,
				t: a.t + (a.b - a.t) * b.t,
				b: a.t + (a.b - a.t) * b.b
			});
		};

		Rect.margin = function margin(r, m) {
			var mr = Rect.convertMargin(m);
			return Rect.add(r, mr);
		};

		Rect.convertMargin = function convertMargin(m) {
			if (!m) return new Rect();
			if (m.isRect) return m;
			if (isNumber(m))
				return new Rect({
					l: m,
					t: m,
					r: -m,
					b: -m
				});
			var m = Rect.convert(m);
			m.b = -m.b;
			m.r = -m.r;
			return m;
		};

		Rect.convert = function convert(r) {
			if (!r)
				return new Rect({
					l: 0,
					r: 0,
					t: 0,
					b: 0
				});
			if (r.isRect) return r;
			if (typeof r === "string") r = r.split(" ");

			if (isArray(r)) {
				return new Rect({
					t: parseFloat(r[0]),
					r: parseFloat(r[1]),
					b: parseFloat(r[2]),
					l: parseFloat(r[3])
				});
			}

			return new Rect(r);
		};

		return Rect;
	})();
Rect.prototype.isRect = true;
Rect.prototype.l = 0; //left;

Rect.prototype.r = 0; //right

Rect.prototype.t = 0; //top

Rect.prototype.b = 0; //bottom

function _defineProperty(obj, key, value) {
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value: value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}

	return obj;
}

function _objectSpread(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? arguments[i] : {};
		var ownKeys = Object.keys(source);

		if (typeof Object.getOwnPropertySymbols === "function") {
			ownKeys = ownKeys.concat(
				Object.getOwnPropertySymbols(source).filter(function(sym) {
					return Object.getOwnPropertyDescriptor(source, sym).enumerable;
				})
			);
		}

		ownKeys.forEach(function(key) {
			_defineProperty(target, key, source[key]);
		});
	}

	return target;
}

function _inheritsLoose(subClass, superClass) {
	subClass.prototype = Object.create(superClass.prototype);
	subClass.prototype.constructor = subClass;
	subClass.__proto__ = superClass;
}

function _setPrototypeOf(o, p) {
	_setPrototypeOf =
		Object.setPrototypeOf ||
		function _setPrototypeOf(o, p) {
			o.__proto__ = p;
			return o;
		};

	return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
	if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	if (Reflect.construct.sham) return false;
	if (typeof Proxy === "function") return true;

	try {
		Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
		return true;
	} catch (e) {
		return false;
	}
}

function _construct(Parent, args, Class) {
	if (isNativeReflectConstruct()) {
		_construct = Reflect.construct;
	} else {
		_construct = function _construct(Parent, args, Class) {
			var a = [null];
			a.push.apply(a, args);
			var Constructor = Function.bind.apply(Parent, a);
			var instance = new Constructor();
			if (Class) _setPrototypeOf(instance, Class.prototype);
			return instance;
		};
	}

	return _construct.apply(null, arguments);
}

function isString(s) {
	return typeof s === "string";
}

function isFunction(f) {
	return typeof f === "function";
}

var componentAlias = {};
var Component =
	/*#__PURE__*/
	(function() {
		function Component(config) {
			if (config && config.$props) {
				Object.assign(config, config.$props);
				delete config.$props;
			}

			Object.assign(this, config);
		}

		Component.alias = function alias(_alias, type) {
			var _this = this;

			if (type) {
				type.prototype.componentAlias = _alias;
				componentAlias[this.namespace + _alias] = type;
			} else //decorator usage
				return function(t) {
					_this.alias(_alias, t);

					return t;
				};
		};

		Component.create = function create(typeAlias, config, more) {
			var _this2 = this;

			if (!typeAlias) return this.factory(typeAlias, config, more);
			if (typeAlias.isComponent) return typeAlias;
			if (isComponentFactory(typeAlias)) return this.create(typeAlias.create(config));
			if (isArray(typeAlias))
				return typeAlias.map(function(c) {
					return _this2.create(c, config, more);
				});
			if (typeAlias.$type) return this.create(typeAlias.$type, typeAlias, config);
			if (typeAlias.type) return this.create(typeAlias.type, typeAlias, config);
			var cmpType, alias;
			if (typeAlias.isComponentType) cmpType = typeAlias;
			else if (isFunction(typeAlias)) {
				if (this.factory) return this.factory(typeAlias, config, more);
				throw new Error("Unsupported component type " + typeAlias + ".");
			} else if (isString(typeAlias)) {
				alias = this.namespace + typeAlias;
				cmpType = componentAlias[alias];

				if (!cmpType) {
					if (typeAlias && this.factory) return this.factory(typeAlias, config, more);
					throw new Error("Unknown component alias " + alias + ".");
				}
			} else if (typeof typeAlias == "object") {
				cmpType = typeAlias.type || typeAlias.$type;

				if (!cmpType) {
					cmpType = this;
					more = more ? Object.assign({}, config, more) : config;
					config = typeAlias;
				}
			}
			if (isArray(config))
				return config.map(function(cfg) {
					return _this2.create(cmpType, cfg, more);
				});
			var cfg = config;
			if (more) cfg = Object.assign({}, config, more);
			var cmp = new cmpType(cfg);
			if (cmpType.autoInit && cmp.init) cmp.init();
			return cmp;
		};

		return Component;
	})();
Component.prototype.isComponent = true;
Component.isComponentType = true;
Component.namespace = "";
Component.autoInit = false;

Component.factory = function(alias, config, more) {
	throw new Error("Unknown component alias " + alias + ".");
};
function isComponentFactory(factory) {
	return factory && factory.$isComponentFactory;
}

var cssHelperCache = {};
var CSSHelper =
	/*#__PURE__*/
	(function() {
		function CSSHelper() {}

		CSSHelper.get = function get(code) {
			var helper = cssHelperCache[code];
			if (!helper) throw new Error("Unknown CSS helper '" + code + "'.");
			return helper;
		};

		CSSHelper.register = function register(code, helper) {
			cssHelperCache[code] = helper;
		};

		CSSHelper.alias = function alias(code, helper) {
			cssHelperCache[code] = helper;
		};

		return CSSHelper;
	})();

function parseStyle(str) {
	if (typeof str != "string") return str;
	var style = {},
		parts = str.split(";");

	for (var i = 0; i < parts.length; i++) {
		var part = parts[i];
		var colonIndex = part.indexOf(":");
		if (colonIndex == -1) continue;
		var name = part.substring(0, colonIndex).trim();
		var value = part.substring(colonIndex + 1).trim();
		name = name
			.split("-")
			.map(function(p, i) {
				return i == 0 ? p : p[0].toUpperCase() + p.substring(1);
			})
			.join("");
		style[name] = value;
	}

	return style;
}

function push(list, item) {
	if (!item) return list;
	if (!list) list = [];
	list.push(item);
	return list;
}

function pushMore(list, itemArray) {
	if (!itemArray || itemArray.length == 0) return list;
	if (!list) list = [];
	list.push.apply(list, itemArray);
	return list;
}

function pushMap(list, itemArray, mapF) {
	return itemArray ? pushMore(list, itemArray.map(mapF)) : list;
}

function join(list) {
	return list ? list.join(" ") : null;
}

var CSS =
	/*#__PURE__*/
	(function() {
		function CSS() {}

		CSS.resolve = function resolve() {
			var list, type, arg, i, key;

			for (i = 0; i < arguments.length; i++) {
				arg = arguments[i];

				if (arg) {
					type = typeof arg;
					if (type == "string") list = push(list, arg);
					else if (type == "object") {
						if (isArray(arg)) list = pushMore(list, this.resolve.apply(this, arg));
						else
							for (key in arg) {
								if (arg[key]) list = push(list, key);
							}
					}
				}
			}

			return list;
		};

		CSS.block = function block(baseClass, styleModifiers, stateModifiers) {
			var _this = this;

			var list;
			if (baseClass) list = push(list, this.classPrefix + "b-" + baseClass);
			list = pushMap(list, this.resolve(styleModifiers), function(m) {
				return _this.classPrefix + "m-" + m;
			});
			list = pushMap(list, this.resolve(stateModifiers), function(m) {
				return _this.classPrefix + "s-" + m;
			});
			return join(list);
		};

		CSS.element = function element(baseClass, elementClass, stateModifiers) {
			var _this2 = this;

			var list;
			if (baseClass && elementClass) list = push(list, this.classPrefix + "e-" + baseClass + "-" + elementClass);
			list = pushMap(list, this.resolve(stateModifiers), function(m) {
				return _this2.classPrefix + "s-" + m;
			});
			return join(list);
		};

		CSS.state = function state(stateModifiers) {
			var _this3 = this;

			return join(
				pushMap(null, this.resolve(stateModifiers), function(m) {
					return _this3.classPrefix + "s-" + m;
				})
			);
		};

		CSS.expand = function expand() {
			return join(this.resolve.apply(this, arguments));
		};

		CSS.parseStyle = function parseStyle$$1(str) {
			return parseStyle(str);
		};

		return CSS;
	})();
CSS.classPrefix = "cx";
CSSHelper.alias("cx", CSS);

function isObject(o) {
	return o !== null && typeof o === "object";
}

var bindingCache = {};
var Binding =
	/*#__PURE__*/
	(function() {
		function Binding(path) {
			this.path = path;
			this.parts = path.split(".");
			var fstr = "return (x";
			var cpath = "x";

			for (var i = 0; i < this.parts.length; i++) {
				if (this.parts[i][0] >= "0" && this.parts[i][0] <= "9") cpath += "[" + this.parts[i] + "]";
				else cpath += "." + this.parts[i];
				if (i + 1 < this.parts.length) fstr += " && " + cpath;
				else fstr += " ? " + cpath + " : undefined";
			}

			fstr += ")";
			this.value = new Function("x", fstr);
		}

		var _proto = Binding.prototype;

		_proto.set = function set(state, value) {
			var cv = this.value(state);
			if (cv === value) return state;
			var ns = Object.assign({}, state);
			var o = ns;

			for (var i = 0; i < this.parts.length; i++) {
				var part = this.parts[i];
				var no = i == this.parts.length - 1 ? value : Object.assign({}, o[part]);
				o[part] = no;
				o = no;
			}

			return ns;
		};

		_proto.delete = function _delete(state) {
			var ns = Object.assign({}, state);
			var o = ns;
			var part;

			for (var i = 0; i < this.parts.length - 1; i++) {
				part = this.parts[i];
				var no = Object.assign({}, o[part]);
				o[part] = no;
				o = no;
			}

			part = this.parts[this.parts.length - 1];
			if (!o.hasOwnProperty(part)) return state;
			delete o[part];
			return ns;
		};

		Binding.get = function get(path) {
			if (isString(path)) {
				var b = bindingCache[path];
				if (b) return b;
				b = new Binding(path);
				bindingCache[path] = b;
				return b;
			}

			if (isObject(path) && isString(path.bind)) return this.get(path.bind);
			if (path instanceof Binding) return path;
			throw new Error("Invalid binding definition provided.");
		};

		return Binding;
	})();

function computable() {
	var _ref;

	if (arguments.length == 0)
		throw new Error("computable requires at least a compute function to be passed in arguments.");
	var compute = ((_ref = arguments.length - 1), _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref]);
	if (typeof compute != "function") throw new Error("Last argument to the computable function should be a function.");
	var inputs = [],
		a;

	for (var i = 0; i + 1 < arguments.length; i++) {
		a = i < 0 || arguments.length <= i ? undefined : arguments[i];
		if (isString(a)) inputs.push(Binding.get(a).value);
		else if (a.memoize) inputs.push(a.memoize());
		else if (isFunction(a)) inputs.push(a);
		else throw new Error("Invalid selector type '" + typeof a + "' received.");
	}

	function memoize(amnesia, warmupData) {
		var lastValue,
			lastArgs =
				warmupData &&
				inputs.map(function(s, i) {
					return s(warmupData);
				});
		return function(data) {
			var dirty = amnesia;

			if (!lastArgs) {
				lastArgs = Array.from({
					length: inputs.length
				});
				dirty = true;
			}

			for (var _i = 0; _i < inputs.length; _i++) {
				var v = inputs[_i](data);

				if (v !== lastArgs[_i]) dirty = true;
				lastArgs[_i] = v;
			}

			if (dirty) lastValue = compute.apply(null, lastArgs);
			return lastValue;
		};
	}

	var selector = memoize(true);
	selector.memoize = memoize;
	return selector;
}

var Console = {
	log: function log() {
		var _console;

		if (typeof window != "undefined" && window.console) (_console = console).log.apply(_console, arguments);
	},
	warn: function warn() {
		var _console2;

		if (typeof window != "undefined" && window.console) (_console2 = console).warn.apply(_console2, arguments);
	}
};

var activeFlags = {
	deprecated: true
};
function debug(flag) {
	if (process.env.NODE_ENV !== "production") {
		if (!activeFlags[flag]) return;
		Console.log.apply(Console, arguments);
	}
}

var globalCacheIdentifier = 1;
var GlobalCacheIdentifier =
	/*#__PURE__*/
	(function() {
		function GlobalCacheIdentifier() {}

		GlobalCacheIdentifier.get = function get() {
			return globalCacheIdentifier;
		};

		GlobalCacheIdentifier.change = function change() {
			globalCacheIdentifier++;
		};

		return GlobalCacheIdentifier;
	})();

function isUndefined(v) {
	return v === undefined;
}

var defaultFormatter = function defaultFormatter(v) {
	return v.toString();
};

var formatFactory = {
	string: function string() {
		return defaultFormatter;
	},
	wrap: function wrap(part0, prefix, suffix) {
		if (!prefix) prefix = "";
		if (!suffix) suffix = "";
		return function(value) {
			return prefix + value.toString() + suffix;
		};
	},
	fixed: function fixed(part0, digits) {
		return function(value) {
			return value.toFixed(digits);
		};
	},
	prefix: function prefix(part0, _prefix) {
		if (!_prefix) _prefix = "";
		return function(value) {
			return _prefix + value.toString();
		};
	},
	suffix: function suffix(part0, _suffix) {
		if (!_suffix) _suffix = "";
		return function(value) {
			return value.toString() + _suffix;
		};
	},
	uppercase: function uppercase() {
		return function(value) {
			return value.toString().toUpperCase();
		};
	},
	lowercase: function lowercase() {
		return function(value) {
			return value.toString().toLowerCase();
		};
	},
	urlencode: function urlencode() {
		return function(value) {
			return encodeURIComponent(value);
		};
	},
	number: function number(part0, minFractionDigits, maxFractionDigits) {
		var _resolveMinMaxFractio = resolveMinMaxFractionDigits(minFractionDigits, maxFractionDigits),
			minimumFractionDigits = _resolveMinMaxFractio.minimumFractionDigits,
			maximumFractionDigits = _resolveMinMaxFractio.maximumFractionDigits;

		var trimmable = maximumFractionDigits - minimumFractionDigits;

		if (trimmable > 0) {
			if (minimumFractionDigits == 0) ++trimmable;
			return function(value) {
				return trimFractionZeros(value.toFixed(maximumFractionDigits), trimmable);
			};
		}

		return function(value) {
			return value.toFixed(maximumFractionDigits);
		};
	},
	percentage: function percentage(part0, minFractionDigits, maxFractionDigits) {
		var numberFormatter = formatFactory.number(part0, minFractionDigits, maxFractionDigits);
		return function(value) {
			return numberFormatter(value * 100) + "%";
		};
	},
	percentageSign: function percentageSign(part0, minFractionDigits, maxFractionDigits) {
		var numberFormatter = formatFactory.number(part0, minFractionDigits, maxFractionDigits);
		return function(value) {
			return numberFormatter(value) + "%";
		};
	},
	date: function date() {
		return function(value) {
			var date = new Date(value);
			return date.getMonth() + 1 + "/" + date.getDate() + "/" + date.getFullYear();
		};
	},
	time: function time() {
		return function(value) {
			var date = new Date(value);
			var h = date.getHours() >= 10 ? date.getHours() : "0" + date.getHours();
			var m = date.getMinutes() >= 10 ? date.getMinutes() : "0" + date.getMinutes();
			return h + ":" + m;
		};
	},
	datetime: function datetime() {
		var date = formatFactory.date();
		var time = formatFactory.time();
		return function(value) {
			return date(value) + " " + time(value);
		};
	},
	ellipsis: function ellipsis(part0, length, where) {
		length = Number(length);
		if (!(length > 3)) length = 10;

		switch (where) {
			default:
			case "end":
				return function(value) {
					var s = String(value);
					if (s.length > length) return s.substring(0, length - 3) + "...";
					return s;
				};

			case "start":
				return function(value) {
					var s = String(value);
					if (s.length > length) return "..." + s.substring(s.length - length + 3);
					return s;
				};

			case "middle":
				return function(value) {
					var s = String(value);

					if (s.length > length) {
						var x = Math.floor(length - 2) / 2;
						return s.substring(0, x) + "..." + s.substring(s.length - (length - 3 - x));
					}

					return s;
				};
		}
	}
};
formatFactory.s = formatFactory.str = formatFactory.string;
formatFactory.f = formatFactory.fixed;
formatFactory.n = formatFactory.number;
formatFactory.p = formatFactory.percentage;
formatFactory.ps = formatFactory.percentageSign;
formatFactory.d = formatFactory.date;
formatFactory.t = formatFactory.time;
formatFactory.dt = formatFactory.datetime;

function buildFormatter(format) {
	var formatter = defaultFormatter,
		nullText = "";

	if (format) {
		var pipeParts = format.split("|");
		nullText = pipeParts[1] || "";
		var colonSepParts = pipeParts[0].split(":");

		for (var i = 0; i < colonSepParts.length; i++) {
			var parts = colonSepParts[i].split(";");
			var factory = formatFactory[parts[0]];
			if (!factory) debug("Unknown string format: " + format);
			else if (i == 0) formatter = factory.apply(void 0, parts);
			else {
				(function() {
					var outerFmt = factory.apply(void 0, parts);
					var innerFmt = formatter;

					formatter = function formatter(v) {
						return outerFmt(innerFmt(v));
					};
				})();
			}
		}
	}

	return function(v) {
		return v == null || v === "" ? nullText : formatter(v);
	};
}

var format = {
	cache: {}
};

function getFormatCache() {
	if (format.cacheIdentifier != GlobalCacheIdentifier.get()) {
		format = {
			cache: {},
			cacheIdentifier: GlobalCacheIdentifier.get()
		};
	}

	return format.cache;
}

function getFormatter(format) {
	if (!format) format = "";
	var formatCache = getFormatCache();
	var formatter = formatCache[format];
	if (!formatter) formatter = formatCache[format] = buildFormatter(format);
	return formatter;
}

var Format =
	/*#__PURE__*/
	(function() {
		function Format() {}

		Format.value = function value(v, format) {
			var formatter = getFormatter(format);
			return formatter(v);
		};

		Format.parse = function parse(format) {
			return getFormatter(format);
		};

		Format.register = function register(format, formatter) {
			this.registerFactory(format, function() {
				return formatter;
			});
		};

		Format.registerFactory = function registerFactory(format, factory) {
			var _this = this;

			if (isArray(format))
				format.forEach(function(f) {
					return _this.registerFactory(f, factory);
				});
			else formatFactory[format] = factory;
		};

		return Format;
	})();
function resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits) {
	minimumFractionDigits = minimumFractionDigits != null ? Number(minimumFractionDigits) : minimumFractionDigits;
	maximumFractionDigits = maximumFractionDigits != null ? Number(maximumFractionDigits) : maximumFractionDigits;

	if (isNumber(minimumFractionDigits)) {
		if (isUndefined(maximumFractionDigits)) maximumFractionDigits = minimumFractionDigits;
		else if (isNumber(maximumFractionDigits) && maximumFractionDigits < minimumFractionDigits)
			maximumFractionDigits = minimumFractionDigits;
	} else if (minimumFractionDigits == null && maximumFractionDigits == null) {
		minimumFractionDigits = 0;
		maximumFractionDigits = 18;
	}

	return {
		minimumFractionDigits: minimumFractionDigits,
		maximumFractionDigits: maximumFractionDigits
	};
}
function trimFractionZeros(str, max) {
	var cnt = 0,
		l = str.length;

	while (cnt < max && (str[l - 1 - cnt] === "0" || str[l - 1 - cnt] === ".")) {
		cnt++;
	}

	return cnt > 0 ? str.substring(0, l - cnt) : str;
}

function quoteStr(str) {
	if (str == null) return str;
	return "'" + str.replace(/'/g, "\\i") + "'";
}

function isDigit(x) {
	return x >= "0" && x <= "9";
}

/*
   Helper usage example

   Expression.registerHelper('_', _);
   let e = Expression.compile('_.min({data})');
 */

var expCache = {},
	helpers = {},
	helperNames = [],
	helperValues = [],
	expFatArrows = null;

function getExpr(expr) {
	if (expr.memoize) return expr;

	function memoize() {
		var lastValue,
			lastRunBindings = {},
			lastRunResults = {},
			getters = {},
			currentData,
			len = -1;

		var get = function get(bindingWithFormat) {
			var getter = getters[bindingWithFormat];

			if (!getter) {
				var binding = bindingWithFormat,
					format;
				var colonIndex = bindingWithFormat.indexOf(":");

				if (colonIndex != -1) {
					format = Format.parse(bindingWithFormat.substring(colonIndex + 1));
					binding = bindingWithFormat.substring(0, colonIndex);
				} else {
					var nullSeparatorIndex = bindingWithFormat.indexOf(":");

					if (nullSeparatorIndex != -1) {
						format = Format.parse(bindingWithFormat.substring(nullSeparatorIndex));
						binding = bindingWithFormat.substring(0, nullSeparatorIndex - 1);
					}
				}

				var b = Binding.get(binding);

				getter = function getter(data) {
					var value = b.value(data);
					lastRunBindings[len] = b.value;
					lastRunResults[len] = value;
					len++;
					return value;
				};

				if (format) {
					var valueGetter = getter;

					getter = function getter(data) {
						return format(valueGetter(data));
					};
				}

				getters[bindingWithFormat] = getter;
			}

			return getter(currentData);
		};

		return function(data) {
			var i = 0;

			for (; i < len; i++) {
				if (lastRunBindings[i](data) !== lastRunResults[i]) break;
			}

			if (i !== len) {
				len = 0;
				currentData = data;
				lastValue = expr(get);
			}

			return lastValue;
		};
	}

	var result = memoize();
	result.memoize = memoize;
	return result;
}

function expression(str) {
	var _ref;

	if (isFunction(str)) return getExpr(str);
	var r = expCache[str];
	if (r) return r;
	var quote = false;
	var termStart = -1,
		curlyBrackets = 0,
		percentExpression;
	var fb = ["return ("];
	var args = {};
	var formats = [];
	var subExpr = 0;

	for (var i = 0; i < str.length; i++) {
		var c = str[i];

		switch (c) {
			case "{":
				if (curlyBrackets > 0) curlyBrackets++;
				else {
					if (!quote && termStart < 0 && (str[i + 1] != "{" || str[i - 1] == "%")) {
						termStart = i + 1;
						curlyBrackets = 1;
						percentExpression = str[i - 1] == "%";
						if (percentExpression) fb.pop(); //%
					} else if (str[i - 1] != "{") fb.push(c);
				}
				break;

			case "}":
				if (termStart >= 0) {
					if (--curlyBrackets == 0) {
						var term = str.substring(termStart, i);
						var formatStart = 0;
						if (term[0] == "[") formatStart = term.indexOf("]");
						var colon = term.indexOf(":", formatStart > 0 ? formatStart : 0);
						var binding = colon == -1 ? term : term.substring(0, colon);
						var format = colon == -1 ? null : term.substring(colon + 1);

						if (colon == -1) {
							var nullSepIndex = binding.indexOf("|");

							if (nullSepIndex != -1) {
								format = binding.substring(nullSepIndex);
								binding = binding.substring(0, nullSepIndex);
							}
						}

						var argName = binding.replace(/\./g, "_");
						if (isDigit(argName[0])) argName = "$" + argName;

						if (percentExpression || (binding[0] == "[" && binding[binding.length - 1] == "]")) {
							argName = "expr" + ++subExpr;
							args[argName] = expression(percentExpression ? binding : binding.substring(1, binding.length - 1));
						} else args[argName] = binding;

						if (format) {
							var formatter = "fmt" + formats.length;
							fb.push(formatter, "(", argName, ", ", quoteStr(format), ")");
							formats.push(Format.parse(format));
						} else fb.push(argName);

						termStart = -1;
					}
				} else fb.push(c);

				break;

			case '"':
			case "'":
				if (curlyBrackets == 0) {
					if (!quote) quote = c;
					else if (str[i - 1] != "\\" && quote == c) quote = false;
					fb.push(c);
				}

				break;

			default:
				if (termStart < 0) fb.push(c);
				break;
		}
	}

	fb.push(")");
	var body = fb.join("");
	if (expFatArrows) body = expFatArrows(body); //console.log(body);

	var keys = Object.keys(args);

	var compute = (_ref = _construct(
		Function,
		formats
			.map(function(f, i) {
				return "fmt" + i;
			})
			.concat(keys, helperNames, [body])
	)).bind.apply(_ref, [Format].concat(formats, helperValues));

	var selector = computable.apply(
		void 0,
		keys
			.map(function(k) {
				return args[k];
			})
			.concat([compute])
	);
	expCache[str] = selector;
	return selector;
}
var Expression = {
	get: function get(str) {
		return expression(str);
	},
	compile: function compile(str) {
		return this.get(str).memoize();
	},
	registerHelper: function registerHelper(name, helper) {
		helpers[name] = helper;
		helperNames = Object.keys(helpers);
		helperValues = helperNames.map(function(n) {
			return helpers[n];
		});
	}
};

function plus(str) {
	return str.length ? str + " + " : str;
}

var tplCache = {};
function stringTemplate(str) {
	var expr = tplCache[str];
	if (expr) return expr;
	expr = "";
	var termStart = -1,
		quoteStart = 0,
		term,
		bracketsOpen = 0,
		percentSign;

	for (var i = 0; i < str.length; i++) {
		var c = str[i];

		switch (c) {
			case "{":
				if (termStart < 0) {
					if (str[i + 1] == "{" && str[i - 1] != "%") {
						expr = plus(expr) + quoteStr(str.substring(quoteStart, i) + "{");
						i++;
						quoteStart = i + 1;
					} else {
						termStart = i + 1;
						percentSign = str[i - 1] == "%";
						if (i > quoteStart) expr = plus(expr) + quoteStr(str.substring(quoteStart, percentSign ? i - 1 : i));
						bracketsOpen = 1;
					}
				} else bracketsOpen++;

				break;

			case "}":
				if (termStart >= 0) {
					if (--bracketsOpen == 0) {
						term = str.substring(termStart, i);

						if (term.indexOf(":") == -1) {
							var nullSepIndex = term.indexOf("|");
							if (nullSepIndex == -1) term += ":s";
							else term = term.substring(0, nullSepIndex) + ":s" + term.substring(nullSepIndex);
						}

						expr = plus(expr) + (percentSign ? "%{" : "{") + term + "}";
						termStart = -1;
						quoteStart = i + 1;
						bracketsOpen = 0;
					}
				} else if (str[i + 1] == "}") {
					expr = plus(expr) + quoteStr(str.substring(quoteStart, i) + "}");
					i++;
					quoteStart = i + 1;
				}

				break;
		}
	}

	if (quoteStart < str.length) expr = plus(expr) + quoteStr(str.substring(quoteStart)); //console.log(expr);

	return (tplCache[str] = expression(expr));
}
var StringTemplate = {
	get: function get(str) {
		return stringTemplate(str);
	},
	compile: function compile(str) {
		return stringTemplate(str).memoize();
	},
	format: function format(_format) {
		for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		return stringTemplate(_format)(args);
	}
};

function createStructuredSelector(selector, constants) {
	var keys = Object.keys(selector);
	if (keys.length == 0)
		return function() {
			return constants;
		};

	function memoize() {
		var lastResult = Object.assign({}, constants);
		var memoizedSelectors = {};
		keys.forEach(function(key) {
			memoizedSelectors[key] = selector[key].memoize ? selector[key].memoize() : selector[key];
		});
		return function(data) {
			var result = lastResult,
				k,
				v,
				i;

			for (i = 0; i < keys.length; i++) {
				k = keys[i];
				v = memoizedSelectors[k](data);

				if (result === lastResult) {
					if (v === lastResult[k]) continue;
					result = Object.assign({}, lastResult);
				}

				result[k] = v;
			}

			return (lastResult = result);
		};
	}

	function evaluate(data) {
		var result = Object.assign({}, constants);

		for (var i = 0; i < keys.length; i++) {
			result[keys[i]] = selector[keys[i]](data);
		}

		return result;
	}

	evaluate.memoize = memoize;
	return evaluate;
}

function isSelector(config) {
	if (config == null) return true;

	switch (typeof config) {
		case "object":
			if (config.type || config.$type) return false;
			return !!(config.bind || config.tpl || config.expr || config.get);

		case "function":
			return true;

		case "string":
			return true;

		case "number":
			return true;

		case "boolean":
			return true;
	}

	return false;
}

var nullF = function nullF() {
	return null;
};

function getSelector(config) {
	if (config == null) return nullF;

	switch (typeof config) {
		case "object":
			if (isArray(config)) {
				var _selectors = config.map(function(x) {
					return getSelector(x);
				});

				return function(data) {
					return _selectors.map(function(elementSelector) {
						return elementSelector(data);
					});
				};
			}

			if (config.bind) return Binding.get(config.bind).value;
			if (config.tpl) return StringTemplate.get(config.tpl);
			if (config.expr) return Expression.get(config.expr);
			if (config.get) return config.get;
			var selectors = {};
			var constants = {};

			for (var key in config) {
				if (isSelector(config[key])) selectors[key] = getSelector(config[key]);
				else constants[key] = config[key];
			}

			return createStructuredSelector(selectors, constants);

		case "function":
			return config;

		default:
			return function() {
				return config;
			};
	}
}

function isDefined(v) {
	return v !== undefined;
}

function defaultValue(pv) {
	if (typeof pv == "object" && pv && pv.structured) return pv.defaultValue;
	return pv;
}

function getSelectorConfig(props, values, nameMap) {
	var functions = {},
		structures = {},
		defaultValues = {},
		constants,
		p,
		v,
		pv,
		constant = true;

	for (p in props) {
		v = values[p];
		pv = props[p];
		if (isUndefined(v) && pv && (pv.bind || pv.tpl || pv.expr)) v = pv;

		if (v === null) {
			if (!constants) constants = {};
			constants[p] = null;
		} else if (typeof v == "object") {
			if (v.bind) {
				if (isUndefined(v.defaultValue) && v != pv) v.defaultValue = defaultValue(pv);
				if (isDefined(v.defaultValue)) defaultValues[v.bind] = v.defaultValue;
				nameMap[p] = v.bind;
				functions[p] = Binding.get(v.bind).value;
				constant = false;
			} else if (v.expr) {
				functions[p] = Expression.get(v.expr);
				constant = false;
			} else if (v.get) {
				functions[p] = v.get;
				constant = false;
			} else if (v.tpl) {
				functions[p] = StringTemplate.get(v.tpl);
				constant = false;
			} else if (pv && typeof pv == "object" && pv.structured) {
				if (isArray(v)) functions[p] = getSelector(v);
				else {
					var s = getSelectorConfig(v, v, {});
					structures[p] = s;
					Object.assign(defaultValues, s.defaultValues);
				}
				constant = false;
			} else {
				if (!constants) constants = {};
				constants[p] = v;
			}
		} else if (isFunction(v)) {
			functions[p] = v;
			constant = false;
		} else {
			if (isUndefined(v)) {
				if (isUndefined(pv)) continue;
				v = defaultValue(pv);
			}

			if (isUndefined(v)) continue;
			if (!constants) constants = {};
			constants[p] = v;
		}
	}

	return {
		functions: functions,
		structures: structures,
		defaultValues: defaultValues,
		constants: constants,
		constant: constant
	};
}

function createSelector(_ref) {
	var functions = _ref.functions,
		structures = _ref.structures,
		constants = _ref.constants,
		defaultValues = _ref.defaultValues;
	var selector = {};

	for (var n in functions) {
		selector[n] = functions[n];
	}

	for (var _n in structures) {
		selector[_n] = createSelector(structures[_n]);
	}

	return createStructuredSelector(selector, constants);
}

var StructuredSelector =
	/*#__PURE__*/
	(function() {
		function StructuredSelector(_ref2) {
			var props = _ref2.props,
				values = _ref2.values;
			this.nameMap = {};
			this.config = getSelectorConfig(props, values, this.nameMap);
		}

		var _proto = StructuredSelector.prototype;

		_proto.init = function init(store) {
			store.init(this.config.defaultValues);
		};

		_proto.create = function create() {
			var selector = createSelector(this.config);
			if (selector.memoize) return selector.memoize();
			return selector;
		};

		_proto.createStoreSelector = function createStoreSelector() {
			if (this.config.constant) {
				var result = _objectSpread({}, this.config.constants);

				return function() {
					return result;
				};
			}

			var selector = this.create();
			return function(store) {
				return selector(store.getData());
			};
		};

		return StructuredSelector;
	})();

var VDOM$1 = VDOM;

var VDOM$2 = VDOM$1;
var widgetId = 100;
var Widget =
	/*#__PURE__*/
	(function(_Component) {
		_inheritsLoose(Widget, _Component);

		function Widget(config) {
			var _this;

			_this = _Component.call(this, config) || this;
			_this.widgetId = widgetId++;

			if (isArray(_this.jsxSpread)) {
				if (!_this.jsxAttributes) _this.jsxAttributes = [];

				_this.jsxSpread.forEach(function(spread) {
					for (var key in spread) {
						_this[key] = spread[key];

						_this.jsxAttributes.push(key);
					}
				});
			}

			return _this;
		}

		var _proto = Widget.prototype;

		_proto.init = function init() {
			if (this.styles) this.style = this.styles;
			if (this.styled) this.style = parseStyle(this.style);
			else if (this.style) {
				Console.warn(
					"Components that allow use of the style attribute should set styled = true on their prototype. This will be an error in future versions."
				);
				this.style = parseStyle(this.style);
				this.styled = true;
			}
			if (typeof this.if !== "undefined") this.visible = this.if;
			this.declareData();

			if (this.outerLayout) {
				if (isArray(this.outerLayout)) throw new Error("Only single element outer layout is supported."); //TODO: better handle the case when outer layout is an array. How to get around circular dependency to PureContainer

				this.outerLayout = Widget.create(this.outerLayout);
			}

			if (this.contentFor) this.putInto = this.contentFor;
			if (this.putInto) this.isContent = true;
			if (isString(this.CSS)) this.CSS = CSSHelper.get(this.CSS);
			this.initHelpers();
			this.initComponents();
			this.initialized = true;
		};

		_proto.initComponents = function initComponents() {
			if (arguments.length > 0) {
				this.components = Object.assign.apply(Object, arguments);

				for (var k in this.components) {
					if (!this.components[k]) delete this.components[k];
				}
			}
		};

		_proto.initHelpers = function initHelpers() {
			if (arguments.length > 0) {
				this.helpers = Object.assign.apply(Object, arguments);
			}
		};

		_proto.declareData = function declareData() {
			var options = {};
			if (this.styled)
				options.class = options.className = options.style = {
					structured: true
				};

			var props = _objectSpread(
				{
					visible: undefined,
					mod: {
						structured: true
					}
				},
				options
			);

			Object.assign.apply(Object, [props].concat(Array.prototype.slice.call(arguments)));
			this.selector = new StructuredSelector({
				props: props,
				values: this
			});
			this.nameMap = this.selector.nameMap;
		};

		_proto.prepareCSS = function prepareCSS(context, _ref) {
			var data = _ref.data;
			data.classNames = this.CSS.expand(
				this.CSS.block(this.baseClass, data.mod, data.stateMods),
				data.class,
				data.className
			);
			data.style = parseStyle(data.style);
		};

		_proto.prepareData = function prepareData(context, instance) {
			if (this.styled) this.prepareCSS(context, instance);
		};

		_proto.initInstance = function initInstance(context, instance) {
			if (this.onInit) this.onInit(context, instance);
		};

		_proto.initState = function initState(context, instance) {};

		_proto.checkVisible = function checkVisible(context, instance, data) {
			return data.visible;
		};

		_proto.explore = function explore(context, instance) {
			if (this.components) instance.components = {};

			for (var cmp in this.components) {
				var ins = instance.getChild(context, this.components[cmp], "cmp-" + cmp, instance.store);
				if (ins.scheduleExploreIfVisible(context)) instance.components[cmp] = ins;
			}
		};

		_proto.render = function render(context, instance, key) {
			throw new Error(
				"Widget's render method should be overridden. This error can happen if you forgot to import the component before using it."
			);
		};

		_proto.update = function update() {
			this.version = (this.version || 0) + 1;
		};

		Widget.resetCounter = function resetCounter() {
			widgetId = 100;
		};

		return Widget;
	})(Component);
Widget.prototype.visible = true;
Widget.prototype.memoize = true; //cache rendered content and use it if possible

Widget.prototype.CSS = "cx";
Widget.prototype.styled = false;
Widget.namespace = "ui.";
Widget.optimizePrepare = true;

Widget.factory = function(type, config, more) {
	throw new Error("Invalid widget type: " + type + ".");
};

function contentAppend(result, w, prependSpace) {
	if (w == null || w === false) return false;
	if (isArray(w))
		w.forEach(function(c) {
			return contentAppend(result, c);
		});
	else if (isDefined(w.content) && !w.atomic) return contentAppend(result, w.content);
	else {
		if (prependSpace) result.push(" ");
		result.push(w);
	}
	return true;
}

var StaticText =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(StaticText, _Widget);

		function StaticText() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = StaticText.prototype;

		_proto.render = function render() {
			return this.text;
		};

		return StaticText;
	})(Widget);
Widget.alias("static-text", StaticText);

var Text =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(Text, _Widget);

		function Text() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = Text.prototype;

		_proto.init = function init() {
			if (!this.value && (this.tpl || this.expr || this.bind))
				this.value = {
					tpl: this.tpl,
					expr: this.expr,
					bind: this.bind
				};

			_Widget.prototype.init.call(this);
		};

		_proto.declareData = function declareData() {
			var _Widget$prototype$dec;

			(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
				_Widget$prototype$dec,
				[
					this,
					{
						value: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.render = function render(context, _ref, key) {
			var data = _ref.data;
			return data.value != null ? data.value : "";
		};

		return Text;
	})(Widget);
Widget.alias("text", Text);

function innerTextTrim(str) {
	str = str.replace(/\t/g, "");
	str = str.replace(/(\s*[\r\n]\s*)/g, "");
	return str;
}

function exploreChildren(context, instance, children, previousResult, key, store, beforeCallback, afterCallback) {
	var newChildren = previousResult || [];
	var oldChildren = previousResult || newChildren;
	var identical = previousResult ? 0 : -1; // if (children.length)
	//    context.exploreStack.hop();

	for (var c = 0; c < children.length; c++) {
		var cell = instance.getChild(context, children[c], key, store); // if (beforeCallback)
		//    beforeCallback(cell);

		if (cell.checkVisible(context)) {
			if (identical >= 0) {
				if (cell == oldChildren[identical]) identical++;
				else {
					newChildren = newChildren.slice(0, identical);
					identical = -1;
					newChildren.push(cell);
				}
			} else newChildren.push(cell);

			context.exploreStack.push(cell);
			if (cell.needsExploreCleanup) context.exploreStack.push(cell);
		}
	}

	if (identical >= 0 && identical != newChildren.length) newChildren = newChildren.slice(0, identical);
	return newChildren;
}

var Container =
	/*#__PURE__*/
	(function(_Widget) {
		_inheritsLoose(Container, _Widget);

		function Container() {
			return _Widget.apply(this, arguments) || this;
		}

		var _proto = Container.prototype;

		_proto.init = function init(context) {
			if (typeof this.ws !== "undefined") this.preserveWhitespace = this.ws;
			if (this.preserveWhitespace) this.trimWhitespace = false;
			var items = this.items || this.children || [];
			delete this.children;
			this.items = [];

			if (this.layout) {
				var layout = Widget.create({
					type: this.layout,
					items: items
				});
				layout.init(context);
				this.layout = null;

				if (layout.noLayout) {
					this.useParentLayout = true;
					this.add(items);
				} else {
					this.add(layout);
					this.layout = layout;
				}
			} else {
				this.add(items);
			}

			_Widget.prototype.init.call(this, context);
		};

		_proto.exploreItems = function exploreItems(context, instance, items) {
			instance.children = exploreChildren(context, instance, items, instance.cached.children);
			if (instance.cache("children", instance.children)) instance.markShouldUpdate(context);
		};

		_proto.explore = function explore(context, instance) {
			_Widget.prototype.explore.call(this, context, instance);

			this.exploreItems(context, instance, this.items);
		};

		_proto.render = function render(context, instance) {
			return this.renderChildren(context, instance);
		};

		_proto.renderChildren = function renderChildren(context, instance) {
			var preserveComplexContent = this.useParentLayout;

			function append(result, r) {
				if (r == null) return; //react element

				if (!r.hasOwnProperty("content")) {
					contentAppend(result, r);
					return;
				}

				if (r.useParentLayout)
					return r.content.forEach(function(x) {
						return append(result, x);
					});

				if (r.atomic || preserveComplexContent) {
					result.push(r);
				} else {
					var first = true;

					for (var k in r) {
						if (contentAppend(result, r[k], !first)) first = false;
					}
				}
			}

			var result = [];

			for (var i = 0; i < instance.children.length; i++) {
				append(result, instance.children[i].vdom);
			}

			if (this.useParentLayout)
				return {
					useParentLayout: true,
					content: result
				};
			return result;
		};

		_proto.clear = function clear() {
			if (this.layout) this.layout.clear();
			else this.items = [];
		};

		_proto.add = function add() {
			var _this$layout,
				_this = this;

			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			if (this.layout) return (_this$layout = this.layout).add.apply(_this$layout, args);
			args.forEach(function(a) {
				if (!a) return;
				if (isArray(a))
					a.forEach(function(c) {
						return _this.add(c);
					});
				else if (isString(a)) {
					if (_this.trimWhitespace) a = innerTextTrim(a);
					if (a) _this.addText(a);
				} else if (a.isComponent) _this.items.push(_this.wrapItem(a));
				else {
					_this.add(Widget.create(a, _this.itemDefaults));
				}
			});
		};

		_proto.wrapItem = function wrapItem(item) {
			return item;
		};

		_proto.addText = function addText(text) {
			if (this.plainText || text.indexOf("{") == -1 || text.indexOf("}") == -1)
				this.add(
					Widget.create(StaticText, {
						text: text
					})
				);
			else
				this.add(
					Widget.create(Text, {
						text: {
							tpl: text
						}
					})
				);
		};

		_proto.find = function find(filter, options) {
			if (!options) options = {};
			if (!filter || !this.items) return [];
			var alias = filter;
			if (isString(filter))
				filter = function filter(w) {
					return w.componentAlias == alias;
				};
			if (filter.isComponentType)
				filter = function filter(w) {
					return w instanceof alias;
				};
			var results = [];

			for (var i = 0; i < this.items.length; i++) {
				var w = this.items[i];
				if (!w.initialized) w.init();

				if (filter(w)) {
					results.push(w);
					if (options.first) break;
				}

				if (w.find) results.push.apply(results, w.find(filter, options));
			}

			return results;
		};

		_proto.findFirst = function findFirst(filter, options) {
			return this.find(
				filter,
				_objectSpread({}, options, {
					first: true
				})
			)[0];
		};

		return Container;
	})(Widget);
Container.prototype.trimWhitespace = true;
Container.prototype.plainText = true;
Container.prototype.styled = false;

var PureContainer =
	/*#__PURE__*/
	(function(_Container) {
		_inheritsLoose(PureContainer, _Container);

		function PureContainer() {
			return _Container.apply(this, arguments) || this;
		}

		return PureContainer;
	})(Container);
PureContainer.prototype.isPureContainer = true;
PureContainer.alias("pure-container", PureContainer);

var BoundedObject =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(BoundedObject, _PureContainer);

		function BoundedObject() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = BoundedObject.prototype;

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[
					this,
					{
						anchors: undefined,
						offset: undefined,
						margin: undefined,
						padding: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			_PureContainer.prototype.prepareData.call(this, context, instance);

			var data = instance.data;
			data.anchors = Rect.convert(data.anchors);
			data.offset = Rect.convert(data.offset);
			data.margin = Rect.convertMargin(data.margin);
			data.padding = Rect.convertMargin(data.padding);
		};

		_proto.calculateBounds = function calculateBounds(context, instance) {
			var data = instance.data;
			return Rect.add(Rect.add(Rect.multiply(instance.parentRect, data.anchors), data.offset), data.margin);
		};

		_proto.prepareBounds = function prepareBounds(context, instance) {
			var data = instance.data;

			if (
				instance.shouldUpdate ||
				!instance.cached.parentRect ||
				!instance.cached.parentRect.isEqual(context.parentRect) ||
				!data.bounds
			) {
				if (!context.parentRect) throw new Error("Parent bounds were not provided through the context.");
				instance.parentRect = context.parentRect;
				instance.cache("parentRect", context.parentRect);
				instance.markShouldUpdate(context);
				data.bounds = this.calculateBounds(context, instance);
				data.childrenBounds = Rect.add(data.bounds, data.padding);
			}
		};

		_proto.prepare = function prepare(context, instance) {
			this.prepareBounds(context, instance);
			context.push("parentRect", instance.data.childrenBounds);
		};

		_proto.prepareCleanup = function prepareCleanup(context, instance) {
			context.pop("parentRect");
		};

		return BoundedObject;
	})(PureContainer);
BoundedObject.prototype.anchors = 0;
BoundedObject.prototype.margin = 0;
BoundedObject.prototype.offset = 0;
BoundedObject.prototype.padding = 0;
BoundedObject.prototype.isPureContainer = false;
BoundedObject.prototype.styled = true;

var Text$1 =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(Text, _BoundedObject);

		function Text() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = Text.prototype;

		_proto.declareData = function declareData() {
			var _BoundedObject$protot;

			return (_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
				_BoundedObject$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						value: undefined,
						dx: undefined,
						dy: undefined,
						textAnchor: undefined,
						fill: undefined,
						stroke: undefined
					}
				])
			);
		};

		_proto.init = function init() {
			if (this.ta) this.textAnchor = this.ta;

			if (this.bind) {
				this.value = {
					bind: this.bind
				};
			} else if (this.tpl) {
				this.value = {
					tpl: this.tpl
				};
			} else if (this.expr) {
				this.value = {
					expr: this.expr
				};
			}

			_BoundedObject.prototype.init.call(this);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			var bounds = data.bounds;
			return VDOM$2.createElement(
				"text",
				{
					key: key,
					className: data.classNames,
					x: bounds.l,
					y: bounds.t,
					dx: data.dx,
					dy: data.dy,
					textAnchor: data.textAnchor,
					style: data.style,
					fill: data.fill,
					stroke: data.stroke
				},
				data.value,
				this.renderChildren(context, instance)
			);
		};

		return Text;
	})(BoundedObject);
Text$1.prototype.anchors = "0.5 0.5 0.5 0.5";
Text$1.prototype.baseClass = "text";
Widget.alias("svg.text", Text$1);

var TextualBoundedObject =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(TextualBoundedObject, _BoundedObject);

		function TextualBoundedObject() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = TextualBoundedObject.prototype;

		_proto.add = function add(widget) {
			if (typeof widget != "string") return _BoundedObject.prototype.add.apply(this, arguments);
			if (this.trimWhitespace) widget = innerTextTrim(widget);
			if (!widget) return;
			return this.add({
				type: Text$1,
				value: widget,
				textAnchor: "middle",
				dy: "0.4em"
			});
		};

		return TextualBoundedObject;
	})(BoundedObject);

var SubscriberList =
	/*#__PURE__*/
	(function() {
		function SubscriberList() {
			this.clear();
		}

		var _proto = SubscriberList.prototype;

		_proto.getSlot = function getSlot() {
			if (this.freeSlots.length) return this.freeSlots.pop();
			var slot = String(this.nextSlot++);
			return slot;
		};

		_proto.recycle = function recycle(slot, callback) {
			if (this.subscriptions[slot] === callback) {
				this.freeSlots.push(slot);
				delete this.subscriptions[slot];
				this.subscriptionCount--;
			}
		};

		_proto.subscribe = function subscribe(callback) {
			var _this = this;

			var slot = this.getSlot();
			this.subscriptions[slot] = callback;
			this.subscriptionCount++;
			return function() {
				_this.recycle(slot, callback);
			};
		};

		_proto.clear = function clear() {
			this.subscriptions = {};
			this.freeSlots = [];
			this.nextSlot = 1;
			this.subscriptionCount = 0;
		};

		_proto.isEmpty = function isEmpty() {
			return this.subscriptionCount == 0;
		};

		_proto.getSubscribers = function getSubscribers() {
			var result = [];

			for (var key in this.subscriptions) {
				result.push(this.subscriptions[key]);
			}

			return result;
		};

		_proto.notify = function notify() {
			for (var key in this.subscriptions) {
				var _this$subscriptions;

				(_this$subscriptions = this.subscriptions)[key].apply(_this$subscriptions, arguments);
			}
		};

		_proto.execute = function execute(callback) {
			for (var key in this.subscriptions) {
				callback(this.subscriptions[key]);
			}
		};

		return SubscriberList;
	})();

var promiseSubscribers = new SubscriberList();
function batchUpdates(callback) {
	if (VDOM$2.DOM.unstable_batchedUpdates)
		VDOM$2.DOM.unstable_batchedUpdates(function() {
			try {
				callback();
			} finally {
			}
		});
	else callback();
}

var subscribers = new SubscriberList();
var ResizeManager =
	/*#__PURE__*/
	(function() {
		function ResizeManager() {}

		ResizeManager.subscribe = function subscribe(callback) {
			return subscribers.subscribe(callback);
		};

		ResizeManager.notify = function notify() {
			batchUpdates(function() {
				subscribers.notify();
			});
		};

		ResizeManager.trackElement = function trackElement(el, callback) {
			if (typeof ResizeObserver !== "function") return this.subscribe(callback);
			var obs = new ResizeObserver(callback);
			obs.observe(el);
			return function() {
				obs.disconnect();
			};
		};

		return ResizeManager;
	})();
if (typeof window != "undefined")
	window.addEventListener("resize", function() {
		return ResizeManager.notify();
	});

var Svg =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(Svg, _BoundedObject);

		function Svg() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = Svg.prototype;

		_proto.initState = function initState(context, instance) {
			var size = {
				width: 0,
				height: 0
			};
			instance.state = {
				size: size
			};
		};

		_proto.prepare = function prepare(context, instance) {
			var size = instance.state.size;
			context.parentRect = new Rect({
				l: 0,
				t: 0,
				r: size.width,
				b: size.height
			});
			instance.clipRects = {};
			instance.clipRectId = 0;
			context.push("addClipRect", function(rect) {
				var id = "clip-" + instance.id + "-" + ++instance.clipRectId;
				instance.clipRects[id] = rect;
				return id;
			});

			_BoundedObject.prototype.prepare.call(this, context, instance);
		};

		_proto.prepareCleanup = function prepareCleanup(context, instance) {
			_BoundedObject.prototype.prepareCleanup.call(this, context, instance);

			context.pop("addClipRect");
		};

		_proto.render = function render(context, instance, key) {
			return VDOM$2.createElement(
				SvgComponent,
				{
					key: key,
					instance: instance,
					data: instance.data,
					options: context.options,
					size: instance.state.size
				},
				this.renderChildren(context, instance)
			);
		};

		return Svg;
	})(BoundedObject);
Svg.prototype.anchors = "0 1 1 0";
Svg.prototype.baseClass = "svg";
Svg.prototype.autoWidth = false;
Svg.prototype.autoHeight = false;
Svg.prototype.aspectRatio = 1.618;

function sameSize(a, b) {
	if (!a || !b) return false;
	return a.width == b.width && a.height == b.height;
}

var SvgComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(SvgComponent, _VDOM$Component);

		function SvgComponent() {
			return _VDOM$Component.apply(this, arguments) || this;
		}

		var _proto2 = SvgComponent.prototype;

		_proto2.render = function render() {
			var _this = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				data = _this$props.data,
				size = _this$props.size,
				children = _this$props.children;
			var widget = instance.widget;
			var defs = [];

			for (var k in instance.clipRects) {
				var cr = instance.clipRects[k];
				defs.push(
					VDOM$2.createElement(
						"clipPath",
						{
							key: k,
							id: k
						},
						VDOM$2.createElement("rect", {
							x: cr.l,
							y: cr.t,
							width: Math.max(0, cr.width()),
							height: Math.max(0, cr.height())
						})
					)
				);
			}

			var style = data.style;
			if (widget.autoHeight)
				style = _objectSpread({}, style, {
					height: size.height + "px"
				});
			if (widget.autoWidth)
				style = _objectSpread({}, style, {
					width: size.width + "px"
				}); //parent div is needed because clientWidth doesn't work on the svg element in FF

			return VDOM$2.createElement(
				"div",
				{
					ref: function ref(el) {
						_this.el = el;
					},
					className: data.classNames,
					style: style
				},
				size.width > 0 &&
					size.height > 0 &&
					VDOM$2.createElement("svg", null, VDOM$2.createElement("defs", null, defs), children)
			);
		};

		_proto2.onResize = function onResize() {
			var instance = this.props.instance;
			var widget = this.props.instance.widget;
			var size = {
				width: this.el.clientWidth,
				height: this.el.clientHeight
			};
			if (widget.autoHeight) size.height = size.width / widget.aspectRatio;
			if (widget.autoWidth) size.width = size.height * widget.aspectRatio;
			if (!sameSize(instance.state.size, size))
				instance.setState({
					size: size
				});
		};

		_proto2.componentDidMount = function componentDidMount() {
			this.offResize = ResizeManager.trackElement(this.el, this.onResize.bind(this));
			this.onResize();
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			this.onResize();
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			if (this.offResize) {
				this.offResize();
				delete this.offResize;
			}
		};

		return SvgComponent;
	})(VDOM$2.Component);

Widget.alias("svg", Svg);

var Rectangle =
	/*#__PURE__*/
	(function(_TextualBoundedObject) {
		_inheritsLoose(Rectangle, _TextualBoundedObject);

		function Rectangle() {
			return _TextualBoundedObject.apply(this, arguments) || this;
		}

		var _proto = Rectangle.prototype;

		_proto.declareData = function declareData() {
			var _TextualBoundedObject2;

			(_TextualBoundedObject2 = _TextualBoundedObject.prototype.declareData).call.apply(
				_TextualBoundedObject2,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						colorIndex: undefined,
						fill: undefined,
						stroke: undefined
					}
				])
			);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			var bounds = data.bounds,
				colorIndex = data.colorIndex;
			if (!bounds.valid()) return false;
			return VDOM$2.createElement(
				"g",
				{
					key: key,
					className: data.classNames
				},
				VDOM$2.createElement("rect", {
					className: this.CSS.element(this.baseClass, "rect", colorIndex != null && "color-" + colorIndex),
					x: bounds.l,
					y: bounds.t,
					width: bounds.width(),
					height: bounds.height(),
					style: data.style,
					fill: data.fill,
					stroke: data.stroke
				}),
				this.renderChildren(context, instance)
			);
		};

		return Rectangle;
	})(TextualBoundedObject);
Rectangle.prototype.baseClass = "rectangle";
Rectangle.prototype.anchors = "0 1 1 0";
Widget.alias("rectangle", Rectangle);

var ClipRect =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(ClipRect, _BoundedObject);

		function ClipRect() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = ClipRect.prototype;

		_proto.prepareBounds = function prepareBounds(context, instance) {
			_BoundedObject.prototype.prepareBounds.call(this, context, instance);

			var data = instance.data;
			data.clipId = context.addClipRect(data.bounds);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			return VDOM$2.createElement(
				"g",
				{
					key: key,
					clipPath: "url(#" + data.clipId + ")"
				},
				this.renderChildren(context, instance)
			);
		};

		return ClipRect;
	})(BoundedObject);
ClipRect.prototype.anchors = "0 1 1 0";

var Ellipse =
	/*#__PURE__*/
	(function(_TextualBoundedObject) {
		_inheritsLoose(Ellipse, _TextualBoundedObject);

		function Ellipse() {
			return _TextualBoundedObject.apply(this, arguments) || this;
		}

		var _proto = Ellipse.prototype;

		_proto.declareData = function declareData() {
			var _TextualBoundedObject2;

			(_TextualBoundedObject2 = _TextualBoundedObject.prototype.declareData).call.apply(
				_TextualBoundedObject2,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						colorIndex: undefined,
						fill: undefined,
						stroke: undefined
					}
				])
			);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			var bounds = data.bounds,
				colorIndex = data.colorIndex;
			if (!bounds.valid()) return false;
			return VDOM$2.createElement(
				"g",
				{
					key: key,
					className: data.classNames
				},
				VDOM$2.createElement("ellipse", {
					className: this.CSS.element(this.baseClass, "rect", colorIndex != null && "color-" + colorIndex),
					cx: (bounds.l + bounds.r) / 2,
					cy: (bounds.t + bounds.b) / 2,
					rx: bounds.width() / 2,
					ry: bounds.height() / 2,
					style: data.style,
					fill: data.fill,
					stroke: data.stroke
				}),
				this.renderChildren(context, instance)
			);
		};

		return Ellipse;
	})(TextualBoundedObject);
Ellipse.prototype.baseClass = "ellipse";
Ellipse.prototype.anchors = "0 1 1 0";
Widget.alias("ellipse", Ellipse);

var Line =
	/*#__PURE__*/
	(function(_TextualBoundedObject) {
		_inheritsLoose(Line, _TextualBoundedObject);

		function Line() {
			return _TextualBoundedObject.apply(this, arguments) || this;
		}

		var _proto = Line.prototype;

		_proto.declareData = function declareData() {
			var _TextualBoundedObject2;

			(_TextualBoundedObject2 = _TextualBoundedObject.prototype.declareData).call.apply(
				_TextualBoundedObject2,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						colorIndex: undefined,
						stroke: undefined
					}
				])
			);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data,
				colorIndex = instance.colorIndex;
			var bounds = data.bounds;
			return VDOM$2.createElement(
				"g",
				{
					key: key,
					className: data.classNames
				},
				VDOM$2.createElement("line", {
					className: this.CSS.element(this.baseClass, "line", colorIndex != null && "color-" + colorIndex),
					x1: bounds.l,
					y1: bounds.t,
					x2: bounds.r,
					y2: bounds.b,
					style: data.style,
					stroke: data.stroke
				}),
				this.renderChildren(context, instance)
			);
		};

		return Line;
	})(TextualBoundedObject);
Line.prototype.anchors = "0 1 1 0";
Line.prototype.baseClass = "line";
Widget.alias("line", Line);

export { Rect, BoundedObject, TextualBoundedObject, Svg, Rectangle, ClipRect, Ellipse, Line, Text$1 as Text };
